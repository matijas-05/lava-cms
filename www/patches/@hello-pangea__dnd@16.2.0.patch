diff --git a/dist/dnd.cjs.js b/dist/dnd.cjs.js
index e6aba47f725ec2e6166d03ecc4c5ae9e55bf228c..70a54d598cb812e3edbd99e881141a4e641267d9 100644
--- a/dist/dnd.cjs.js
+++ b/dist/dnd.cjs.js
@@ -1,7 +1,5 @@
 'use strict';
 
-Object.defineProperty(exports, '__esModule', { value: true });
-
 var React = require('react');
 var ReactDOM = require('react-dom');
 var redux = require('redux');
@@ -12,19 +10,9 @@ var memoizeOne = require('memoize-one');
 var rafSchd = require('raf-schd');
 var _extends = require('@babel/runtime/helpers/extends');
 
-function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
-
-var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
-var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
-var memoizeOne__default = /*#__PURE__*/_interopDefaultLegacy(memoizeOne);
-var rafSchd__default = /*#__PURE__*/_interopDefaultLegacy(rafSchd);
-var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
-
 const isProduction$1 = process.env.NODE_ENV === 'production';
-
 const spacesAndTabs = /[ \t]{2,}/g;
 const lineStartWithSpaces = /^[ \t]*/gm;
-
 const clean$2 = value => value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
 const getDevMessage = message => clean$2(`
   %c@hello-pangea/dnd
@@ -33,20 +21,15 @@ const getDevMessage = message => clean$2(`
 
   %c👷‍ This is a development only message. It will be removed in production builds.
 `);
-const getFormattedMessage = message => [getDevMessage(message),
-'color: #00C584; font-size: 1.2em; font-weight: bold;',
-'line-height: 1.5',
-'color: #723874;'];
+const getFormattedMessage = message => [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];
 const isDisabledFlag = '__@hello-pangea/dnd-disable-dev-warnings';
 function log(type, message) {
   if (isProduction$1) {
     return;
   }
-
   if (typeof window !== 'undefined' && window[isDisabledFlag]) {
     return;
   }
-
   console[type](...getFormattedMessage(message));
 }
 const warning = log.bind(null, 'warn');
@@ -68,7 +51,6 @@ function bindEvents(el, bindings, sharedOptions) {
       el.removeEventListener(binding.eventName, binding.fn, options);
     };
   });
-
   return function unbindAll() {
     unbindings.forEach(unbind => {
       unbind();
@@ -82,7 +64,6 @@ class RbdInvariant extends Error {}
 RbdInvariant.prototype.toString = function toString() {
   return this.message;
 };
-
 function invariant(condition, message) {
   if (condition) {
     return;
@@ -94,7 +75,7 @@ function invariant(condition, message) {
   }
 }
 
-class ErrorBoundary extends React__default["default"].Component {
+class ErrorBoundary extends React.Component {
   constructor() {
     super(...arguments);
     this.callbacks = null;
@@ -140,7 +121,6 @@ class ErrorBoundary extends React__default["default"].Component {
       this.setState({});
       return;
     }
-
     throw err;
   }
   componentWillUnmount() {
@@ -157,7 +137,6 @@ const dragHandleUsageInstructions = `
   Some screen readers may require you to be in focus mode or to use your pass through key
 `;
 const position = index => index + 1;
-
 const onDragStart = start => `
   You have lifted an item in position ${position(start.source.index)}
 `;
@@ -258,7 +237,6 @@ const negate = point => ({
   x: point.x !== 0 ? -point.x : 0,
   y: point.y !== 0 ? -point.y : 0
 });
-
 const patch = function (line, value, otherValue) {
   if (otherValue === void 0) {
     otherValue = 0;
@@ -274,11 +252,8 @@ const patch = function (line, value, otherValue) {
     y: value
   };
 };
-
 const distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
-
 const closest$1 = (target, points) => Math.min(...points.map(point => distance(target, point)));
-
 const apply = fn => point => ({
   x: fn(point.x),
   y: fn(point.y)
@@ -366,7 +341,6 @@ var scrollDroppable = ((droppable, newScroll) => {
   const scrollable = droppable.frame;
   const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
   const scrollDisplacement = negate(scrollDiff);
-
   const frame = {
     ...scrollable,
     scroll: {
@@ -393,20 +367,19 @@ var scrollDroppable = ((droppable, newScroll) => {
   return result;
 });
 
-const toDroppableMap = memoizeOne__default["default"](droppables => droppables.reduce((previous, current) => {
+const toDroppableMap = memoizeOne(droppables => droppables.reduce((previous, current) => {
   previous[current.descriptor.id] = current;
   return previous;
 }, {}));
-const toDraggableMap = memoizeOne__default["default"](draggables => draggables.reduce((previous, current) => {
+const toDraggableMap = memoizeOne(draggables => draggables.reduce((previous, current) => {
   previous[current.descriptor.id] = current;
   return previous;
 }, {}));
-const toDroppableList = memoizeOne__default["default"](droppables => Object.values(droppables));
-const toDraggableList = memoizeOne__default["default"](draggables => Object.values(draggables));
+const toDroppableList = memoizeOne(droppables => Object.values(droppables));
+const toDraggableList = memoizeOne(draggables => Object.values(draggables));
 
-var getDraggablesInsideDroppable = memoizeOne__default["default"]((droppableId, draggables) => {
-  const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId)
-  .sort((a, b) => a.descriptor.index - b.descriptor.index);
+var getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {
+  const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId).sort((a, b) => a.descriptor.index - b.descriptor.index);
   return result;
 });
 
@@ -423,7 +396,7 @@ function tryGetCombine(impact) {
   return null;
 }
 
-var removeDraggableFromList = memoizeOne__default["default"]((remove, list) => list.filter(item => item.descriptor.id !== remove.descriptor.id));
+var removeDraggableFromList = memoizeOne((remove, list) => list.filter(item => item.descriptor.id !== remove.descriptor.id));
 
 var moveToNextCombine = (_ref => {
   let {
@@ -459,7 +432,6 @@ var moveToNextCombine = (_ref => {
     return closestId ? getImpact(closestId) : null;
   }
   const withoutDraggable = removeDraggableFromList(draggable, insideDestination);
-
   if (!closestId) {
     if (!withoutDraggable.length) {
       return null;
@@ -467,11 +439,9 @@ var moveToNextCombine = (_ref => {
     const last = withoutDraggable[withoutDraggable.length - 1];
     return getImpact(last.descriptor.id);
   }
-
   const indexOfClosest = withoutDraggable.findIndex(d => d.descriptor.id === closestId);
   !(indexOfClosest !== -1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;
   const proposedIndex = indexOfClosest - 1;
-
   if (proposedIndex < 0) {
     return null;
   }
@@ -503,26 +473,22 @@ var isPartiallyVisibleThroughFrame = (frame => {
   const isWithinVertical = isWithin(frame.top, frame.bottom);
   const isWithinHorizontal = isWithin(frame.left, frame.right);
   return subject => {
-
     const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
     if (isContained) {
       return true;
     }
     const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
     const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
-
     const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
     if (isPartiallyContained) {
       return true;
     }
     const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
     const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
-
     const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
     if (isTargetBiggerThanFrame) {
       return true;
     }
-
     const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
     return isTargetBiggerOnOneAxis;
   };
@@ -579,7 +545,6 @@ const isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {
   if (!destination.subject.active) {
     return false;
   }
-
   return isVisibleThroughFrameFn(destination.subject.active)(target);
 };
 const isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);
@@ -611,7 +576,6 @@ const getShouldAnimate = (id, last, forceShouldAnimate) => {
   if (typeof forceShouldAnimate === 'boolean') {
     return forceShouldAnimate;
   }
-
   if (!last) {
     return true;
   }
@@ -619,17 +583,14 @@ const getShouldAnimate = (id, last, forceShouldAnimate) => {
     invisible,
     visible
   } = last;
-
   if (invisible[id]) {
     return false;
   }
   const previous = visible[id];
   return previous ? previous.shouldAnimate : true;
 };
-
 function getTarget(draggable, displacedBy) {
   const marginBox = draggable.page.marginBox;
-
   const expandBy = {
     top: displacedBy.point.y,
     right: 0,
@@ -661,7 +622,6 @@ function getDisplacementGroups(_ref) {
       groups.invisible[draggable.descriptor.id] = true;
       return groups;
     }
-
     const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
     const displacement = {
       draggableId: id,
@@ -681,7 +641,6 @@ function getIndexOfLastItem(draggables, options) {
     return 0;
   }
   const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
-
   return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
 }
 function goAtEnd(_ref) {
@@ -718,7 +677,6 @@ function calculateReorderImpact(_ref2) {
     forceShouldAnimate
   } = _ref2;
   const inHomeList = isHomeOf(draggable, destination);
-
   if (index == null) {
     return goAtEnd({
       insideDestination,
@@ -727,7 +685,6 @@ function calculateReorderImpact(_ref2) {
       destination
     });
   }
-
   const match = insideDestination.find(item => item.descriptor.index === index);
   if (!match) {
     return goAtEnd({
@@ -804,10 +761,8 @@ var fromReorder = (_ref => {
   }
   const currentIndex = location.index;
   const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
-
   const firstIndex = insideDestination[0].descriptor.index;
   const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
-
   const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
   if (proposedIndex < firstIndex) {
     return null;
@@ -852,7 +807,6 @@ var moveToNextIndex = (_ref => {
       index: newIndex
     });
   }
-
   const newIndex = fromCombine({
     isMovingForward,
     destination,
@@ -910,7 +864,6 @@ var whenCombining = (_ref => {
 
 const distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
 const distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
-
 const getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
 const goAfter = _ref => {
   let {
@@ -918,8 +871,7 @@ const goAfter = _ref => {
     moveRelativeTo,
     isMoving
   } = _ref;
-  return patch(axis.line,
-  moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
 };
 const goBefore = _ref2 => {
   let {
@@ -927,8 +879,7 @@ const goBefore = _ref2 => {
     moveRelativeTo,
     isMoving
   } = _ref2;
-  return patch(axis.line,
-  moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
 };
 const goIntoStart = _ref3 => {
   let {
@@ -950,7 +901,6 @@ var whenReordering = (_ref => {
   const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
   const draggablePage = draggable.page;
   const axis = droppable.axis;
-
   if (!insideDestination.length) {
     return goIntoStart({
       axis,
@@ -963,10 +913,8 @@ var whenReordering = (_ref => {
     displacedBy
   } = impact;
   const closestAfter = displaced.all[0];
-
   if (closestAfter) {
     const closest = draggables[closestAfter];
-
     if (didStartAfterCritical(closestAfter, afterCritical)) {
       return goBefore({
         axis,
@@ -974,7 +922,6 @@ var whenReordering = (_ref => {
         isMoving: draggablePage
       });
     }
-
     const withDisplacement = cssBoxModel.offset(closest.page, displacedBy.point);
     return goBefore({
       axis,
@@ -982,14 +929,11 @@ var whenReordering = (_ref => {
       isMoving: draggablePage
     });
   }
-
   const last = insideDestination[insideDestination.length - 1];
-
   if (last.descriptor.id === draggable.descriptor.id) {
     return draggablePage.borderBox.center;
   }
   if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
-
     const page = cssBoxModel.offset(last.page, negate(afterCritical.displacedBy.point));
     return goAfter({
       axis,
@@ -997,7 +941,6 @@ var whenReordering = (_ref => {
       isMoving: draggablePage
     });
   }
-
   return goAfter({
     axis,
     moveRelativeTo: last.page,
@@ -1054,7 +997,6 @@ var getPageBorderBoxCenterFromImpact = (args => {
 var scrollViewport = ((viewport, newScroll) => {
   const diff = subtract(newScroll, viewport.scroll.initial);
   const displacement = negate(diff);
-
   const frame = cssBoxModel.getRect({
     top: newScroll.y,
     bottom: newScroll.y + viewport.frame.height,
@@ -1117,8 +1059,7 @@ var speculativelyIncrease = (_ref => {
   });
   const invisible = {};
   const visible = {};
-  const groups = [
-  last, withViewportScroll, withDroppableScroll];
+  const groups = [last, withViewportScroll, withDroppableScroll];
   last.all.forEach(id => {
     const displacement = tryGetVisible(id, groups);
     if (displacement) {
@@ -1162,7 +1103,6 @@ var isTotallyVisibleInNewLocation = (_ref => {
   } = _ref;
   const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);
   const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);
-
   const args = {
     target: shifted,
     destination,
@@ -1270,41 +1210,30 @@ var getBestCrossAxisDroppable = (_ref => {
   }
   const axis = source.axis;
   const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
-  const candidates = toDroppableList(droppables)
-  .filter(droppable => droppable !== source)
-  .filter(droppable => droppable.isEnabled)
-  .filter(droppable => Boolean(droppable.subject.active))
-  .filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {
+  const candidates = toDroppableList(droppables).filter(droppable => droppable !== source).filter(droppable => droppable.isEnabled).filter(droppable => Boolean(droppable.subject.active)).filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {
     const activeOfTarget = getKnownActive(droppable);
-
     if (isMovingForward) {
       return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
     }
     return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
-  })
-  .filter(droppable => {
+  }).filter(droppable => {
     const activeOfTarget = getKnownActive(droppable);
     const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
     return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
-  })
-  .sort((a, b) => {
+  }).sort((a, b) => {
     const first = getKnownActive(a)[axis.crossAxisStart];
     const second = getKnownActive(b)[axis.crossAxisStart];
     if (isMovingForward) {
       return first - second;
     }
     return second - first;
-  })
-  .filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
-
+  }).filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
   if (!candidates.length) {
     return null;
   }
-
   if (candidates.length === 1) {
     return candidates[0];
   }
-
   const contains = candidates.filter(droppable => {
     const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);
     return isWithinDroppable(pageBorderBoxCenter[axis.line]);
@@ -1312,19 +1241,15 @@ var getBestCrossAxisDroppable = (_ref => {
   if (contains.length === 1) {
     return contains[0];
   }
-
   if (contains.length > 1) {
     return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];
   }
-
   return candidates.sort((a, b) => {
     const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));
     const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));
-
     if (first !== second) {
       return first - second;
     }
-
     return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
   })[0];
 });
@@ -1346,8 +1271,7 @@ var getClosestDraggable = (_ref => {
     insideDestination,
     afterCritical
   } = _ref;
-  const sorted = insideDestination.filter(draggable =>
-  isTotallyVisible({
+  const sorted = insideDestination.filter(draggable => isTotallyVisible({
     target: getCurrentPageBorderBox(draggable, afterCritical),
     destination,
     viewport: viewport.frame,
@@ -1355,21 +1279,18 @@ var getClosestDraggable = (_ref => {
   })).sort((a, b) => {
     const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
     const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
-
     if (distanceToA < distanceToB) {
       return -1;
     }
-
     if (distanceToB < distanceToA) {
       return 1;
     }
-
     return a.descriptor.index - b.descriptor.index;
   });
   return sorted[0] || null;
 });
 
-var getDisplacedBy = memoizeOne__default["default"](function getDisplacedBy(axis, displaceBy) {
+var getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {
   const displacement = displaceBy[axis.line];
   return {
     value: displacement,
@@ -1379,17 +1300,14 @@ var getDisplacedBy = memoizeOne__default["default"](function getDisplacedBy(axis
 
 const getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables) => {
   const axis = droppable.axis;
-
   if (droppable.descriptor.mode === 'virtual') {
     return patch(axis.line, placeholderSize[axis.line]);
   }
-
   const availableSpace = droppable.subject.page.contentBox[axis.size];
   const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
   const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
   const requiredSpace = spaceUsed + placeholderSize[axis.line];
   const needsToGrowBy = requiredSpace - availableSpace;
-
   if (needsToGrowBy <= 0) {
     return null;
   }
@@ -1486,7 +1404,6 @@ var moveToNewDroppable = (_ref => {
     if (insideDestination.length) {
       return null;
     }
-
     const proposed = {
       displaced: emptyGroups,
       displacedBy: noDisplacedBy,
@@ -1505,7 +1422,6 @@ var moveToNewDroppable = (_ref => {
       draggables,
       afterCritical
     });
-
     const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);
     const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
       draggable,
@@ -1517,8 +1433,7 @@ var moveToNewDroppable = (_ref => {
     });
     return isVisibleInNewLocation ? proposed : null;
   }
-  const isGoingBeforeTarget = Boolean(
-  previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
+  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
   const proposedIndex = (() => {
     const relativeTo = moveRelativeTo.descriptor.index;
     if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {
@@ -1552,7 +1467,6 @@ var moveCrossAxis = (_ref => {
     viewport,
     afterCritical
   } = _ref;
-
   const destination = getBestCrossAxisDroppable({
     isMovingForward,
     pageBorderBoxCenter: previousPageBorderBoxCenter,
@@ -1560,7 +1474,6 @@ var moveCrossAxis = (_ref => {
     droppables,
     viewport
   });
-
   if (!destination) {
     return null;
   }
@@ -1630,7 +1543,6 @@ var moveInDirection = (_ref => {
   const isOver = isActuallyOver || home;
   const direction = isOver.axis.direction;
   const isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');
-
   if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
     return null;
   }
@@ -1684,20 +1596,15 @@ function getFurthestAway(_ref) {
     draggable,
     candidates
   } = _ref;
-
   const startCenter = draggable.page.borderBox.center;
   const sorted = candidates.map(candidate => {
     const axis = candidate.axis;
-    const target = patch(candidate.axis.line,
-    pageBorderBox.center[axis.line],
-    candidate.page.borderBox.center[axis.crossAxisLine]);
+    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
     return {
       id: candidate.descriptor.id,
       distance: distance(startCenter, target)
     };
-  })
-  .sort((a, b) => b.distance - a.distance);
-
+  }).sort((a, b) => b.distance - a.distance);
   return sorted[0] ? sorted[0].id : null;
 }
 function getDroppableOver(_ref2) {
@@ -1710,20 +1617,16 @@ function getDroppableOver(_ref2) {
     if (!item.isEnabled) {
       return false;
     }
-
     const active = item.subject.active;
     if (!active) {
       return false;
     }
-
     if (!getHasOverlap(pageBorderBox, active)) {
       return false;
     }
-
     if (isPositionInFrame(active)(pageBorderBox.center)) {
       return true;
     }
-
     const axis = item.axis;
     const childCenter = active.center[axis.crossAxisLine];
     const crossAxisStart = pageBorderBox[axis.crossAxisStart];
@@ -1731,11 +1634,9 @@ function getDroppableOver(_ref2) {
     const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
     const isStartContained = isContained(crossAxisStart);
     const isEndContained = isContained(crossAxisEnd);
-
     if (!isStartContained && !isEndContained) {
       return true;
     }
-
     if (isStartContained) {
       return crossAxisStart < childCenter;
     }
@@ -1744,11 +1645,9 @@ function getDroppableOver(_ref2) {
   if (!candidates.length) {
     return null;
   }
-
   if (candidates.length === 1) {
     return candidates[0].descriptor.id;
   }
-
   return getFurthestAway({
     pageBorderBox,
     draggable,
@@ -1815,19 +1714,15 @@ var getReorderImpact = (_ref2 => {
       displaced: last,
       id
     });
-
     if (didStartAfterCritical$1) {
       if (isDisplaced) {
         return targetEnd <= childCenter;
       }
-
       return targetStart < childCenter - displacement;
     }
-
     if (isDisplaced) {
       return targetEnd <= childCenter + displacement;
     }
-
     return targetStart < childCenter;
   }) || null;
   const newIndex = atIndex({
@@ -1835,7 +1730,6 @@ var getReorderImpact = (_ref2 => {
     closest,
     inHomeList: isHomeOf(draggable, destination)
   });
-
   return calculateReorderImpact({
     draggable,
     insideDestination,
@@ -1876,19 +1770,15 @@ var getCombineImpact = (_ref => {
       displaced: previousImpact.displaced,
       id
     });
-
     if (didStartAfterCritical$1) {
       if (isDisplaced) {
         return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
       }
-
       return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
     }
-
     if (isDisplaced) {
       return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
     }
-
     return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
   });
   if (!combineWith) {
@@ -1924,15 +1814,12 @@ var getDragImpact = (_ref => {
     draggable,
     droppables
   });
-
   if (!destinationId) {
     return noImpact$1;
   }
   const destination = droppables[destinationId];
   const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
-
   const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
-
   return getCombineImpact({
     pageBorderBoxWithDroppableScroll,
     draggable,
@@ -1967,12 +1854,10 @@ const clearUnusedPlaceholder = _ref => {
   if (!last) {
     return droppables;
   }
-
   if (last === now) {
     return droppables;
   }
   const lastDroppable = droppables[last];
-
   if (!lastDroppable.subject.withPlaceholder) {
     return droppables;
   }
@@ -1997,15 +1882,12 @@ var recomputePlaceholders = (_ref2 => {
     return cleaned;
   }
   const droppable = droppables[isOver];
-
   if (isHomeOf(draggable, droppable)) {
     return cleaned;
   }
-
   if (droppable.subject.withPlaceholder) {
     return cleaned;
   }
-
   const patched = addPlaceholder(droppable, draggable, draggables);
   return patchDroppableMap(cleaned, patched);
 });
@@ -2019,7 +1901,6 @@ var update = (_ref => {
     impact: forcedImpact,
     scrollJumpRequest
   } = _ref;
-
   const viewport = forcedViewport || state.viewport;
   const dimensions = forcedDimensions || state.dimensions;
   const clientSelection = forcedClientSelection || state.current.client.selection;
@@ -2038,7 +1919,6 @@ var update = (_ref => {
     client,
     page
   };
-
   if (state.phase === 'COLLECTING') {
     return {
       ...state,
@@ -2184,7 +2064,6 @@ var getLiftEffect = (_ref => {
   } = _ref;
   const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);
   const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);
-
   const rawIndex = insideHome.indexOf(draggable);
   !(rawIndex !== -1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;
   const afterDragging = insideHome.slice(rawIndex + 1);
@@ -2271,9 +2150,7 @@ var adjustAdditionsForScrollChanges = (_ref => {
     updatedDroppables,
     viewport
   } = _ref;
-
   const windowScrollChange = viewport.scroll.diff.value;
-
   return additions.map(draggable => {
     const droppableId = draggable.descriptor.droppableId;
     const modified = updatedDroppables[droppableId];
@@ -2296,7 +2173,6 @@ var publishWhileDraggingInVirtual = (_ref => {
     published
   } = _ref;
   start(timingsKey);
-
   const withScrollChange = published.modified.map(update => {
     const existing = state.dimensions.droppables[update.droppableId];
     const scrolled = scrollDroppable(existing, update.scroll);
@@ -2315,7 +2191,6 @@ var publishWhileDraggingInVirtual = (_ref => {
     ...state.dimensions.draggables,
     ...updatedAdditions
   };
-
   published.removals.forEach(id => {
     delete draggables[id];
   });
@@ -2336,8 +2211,7 @@ var publishWhileDraggingInVirtual = (_ref => {
     draggables,
     viewport: state.viewport
   });
-  const previousImpact = wasOver && wasOver.isCombineEnabled ?
-  state.impact : onLiftImpact;
+  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
   const impact = getDragImpact({
     pageOffset: state.current.page.offset,
     draggable: dimensions.draggables[state.critical.draggable.id],
@@ -2360,7 +2234,6 @@ var publishWhileDraggingInVirtual = (_ref => {
   if (state.phase === 'COLLECTING') {
     return draggingState;
   }
-
   const dropPending = {
     ...draggingState,
     phase: 'DROP_PENDING',
@@ -2373,7 +2246,6 @@ var publishWhileDraggingInVirtual = (_ref => {
 const isSnapping = state => state.movementMode === 'SNAP';
 const postDroppableChange = (state, updated, isEnabledChanging) => {
   const dimensions = patchDimensionMap(state.dimensions, updated);
-
   if (!isSnapping(state) || isEnabledChanging) {
     return update({
       state,
@@ -2399,7 +2271,6 @@ const idle$2 = {
   completed: null,
   shouldFlush: false
 };
-
 var reducer = (function (state, action) {
   if (state === void 0) {
     state = idle$2;
@@ -2434,7 +2305,6 @@ var reducer = (function (state, action) {
         offset: add(client.selection, viewport.scroll.diff.value)
       }
     };
-
     const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(item => !item.isFixedOnPage);
     const {
       impact,
@@ -2489,7 +2359,6 @@ var reducer = (function (state, action) {
     const {
       client: clientSelection
     } = action.payload;
-
     if (isEqual$1(clientSelection, state.current.client.selection)) {
       return state;
     }
@@ -2503,7 +2372,6 @@ var reducer = (function (state, action) {
     if (state.phase === 'DROP_PENDING') {
       return removeScrollJumpRequest(state);
     }
-
     if (state.phase === 'COLLECTING') {
       return removeScrollJumpRequest(state);
     }
@@ -2513,7 +2381,6 @@ var reducer = (function (state, action) {
       newScroll
     } = action.payload;
     const target = state.dimensions.droppables[id];
-
     if (!target) {
       return state;
     }
@@ -2565,7 +2432,6 @@ var reducer = (function (state, action) {
     !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot move by window in phase ${state.phase}`) : invariant(false) : void 0;
     !state.isWindowScrollAllowed ? process.env.NODE_ENV !== "production" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;
     const newScroll = action.payload.newScroll;
-
     if (isEqual$1(state.viewport.scroll.current, newScroll)) {
       return removeScrollJumpRequest(state);
     }
@@ -2596,7 +2462,6 @@ var reducer = (function (state, action) {
         max: maxScroll
       }
     };
-
     return {
       ...state,
       viewport: withMaxScroll
@@ -2611,7 +2476,6 @@ var reducer = (function (state, action) {
       state,
       type: action.type
     });
-
     if (!result) {
       return state;
     }
@@ -2640,7 +2504,6 @@ var reducer = (function (state, action) {
       newHomeClientOffset
     } = action.payload;
     !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : invariant(false) : void 0;
-
     const result = {
       phase: 'DROP_ANIMATING',
       completed,
@@ -2650,7 +2513,6 @@ var reducer = (function (state, action) {
     };
     return result;
   }
-
   if (action.type === 'DROP_COMPLETE') {
     const {
       completed
@@ -2758,7 +2620,6 @@ function checkIndexes(insideDestination) {
   for (let i = 1; i < indexes.length; i++) {
     const current = indexes[i];
     const previous = indexes[i - 1];
-
     if (current !== previous + 1) {
       errors[current] = true;
     }
@@ -2801,21 +2662,17 @@ var lift = (marshal => _ref => {
       movementMode
     } = action.payload;
     const initial = getState();
-
     if (initial.phase === 'DROP_ANIMATING') {
       dispatch(completeDrop({
         completed: initial.completed
       }));
     }
     !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;
-
     dispatch(flush());
-
     dispatch(beforeInitialCapture({
       draggableId: id,
       movementMode
     }));
-
     const scrollOptions = {
       shouldPublishImmediately: movementMode === 'SNAP'
     };
@@ -2829,7 +2686,6 @@ var lift = (marshal => _ref => {
       viewport
     } = marshal.startPublishing(request);
     validateDimensions(critical, dimensions);
-
     dispatch(initialPublish({
       critical,
       dimensions,
@@ -2847,7 +2703,6 @@ var style = (marshal => () => next => action => {
   if (action.type === 'DROP_ANIMATE') {
     marshal.dropping(action.payload.completed.result.reason);
   }
-
   if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {
     marshal.resting();
   }
@@ -2872,7 +2727,6 @@ const timings = {
   minDropTime: 0.33,
   maxDropTime: 0.55
 };
-
 const outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
 const transitions = {
   fluid: `opacity ${outOfTheWayTiming}`,
@@ -2892,11 +2746,9 @@ const transforms = {
     if (!translate) {
       return undefined;
     }
-
     if (!isCombining) {
       return translate;
     }
-
     return `${translate} scale(${combine.scale.drop})`;
   }
 };
@@ -2921,7 +2773,6 @@ var getDropDuration = (_ref => {
   if (distance$1 >= maxDropTimeAtDistance) {
     return maxDropTime;
   }
-
   const percentage = distance$1 / maxDropTimeAtDistance;
   const duration = minDropTime + dropTimeRange * percentage;
   const withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;
@@ -2965,7 +2816,6 @@ var getDropImpact = (_ref => {
     onLiftImpact
   } = _ref;
   if (!lastImpact.at || reason !== 'DROP') {
-
     const recomputedHomeImpact = recompute({
       draggables,
       impact: onLiftImpact,
@@ -2978,14 +2828,12 @@ var getDropImpact = (_ref => {
       didDropInsideDroppable: false
     };
   }
-
   if (lastImpact.at.type === 'REORDER') {
     return {
       impact: lastImpact,
       didDropInsideDroppable: true
     };
   }
-
   const withoutMovement = {
     ...lastImpact,
     displaced: emptyGroups
@@ -3008,26 +2856,21 @@ const dropMiddleware = _ref => {
     }
     const state = getState();
     const reason = action.payload.reason;
-
     if (state.phase === 'COLLECTING') {
       dispatch(dropPending({
         reason
       }));
       return;
     }
-
     if (state.phase === 'IDLE') {
       return;
     }
-
     const isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;
     !!isWaitingForDrop ? process.env.NODE_ENV !== "production" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;
     !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot drop in phase: ${state.phase}`) : invariant(false) : void 0;
-
     const critical = state.critical;
     const dimensions = state.dimensions;
     const draggable = dimensions.draggables[state.critical.draggable.id];
-
     const {
       impact,
       didDropInsideDroppable
@@ -3040,7 +2883,6 @@ const dropMiddleware = _ref => {
       viewport: state.viewport,
       draggables: state.dimensions.draggables
     });
-
     const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
     const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;
     const source = {
@@ -3069,9 +2911,7 @@ const dropMiddleware = _ref => {
       result,
       impact
     };
-    const isAnimationRequired =
-    !isEqual$1(state.current.client.offset, newHomeClientOffset) ||
-    Boolean(result.combine);
+    const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
     if (!isAnimationRequired) {
       dispatch(completeDrop({
         completed
@@ -3120,7 +2960,7 @@ function getScrollListener(_ref) {
   function updateScroll() {
     onWindowScroll(getWindowScroll());
   }
-  const scheduled = rafSchd__default["default"](updateScroll);
+  const scheduled = rafSchd(updateScroll);
   const binding = getWindowScrollBinding(scheduled);
   let unbind = noop$2;
   function isActive() {
@@ -3167,7 +3007,6 @@ var scrollListener$1 = scrollListener;
 var getExpiringAnnounce = (announce => {
   let wasCalled = false;
   let isExpired = false;
-
   const timeoutId = setTimeout(() => {
     isExpired = true;
   });
@@ -3187,7 +3026,6 @@ var getExpiringAnnounce = (announce => {
     announce(message);
     clearTimeout(timeoutId);
   };
-
   result.wasCalled = () => wasCalled;
   return result;
 });
@@ -3229,18 +3067,15 @@ const areLocationsEqual = (first, second) => {
   if (first == null && second == null) {
     return true;
   }
-
   if (first == null || second == null) {
     return false;
   }
-
   return first.droppableId === second.droppableId && first.index === second.index;
 };
 const isCombineEqual = (first, second) => {
   if (first == null && second == null) {
     return true;
   }
-
   if (first == null || second == null) {
     return false;
   }
@@ -3269,8 +3104,7 @@ const getDragStart = (critical, mode) => ({
   },
   mode
 });
-function execute(responder, data, announce,
-getDefaultMessage) {
+function execute(responder, data, announce, getDefaultMessage) {
   if (!responder) {
     announce(getDefaultMessage(data));
     return;
@@ -3279,7 +3113,6 @@ getDefaultMessage) {
   const provided = {
     announce: willExpire
   };
-
   responder(data, provided);
   if (!willExpire.wasCalled()) {
     announce(getDefaultMessage(data));
@@ -3319,22 +3152,18 @@ var getPublisher = ((getResponders, announce) => {
       lastLocation: data.source,
       lastCombine: null
     };
-
     asyncMarshal.add(() => {
       withTimings('onDragStart', () => execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));
     });
   };
-
   const update = (critical, impact) => {
     const location = tryGetDestination(impact);
     const combine = tryGetCombine(impact);
     !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;
-
     const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
     if (hasCriticalChanged) {
       dragging.lastCritical = critical;
     }
-
     const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
     if (hasLocationChanged) {
       dragging.lastLocation = location;
@@ -3343,7 +3172,6 @@ var getPublisher = ((getResponders, announce) => {
     if (hasGroupingChanged) {
       dragging.lastCombine = combine;
     }
-
     if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
       return;
     }
@@ -3365,7 +3193,6 @@ var getPublisher = ((getResponders, announce) => {
     dragging = null;
     withTimings('onDragEnd', () => execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));
   };
-
   const abort = () => {
     if (!dragging) {
       return;
@@ -3403,7 +3230,6 @@ var responders = ((getResponders, announce) => {
       publisher.start(critical, action.payload.movementMode);
       return;
     }
-
     if (action.type === 'DROP_COMPLETE') {
       const result = action.payload.completed.result;
       publisher.flush();
@@ -3411,14 +3237,11 @@ var responders = ((getResponders, announce) => {
       publisher.drop(result);
       return;
     }
-
     next(action);
-
     if (action.type === 'FLUSH') {
       publisher.abort();
       return;
     }
-
     const state = store.getState();
     if (state.phase === 'DRAGGING') {
       publisher.update(state.critical, state.impact);
@@ -3474,7 +3297,6 @@ const dropAnimationFlushOnScrollMiddleware = store => {
         }
       }
     };
-
     frameId = requestAnimationFrame(() => {
       frameId = null;
       unbind = bindEvents(window, [binding]);
@@ -3484,9 +3306,7 @@ const dropAnimationFlushOnScrollMiddleware = store => {
 var dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;
 
 var dimensionMarshalStopper = (marshal => () => next => action => {
-  if (
-  action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' ||
-  action.type === 'DROP_ANIMATE') {
+  if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {
     marshal.stopPublishing();
   }
   next(action);
@@ -3514,7 +3334,6 @@ var focus = (marshal => {
     if (action.type === 'DROP_COMPLETE') {
       isWatching = false;
       const result = action.payload.completed.result;
-
       if (result.combine) {
         marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
       }
@@ -3537,7 +3356,6 @@ var autoScroll = (autoScroller => store => next => action => {
     autoScroller.start(state);
     return;
   }
-
   next(action);
   autoScroller.scroll(store.getState());
 });
@@ -3547,13 +3365,10 @@ const pendingDrop = store => next => action => {
   if (action.type !== 'PUBLISH_WHILE_DRAGGING') {
     return;
   }
-
   const postActionState = store.getState();
-
   if (postActionState.phase !== 'DROP_PENDING') {
     return;
   }
-
   if (postActionState.isWaiting) {
     return;
   }
@@ -3575,13 +3390,7 @@ var createStore = (_ref => {
     announce,
     autoScroller
   } = _ref;
-  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(
-
-  style(styleMarshal),
-  dimensionMarshalStopper(dimensionMarshal),
-  lift(dimensionMarshal), drop,
-  dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal),
-  responders(getResponders, announce))));
+  return redux.createStore(reducer, composeEnhancers(redux.applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), drop, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal), responders(getResponders, announce))));
 });
 
 const clean$1 = () => ({
@@ -3609,9 +3418,7 @@ function createPublisher(_ref) {
         removals,
         modified
       } = staging;
-      const added = Object.keys(additions).map(
-      id => registry.draggable.getById(id).getDimension(origin))
-      .sort((a, b) => a.descriptor.index - b.descriptor.index);
+      const added = Object.keys(additions).map(id => registry.draggable.getById(id).getDimension(origin)).sort((a, b) => a.descriptor.index - b.descriptor.index);
       const updated = Object.keys(modified).map(id => {
         const entry = registry.droppable.getById(id);
         const scroll = entry.callbacks.getScrollWhileDragging();
@@ -3670,12 +3477,10 @@ var getMaxScroll = (_ref => {
     height,
     width
   } = _ref;
-  const maxScroll = subtract(
-  {
+  const maxScroll = subtract({
     x: scrollWidth,
     y: scrollHeight
-  },
-  {
+  }, {
     x: width,
     y: height
   });
@@ -3708,11 +3513,9 @@ var getViewport = (() => {
   const maxScroll = getMaxWindowScroll();
   const top = scroll.y;
   const left = scroll.x;
-
   const doc = getDocumentElement();
   const width = doc.clientWidth;
   const height = doc.clientHeight;
-
   const right = left + width;
   const bottom = top + height;
   const frame = cssBoxModel.getRect({
@@ -3791,11 +3594,9 @@ var createDimensionMarshal = ((registry, callbacks) => {
   });
   const updateDroppableIsEnabled = (id, isEnabled) => {
     !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : invariant(false) : void 0;
-
     if (!collection) {
       return;
     }
-
     callbacks.updateDroppableIsEnabled({
       id,
       isEnabled
@@ -3832,10 +3633,8 @@ var createDimensionMarshal = ((registry, callbacks) => {
       return;
     }
     publisher.stop();
-
     const home = collection.critical.droppable;
     registry.droppable.getAllByType(home.type).forEach(entry => entry.callbacks.dragStopped());
-
     collection.unsubscribe();
     collection = null;
   };
@@ -3887,15 +3686,12 @@ var canStartDrag = ((state, id) => {
   if (state.phase === 'IDLE') {
     return true;
   }
-
   if (state.phase !== 'DROP_ANIMATING') {
     return false;
   }
-
   if (state.completed.result.draggableId === id) {
     return false;
   }
-
   return state.completed.result.reason === 'DROP';
 });
 
@@ -3903,11 +3699,10 @@ var scrollWindow = (change => {
   window.scrollBy(change.x, change.y);
 });
 
-const getScrollableDroppables = memoizeOne__default["default"](droppables => toDroppableList(droppables).filter(droppable => {
+const getScrollableDroppables = memoizeOne(droppables => toDroppableList(droppables).filter(droppable => {
   if (!droppable.isEnabled) {
     return false;
   }
-
   if (!droppable.frame) {
     return false;
   }
@@ -3926,7 +3721,6 @@ var getBestScrollableDroppable = (_ref => {
     destination,
     droppables
   } = _ref;
-
   if (destination) {
     const dimension = droppables[destination];
     if (!dimension.frame) {
@@ -3934,7 +3728,6 @@ var getBestScrollableDroppable = (_ref => {
     }
     return dimension;
   }
-
   const dimension = getScrollableDroppableOver(center, droppables);
   return dimension;
 });
@@ -3992,19 +3785,15 @@ var getValueFromDistance = (function (distanceToEdge, thresholds, getAutoScrolle
     getAutoScrollerOptions = () => defaultAutoScrollerOptions;
   }
   const autoScrollerOptions = getAutoScrollerOptions();
-
   if (distanceToEdge > thresholds.startScrollingFrom) {
     return 0;
   }
-
   if (distanceToEdge <= thresholds.maxScrollValueAt) {
     return autoScrollerOptions.maxPixelScroll;
   }
-
   if (distanceToEdge === thresholds.startScrollingFrom) {
     return minScroll;
   }
-
   const percentageFromMaxScrollValueAt = getPercentage({
     startOfRange: thresholds.maxScrollValueAt,
     endOfRange: thresholds.startScrollingFrom,
@@ -4012,7 +3801,6 @@ var getValueFromDistance = (function (distanceToEdge, thresholds, getAutoScrolle
   });
   const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
   const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
-
   return Math.ceil(scroll);
 });
 
@@ -4024,11 +3812,9 @@ var dampenValueByTime = ((proposedScroll, dragStartTime, getAutoScrollerOptions)
   const endOfRange = stopAt;
   const now = Date.now();
   const runTime = now - startOfRange;
-
   if (runTime >= stopAt) {
     return proposedScroll;
   }
-
   if (runTime < accelerateAt) {
     return minScroll;
   }
@@ -4050,15 +3836,12 @@ var getValue = (_ref => {
     getAutoScrollerOptions
   } = _ref;
   const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
-
   if (scroll === 0) {
     return 0;
   }
-
   if (!shouldUseTimeDampening) {
     return scroll;
   }
-
   return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);
 });
 
@@ -4099,15 +3882,12 @@ var adjustForSizeLimits = (_ref => {
   } = _ref;
   const isTooBigVertically = subject.height > container.height;
   const isTooBigHorizontally = subject.width > container.width;
-
   if (!isTooBigHorizontally && !isTooBigVertically) {
     return proposedScroll;
   }
-
   if (isTooBigHorizontally && isTooBigVertically) {
     return null;
   }
-
   return {
     x: isTooBigHorizontally ? 0 : proposedScroll.x,
     y: isTooBigVertically ? 0 : proposedScroll.y
@@ -4130,7 +3910,6 @@ var getScroll$1 = (_ref => {
     bottom: container.bottom - center.y,
     left: center.x - container.left
   };
-
   const y = getScrollOnAxis({
     container,
     distanceToEdges,
@@ -4151,11 +3930,9 @@ var getScroll$1 = (_ref => {
     x,
     y
   });
-
   if (isEqual$1(required, origin)) {
     return null;
   }
-
   const limited = adjustForSizeLimits({
     container,
     subject,
@@ -4210,22 +3987,18 @@ const canPartiallyScroll = _ref2 => {
     x: Math.max(current.x, rawMax.x),
     y: Math.max(current.y, rawMax.y)
   };
-
   const smallestChange = smallestSigned(change);
   const overlap = getOverlap({
     max,
     current,
     change: smallestChange
   });
-
   if (!overlap) {
     return true;
   }
-
   if (smallestChange.x !== 0 && overlap.x === 0) {
     return true;
   }
-
   if (smallestChange.y !== 0 && overlap.y === 0) {
     return true;
   }
@@ -4250,7 +4023,6 @@ const getWindowOverlap = (viewport, change) => {
 };
 const canScrollDroppable = (droppable, change) => {
   const frame = droppable.frame;
-
   if (!frame) {
     return false;
   }
@@ -4305,7 +4077,6 @@ var getDroppableScrollChange = (_ref => {
     getAutoScrollerOptions
   } = _ref;
   const frame = droppable.frame;
-
   if (!frame) {
     return null;
   }
@@ -4374,8 +4145,8 @@ var createFluidScroller = (_ref => {
     scrollDroppable,
     getAutoScrollerOptions = () => defaultAutoScrollerOptions
   } = _ref;
-  const scheduleWindowScroll = rafSchd__default["default"](scrollWindow);
-  const scheduleDroppableScroll = rafSchd__default["default"](scrollDroppable);
+  const scheduleWindowScroll = rafSchd(scrollWindow);
+  const scheduleDroppableScroll = rafSchd(scrollDroppable);
   let dragging = null;
   const tryScroll = state => {
     !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;
@@ -4413,7 +4184,6 @@ var createFluidScroller = (_ref => {
       shouldUseTimeDampening: wasScrollNeeded
     };
     finish();
-
     if (wasScrollNeeded) {
       tryScroll(state);
     }
@@ -4450,12 +4220,10 @@ var createJumpScroller = (_ref => {
       return change;
     }
     const overlap = getDroppableOverlap(droppable, change);
-
     if (!overlap) {
       scrollDroppable(droppable.descriptor.id, change);
       return null;
     }
-
     const whatTheDroppableCanScroll = subtract(change, overlap);
     scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);
     const remainder = subtract(change, whatTheDroppableCanScroll);
@@ -4469,12 +4237,10 @@ var createJumpScroller = (_ref => {
       return change;
     }
     const overlap = getWindowOverlap(viewport, change);
-
     if (!overlap) {
       scrollWindow(change);
       return null;
     }
-
     const whatTheWindowCanScroll = subtract(change, overlap);
     scrollWindow(whatTheWindowCanScroll);
     const remainder = subtract(change, whatTheWindowCanScroll);
@@ -4487,19 +4253,15 @@ var createJumpScroller = (_ref => {
     }
     const destination = whatIsDraggedOver(state.impact);
     !destination ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;
-
     const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
-
     if (!droppableRemainder) {
       return;
     }
     const viewport = state.viewport;
     const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
-
     if (!windowRemainder) {
       return;
     }
-
     moveByOffset(state, windowRemainder);
   };
   return jumpScroller;
@@ -4524,7 +4286,6 @@ var createAutoScroller = (_ref => {
   });
   const scroll = state => {
     const autoScrollerOptions = getAutoScrollerOptions();
-
     if (autoScrollerOptions.disabled || state.phase !== 'DRAGGING') {
       return;
     }
@@ -4585,7 +4346,6 @@ const getStyles = (rules, property) => rules.map(rule => {
 const noPointerEvents = 'pointer-events: none;';
 var getStyles$1 = (contextId => {
   const getSelector = makeGetSelector(contextId);
-
   const dragHandle$1 = (() => {
     const grabCursor = `
       cursor: -webkit-grab;
@@ -4605,7 +4365,6 @@ var getStyles$1 = (contextId => {
       }
     };
   })();
-
   const draggable$1 = (() => {
     const transition = `
       transition: ${transitions.outOfTheWay};
@@ -4619,14 +4378,12 @@ var getStyles$1 = (contextId => {
       }
     };
   })();
-
   const droppable$1 = {
     selector: getSelector(droppable.contextId),
     styles: {
       always: `overflow-anchor: none;`
     }
   };
-
   const body = {
     selector: 'body',
     styles: {
@@ -4671,9 +4428,7 @@ function useStyleMarshal(contextId, nonce) {
   const styles = useMemoOne.useMemo(() => getStyles$1(contextId), [contextId]);
   const alwaysRef = React.useRef(null);
   const dynamicRef = React.useRef(null);
-
-  const setDynamicStyle = useMemoOne.useCallback(
-  memoizeOne__default["default"](proposed => {
+  const setDynamicStyle = useMemoOne.useCallback(memoizeOne(proposed => {
     const el = dynamicRef.current;
     !el ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;
     el.textContent = proposed;
@@ -4683,21 +4438,16 @@ function useStyleMarshal(contextId, nonce) {
     !el ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;
     el.textContent = proposed;
   }, []);
-
   useLayoutEffect(() => {
     !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== "production" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;
     const always = createStyleEl(nonce);
     const dynamic = createStyleEl(nonce);
-
     alwaysRef.current = always;
     dynamicRef.current = dynamic;
-
     always.setAttribute(`${prefix}-always`, contextId);
     dynamic.setAttribute(`${prefix}-dynamic`, contextId);
-
     getHead().appendChild(always);
     getHead().appendChild(dynamic);
-
     setAlwaysStyle(styles.always);
     setDynamicStyle(styles.resting);
     return () => {
@@ -4737,10 +4487,7 @@ function querySelectorAll(parentNode, selector) {
   return Array.from(parentNode.querySelectorAll(selector));
 }
 
-var getWindowFromEl = (el => {
-  var _el$ownerDocument;
-  return (el == null ? void 0 : (_el$ownerDocument = el.ownerDocument) == null ? void 0 : _el$ownerDocument.defaultView) || window;
-});
+var getWindowFromEl = (el => el?.ownerDocument?.defaultView || window);
 
 function isHtmlElement(el) {
   return el instanceof getWindowFromEl(el).HTMLElement;
@@ -4801,7 +4548,6 @@ function useFocusMarshal(contextId) {
     if (restoreFocusFrameRef.current) {
       return;
     }
-
     if (!isMountedRef.current) {
       return;
     }
@@ -4816,11 +4562,9 @@ function useFocusMarshal(contextId) {
   const tryRecordFocus = useMemoOne.useCallback(function tryRecordFocus(id) {
     recordRef.current = null;
     const focused = document.activeElement;
-
     if (!focused) {
       return;
     }
-
     if (focused.getAttribute(dragHandle.draggableId) !== id) {
       return;
     }
@@ -4855,7 +4599,6 @@ function createRegistry() {
     subscribers.push(cb);
     return function unsubscribe() {
       const index = subscribers.indexOf(cb);
-
       if (index === -1) {
         return;
       }
@@ -4885,31 +4628,25 @@ function createRegistry() {
     },
     update: (entry, last) => {
       const current = entries.draggables[last.descriptor.id];
-
       if (!current) {
         return;
       }
-
       if (current.uniqueId !== entry.uniqueId) {
         return;
       }
-
       delete entries.draggables[last.descriptor.id];
       entries.draggables[entry.descriptor.id] = entry;
     },
     unregister: entry => {
       const draggableId = entry.descriptor.id;
       const current = findDraggableById(draggableId);
-
       if (!current) {
         return;
       }
-
       if (entry.uniqueId !== current.uniqueId) {
         return;
       }
       delete entries.draggables[draggableId];
-
       if (entries.droppables[entry.descriptor.droppableId]) {
         notify({
           type: 'REMOVAL',
@@ -4936,11 +4673,9 @@ function createRegistry() {
     },
     unregister: entry => {
       const current = findDroppableById(entry.descriptor.id);
-
       if (!current) {
         return;
       }
-
       if (entry.uniqueId !== current.uniqueId) {
         return;
       }
@@ -4968,7 +4703,7 @@ function useRegistry() {
   const registry = useMemoOne.useMemo(createRegistry, []);
   React.useEffect(() => {
     return function unmount() {
-      if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+      if (React.version.startsWith('16') || React.version.startsWith('17')) {
         requestAnimationFrame(registry.clean);
       } else {
         registry.clean();
@@ -4978,7 +4713,7 @@ function useRegistry() {
   return registry;
 }
 
-var StoreContext = React__default["default"].createContext(null);
+var StoreContext = React.createContext(null);
 
 var getBodyElement = (() => {
   const body = document.body;
@@ -5006,17 +4741,12 @@ function useAnnouncer(contextId) {
   React.useEffect(function setup() {
     const el = document.createElement('div');
     ref.current = el;
-
     el.id = id;
-
     el.setAttribute('aria-live', 'assertive');
     el.setAttribute('aria-atomic', 'true');
-
-    _extends__default["default"](el.style, visuallyHidden$1);
-
+    _extends(el.style, visuallyHidden$1);
     getBodyElement().appendChild(el);
     return function cleanup() {
-
       setTimeout(function remove() {
         const body = getBodyElement();
         if (body.contains(el)) {
@@ -5065,11 +4795,10 @@ function useUniqueId(prefix, options) {
   if (options === void 0) {
     options = defaults;
   }
-  const id = React__default["default"].useId();
+  const id = React.useId();
   return useMemoOne.useMemo(() => `${prefix}${options.separator}${id}`, [options.separator, prefix, id]);
 }
-
-var useUniqueId$1 = 'useId' in React__default["default"] ? useUniqueId : useDeprecatedUniqueId;
+var useUniqueId$1 = 'useId' in React ? useUniqueId : useDeprecatedUniqueId;
 
 function getElementId(_ref) {
   let {
@@ -5092,13 +4821,9 @@ function useHiddenTextElement(_ref2) {
   }), [uniqueId, contextId]);
   React.useEffect(function mount() {
     const el = document.createElement('div');
-
     el.id = id;
-
     el.textContent = text;
-
     el.style.display = 'none';
-
     getBodyElement().appendChild(el);
     return function unmount() {
       const body = getBodyElement();
@@ -5110,7 +4835,7 @@ function useHiddenTextElement(_ref2) {
   return id;
 }
 
-var AppContext = React__default["default"].createContext(null);
+var AppContext = React.createContext(null);
 
 var peerDependencies = {
 	react: "^16.8.5 || ^17.0.0 || ^18.0.0",
@@ -5138,14 +4863,12 @@ const isSatisfied = (expected, actual) => {
   if (actual.major < expected.major) {
     return false;
   }
-
   if (actual.minor > expected.minor) {
     return true;
   }
   if (actual.minor < expected.minor) {
     return false;
   }
-
   return actual.patch >= expected.patch;
 };
 var checkReactVersion = ((peerDepValue, actualValue) => {
@@ -5219,18 +4942,16 @@ function useDevSetupWarning(fn, inputs) {
 
 function useStartupValidation() {
   useDevSetupWarning(() => {
-    checkReactVersion(peerDependencies.react, React__default["default"].version);
+    checkReactVersion(peerDependencies.react, React.version);
     checkDoctype(document);
   }, []);
 }
 
 function usePrevious(current) {
   const ref = React.useRef(current);
-
   React.useEffect(() => {
     ref.current = current;
   });
-
   return ref;
 }
 
@@ -5301,11 +5022,9 @@ var preventStandardKeyEvents = (event => {
 
 const supportedEventName = (() => {
   const base = 'visibilitychange';
-
   if (typeof document === 'undefined') {
     return base;
   }
-
   const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];
   const supported = candidates.find(eventName => `on${eventName}` in document);
   return supported || base;
@@ -5343,22 +5062,17 @@ function getCaptureBindings(_ref) {
         y: clientY
       };
       const phase = getPhase();
-
       if (phase.type === 'DRAGGING') {
         event.preventDefault();
         phase.actions.move(point);
         return;
       }
-
       !(phase.type === 'PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;
       const pending = phase.point;
-
       if (!isSloppyClickThresholdExceeded(pending, point)) {
         return;
       }
-
       event.preventDefault();
-
       const actions = phase.actions.fluidLift(point);
       setPhase({
         type: 'DRAGGING',
@@ -5373,7 +5087,6 @@ function getCaptureBindings(_ref) {
         cancel();
         return;
       }
-
       event.preventDefault();
       phase.actions.drop({
         shouldBlockNextClick: true
@@ -5396,7 +5109,6 @@ function getCaptureBindings(_ref) {
         cancel();
         return;
       }
-
       if (event.keyCode === escape) {
         event.preventDefault();
         cancel();
@@ -5418,8 +5130,7 @@ function getCaptureBindings(_ref) {
         cancel();
       }
     }
-  },
-  {
+  }, {
     eventName: 'webkitmouseforcedown',
     fn: event => {
       const phase = getPhase();
@@ -5428,11 +5139,9 @@ function getCaptureBindings(_ref) {
         cancel();
         return;
       }
-
       event.preventDefault();
     }
-  },
-  {
+  }, {
     eventName: supportedPageVisibilityEventName,
     fn: cancel
   }];
@@ -5449,7 +5158,6 @@ function useMouseSensor(api) {
       if (event.button !== primaryButton) {
         return;
       }
-
       if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
         return;
       }
@@ -5457,25 +5165,21 @@ function useMouseSensor(api) {
       if (!draggableId) {
         return;
       }
-      const actions = api.tryGetLock(draggableId,
-      stop, {
+      const actions = api.tryGetLock(draggableId, stop, {
         sourceEvent: event
       });
       if (!actions) {
         return;
       }
-
       event.preventDefault();
       const point = {
         x: event.clientX,
         y: event.clientY
       };
-
       unbindEventsRef.current();
       startPendingDrag(actions, point);
     }
-  }),
-  [api]);
+  }), [api]);
   const preventForcePressBinding = useMemoOne.useMemo(() => ({
     eventName: 'webkitmouseforcewillbegin',
     fn: event => {
@@ -5553,7 +5257,6 @@ function useMouseSensor(api) {
   }, [bindCapturingEvents]);
   useLayoutEffect(function mount() {
     listenForCapture();
-
     return function unmount() {
       unbindEventsRef.current();
     };
@@ -5584,13 +5287,11 @@ function getDraggingBindings(actions, stop) {
         cancel();
         return;
       }
-
       if (event.keyCode === space) {
         event.preventDefault();
         drop();
         return;
       }
-
       if (event.keyCode === arrowDown) {
         event.preventDefault();
         actions.moveDown();
@@ -5611,15 +5312,13 @@ function getDraggingBindings(actions, stop) {
         actions.moveLeft();
         return;
       }
-
       if (scrollJumpKeys[event.keyCode]) {
         event.preventDefault();
         return;
       }
       preventStandardKeyEvents(event);
     }
-  },
-  {
+  }, {
     eventName: 'mousedown',
     fn: cancel
   }, {
@@ -5631,19 +5330,16 @@ function getDraggingBindings(actions, stop) {
   }, {
     eventName: 'touchstart',
     fn: cancel
-  },
-  {
+  }, {
     eventName: 'resize',
     fn: cancel
-  },
-  {
+  }, {
     eventName: 'wheel',
     fn: cancel,
     options: {
       passive: true
     }
-  },
-  {
+  }, {
     eventName: supportedPageVisibilityEventName,
     fn: cancel
   }];
@@ -5656,7 +5352,6 @@ function useKeyboardSensor(api) {
       if (event.defaultPrevented) {
         return;
       }
-
       if (event.keyCode !== space) {
         return;
       }
@@ -5664,37 +5359,28 @@ function useKeyboardSensor(api) {
       if (!draggableId) {
         return;
       }
-      const preDrag = api.tryGetLock(draggableId,
-      stop, {
+      const preDrag = api.tryGetLock(draggableId, stop, {
         sourceEvent: event
       });
-
       if (!preDrag) {
         return;
       }
-
       event.preventDefault();
       let isCapturing = true;
-
       const actions = preDrag.snapLift();
-
       unbindEventsRef.current();
-
       function stop() {
         !isCapturing ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;
         isCapturing = false;
-
         unbindEventsRef.current();
         listenForCapture();
       }
-
       unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
         capture: true,
         passive: false
       });
     }
-  }),
-  [api]);
+  }), [api]);
   const listenForCapture = useMemoOne.useCallback(function tryStartCapture() {
     const options = {
       passive: false,
@@ -5704,7 +5390,6 @@ function useKeyboardSensor(api) {
   }, [startCaptureBinding]);
   useLayoutEffect(function mount() {
     listenForCapture();
-
     return function unmount() {
       unbindEventsRef.current();
     };
@@ -5721,41 +5406,34 @@ function getWindowBindings(_ref) {
     cancel,
     getPhase
   } = _ref;
-  return [
-  {
+  return [{
     eventName: 'orientationchange',
     fn: cancel
-  },
-  {
+  }, {
     eventName: 'resize',
     fn: cancel
-  },
-  {
+  }, {
     eventName: 'contextmenu',
     fn: event => {
       event.preventDefault();
     }
-  },
-  {
+  }, {
     eventName: 'keydown',
     fn: event => {
       if (getPhase().type !== 'DRAGGING') {
         cancel();
         return;
       }
-
       if (event.keyCode === escape) {
         event.preventDefault();
       }
       cancel();
     }
-  },
-  {
+  }, {
     eventName: supportedPageVisibilityEventName,
     fn: cancel
   }];
 }
-
 function getHandleBindings(_ref2) {
   let {
     cancel,
@@ -5773,7 +5451,6 @@ function getHandleBindings(_ref2) {
         cancel();
         return;
       }
-
       phase.hasMoved = true;
       const {
         clientX,
@@ -5783,7 +5460,6 @@ function getHandleBindings(_ref2) {
         x: clientX,
         y: clientY
       };
-
       event.preventDefault();
       phase.actions.move(point);
     }
@@ -5795,7 +5471,6 @@ function getHandleBindings(_ref2) {
         cancel();
         return;
       }
-
       event.preventDefault();
       phase.actions.drop({
         shouldBlockNextClick: true
@@ -5809,18 +5484,14 @@ function getHandleBindings(_ref2) {
         cancel();
         return;
       }
-
       event.preventDefault();
       cancel();
     }
-  },
-  {
+  }, {
     eventName: 'touchforcechange',
     fn: event => {
       const phase = getPhase();
-
       !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-
       const touch = event.touches[0];
       if (!touch) {
         return;
@@ -5836,7 +5507,6 @@ function getHandleBindings(_ref2) {
         }
         return;
       }
-
       if (shouldRespect) {
         if (phase.hasMoved) {
           event.preventDefault();
@@ -5845,17 +5515,13 @@ function getHandleBindings(_ref2) {
         cancel();
         return;
       }
-
       event.preventDefault();
     }
-  },
-  {
+  }, {
     eventName: supportedPageVisibilityEventName,
     fn: cancel
-  }
-  ];
+  }];
 }
-
 function useTouchSensor(api) {
   const phaseRef = React.useRef(idle);
   const unbindEventsRef = React.useRef(noop$2);
@@ -5871,16 +5537,13 @@ function useTouchSensor(api) {
       if (event.defaultPrevented) {
         return;
       }
-
       const draggableId = api.findClosestDraggableId(event);
       if (!draggableId) {
         return;
       }
-      const actions = api.tryGetLock(draggableId,
-      stop, {
+      const actions = api.tryGetLock(draggableId, stop, {
         sourceEvent: event
       });
-
       if (!actions) {
         return;
       }
@@ -5893,13 +5556,10 @@ function useTouchSensor(api) {
         x: clientX,
         y: clientY
       };
-
       unbindEventsRef.current();
-
       startPendingDrag(actions, point);
     }
-  }),
-  [api]);
+  }), [api]);
   const listenForCapture = useMemoOne.useCallback(function listenForCapture() {
     const options = {
       capture: true,
@@ -5912,7 +5572,6 @@ function useTouchSensor(api) {
     if (current.type === 'IDLE') {
       return;
     }
-
     if (current.type === 'PENDING') {
       clearTimeout(current.longPressTimerId);
     }
@@ -5942,7 +5601,6 @@ function useTouchSensor(api) {
       completed: stop,
       getPhase
     };
-
     const unbindTarget = bindEvents(window, getHandleBindings(args), options);
     const unbindWindow = bindEvents(window, getWindowBindings(args), options);
     unbindEventsRef.current = function unbindAll() {
@@ -5975,7 +5633,6 @@ function useTouchSensor(api) {
     listenForCapture();
     return function unmount() {
       unbindEventsRef.current();
-
       const phase = getPhase();
       if (phase.type === 'PENDING') {
         clearTimeout(phase.longPressTimerId);
@@ -5983,7 +5640,6 @@ function useTouchSensor(api) {
       }
     };
   }, [getPhase, listenForCapture, setPhase]);
-
   useLayoutEffect(function webkitHack() {
     const unbind = bindEvents(window, [{
       eventName: 'touchmove',
@@ -6011,21 +5667,17 @@ function isAnInteractiveElement(parent, current) {
   if (current == null) {
     return false;
   }
-
   const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
   if (hasAnInteractiveTag) {
     return true;
   }
-
   const attribute = current.getAttribute('contenteditable');
   if (attribute === 'true' || attribute === '') {
     return true;
   }
-
   if (current === parent) {
     return false;
   }
-
   return isAnInteractiveElement(parent, current.parentElement);
 }
 function isEventInInteractiveElement(draggable, event) {
@@ -6044,11 +5696,9 @@ function isElement(el) {
 
 const supportedMatchesName = (() => {
   const base = 'matches';
-
   if (typeof document === 'undefined') {
     return base;
   }
-
   const candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];
   const value = candidates.find(name => name in Element.prototype);
   return value || base;
@@ -6057,11 +5707,9 @@ function closestPonyfill(el, selector) {
   if (el == null) {
     return null;
   }
-
   if (el[supportedMatchesName](selector)) {
     return el;
   }
-
   return closestPonyfill(el.parentElement, selector);
 }
 function closest(el, selector) {
@@ -6172,11 +5820,9 @@ function canStart(_ref2) {
     process.env.NODE_ENV !== "production" ? warning(`Unable to find draggable with id: ${draggableId}`) : void 0;
     return false;
   }
-
   if (!entry.options.isEnabled) {
     return false;
   }
-
   if (!canStartDrag(store.getState(), draggableId)) {
     return false;
   }
@@ -6207,11 +5853,9 @@ function tryStart(_ref3) {
     process.env.NODE_ENV !== "production" ? warning(`Unable to find draggable element with id: ${draggableId}`) : void 0;
     return null;
   }
-
   if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
     return null;
   }
-
   const lock = lockAPI.claim(forceSensorStop || noop$2);
   let phase = 'PRE_DRAG';
   function getShouldRespectForcePress() {
@@ -6241,7 +5885,6 @@ function tryStart(_ref3) {
       process.env.NODE_ENV !== "production" ? invariant(false, `Cannot lift in phase ${phase}`) : invariant(false) ;
     }
     store.dispatch(lift$1(args.liftActionArgs));
-
     phase = 'DRAGGING';
     function finish(reason, options) {
       if (options === void 0) {
@@ -6250,7 +5893,6 @@ function tryStart(_ref3) {
         };
       }
       args.cleanup();
-
       if (options.shouldBlockNextClick) {
         const unbind = bindEvents(window, [{
           eventName: 'click',
@@ -6263,7 +5905,6 @@ function tryStart(_ref3) {
         }]);
         setTimeout(unbind);
       }
-
       completed();
       store.dispatch(drop$1({
         reason
@@ -6283,7 +5924,7 @@ function tryStart(_ref3) {
     };
   }
   function fluidLift(clientSelection) {
-    const move$1 = rafSchd__default["default"](client => {
+    const move$1 = rafSchd(client => {
       tryDispatchWhenDragging(() => move({
         client
       }));
@@ -6362,7 +6003,6 @@ function useSensorMarshal(_ref4) {
       lockAPI.tryAbandon();
     }
   }, [lockAPI]);
-
   useLayoutEffect(function listenToStore() {
     let previous = store.getState();
     const unsubscribe = store.subscribe(() => {
@@ -6370,10 +6010,8 @@ function useSensorMarshal(_ref4) {
       tryAbandonLock(previous, current);
       previous = current;
     });
-
     return unsubscribe;
   }, [lockAPI, store, tryAbandonLock]);
-
   useLayoutEffect(() => {
     return lockAPI.tryAbandon;
   }, [lockAPI.tryAbandon]);
@@ -6417,7 +6055,6 @@ function useSensorMarshal(_ref4) {
     tryReleaseLock,
     isLockClaimed
   }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
-
   useValidateSensorHooks(useSensors);
   for (let i = 0; i < useSensors.length; i++) {
     useSensors[i](api);
@@ -6431,7 +6068,7 @@ const createResponders = props => ({
         props.onBeforeCapture(t);
       }
     };
-    if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+    if (React.version.startsWith('16') || React.version.startsWith('17')) {
       onBeforeCapureCallback();
     } else {
       ReactDOM.flushSync(onBeforeCapureCallback);
@@ -6464,7 +6101,6 @@ function App(props) {
   } = props;
   const lazyStoreRef = React.useRef(null);
   useStartupValidation();
-
   const lastPropsRef = usePrevious(props);
   const getResponders = useMemoOne.useCallback(() => {
     return createResponders(lastPropsRef.current);
@@ -6509,13 +6145,11 @@ function App(props) {
     getResponders,
     styleMarshal
   }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
-
   if (process.env.NODE_ENV !== 'production') {
     if (lazyStoreRef.current && lazyStoreRef.current !== store) {
       process.env.NODE_ENV !== "production" ? warning('unexpected store change') : void 0;
     }
   }
-
   lazyStoreRef.current = store;
   const tryResetStore = useMemoOne.useCallback(() => {
     const current = getStore(lazyStoreRef);
@@ -6538,7 +6172,6 @@ function App(props) {
     isDragging,
     tryAbort: tryResetStore
   }), [isDragging, tryResetStore]);
-
   setCallbacks(appCallbacks);
   const getCanLift = useMemoOne.useCallback(id => canStartDrag(getStore(lazyStoreRef).getState(), id), []);
   const getIsMovementAllowed = useMemoOne.useCallback(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
@@ -6558,13 +6191,12 @@ function App(props) {
     customSensors: sensors || null,
     enableDefaultSensors: props.enableDefaultSensors !== false
   });
-
   React.useEffect(() => {
     return tryResetStore;
   }, [tryResetStore]);
-  return React__default["default"].createElement(AppContext.Provider, {
+  return React.createElement(AppContext.Provider, {
     value: appContext
-  }, React__default["default"].createElement(reactRedux.Provider, {
+  }, React.createElement(reactRedux.Provider, {
     context: StoreContext,
     store: store
   }, props.children));
@@ -6578,13 +6210,12 @@ function useDeprecatedUniqueContextId() {
   return useMemoOne.useMemo(() => `${count++}`, []);
 }
 function useUniqueContextId() {
-  return React__default["default"].useId();
+  return React.useId();
 }
-
-var useUniqueContextId$1 = 'useId' in React__default["default"] ? useUniqueContextId : useDeprecatedUniqueContextId;
+var useUniqueContextId$1 = 'useId' in React ? useUniqueContextId : useDeprecatedUniqueContextId;
 
 function resetServerContext() {
-  if ('useId' in React__default["default"]) {
+  if ('useId' in React) {
     process.env.NODE_ENV !== "production" ? warning(`It is not necessary to call resetServerContext when using React 18+`) : void 0;
     return;
   }
@@ -6594,8 +6225,7 @@ function resetServerContext() {
 function DragDropContext(props) {
   const contextId = useUniqueContextId$1();
   const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;
-
-  return React__default["default"].createElement(ErrorBoundary, null, setCallbacks => React__default["default"].createElement(App, {
+  return React.createElement(ErrorBoundary, null, setCallbacks => React.createElement(App, {
     nonce: props.nonce,
     contextId: contextId,
     setCallbacks: setCallbacks,
@@ -6728,12 +6358,10 @@ function useDraggablePublisher(args) {
   }), [descriptor, getDimension, options, uniqueId]);
   const publishedRef = React.useRef(entry);
   const isFirstPublishRef = React.useRef(true);
-
   useLayoutEffect(() => {
     registry.draggable.register(publishedRef.current);
     return () => registry.draggable.unregister(publishedRef.current);
   }, [registry.draggable]);
-
   useLayoutEffect(() => {
     if (isFirstPublishRef.current) {
       isFirstPublishRef.current = false;
@@ -6745,7 +6373,7 @@ function useDraggablePublisher(args) {
   }, [entry, registry.draggable]);
 }
 
-var DroppableContext = React__default["default"].createContext(null);
+var DroppableContext = React.createContext(null);
 
 function checkIsValidInnerRef(el) {
   !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== "production" ? invariant(false, `
@@ -6761,7 +6389,6 @@ function useValidation$1(props, contextId, getRef) {
     function prefix(id) {
       return `Draggable[id: ${id}]: `;
     }
-
     const id = props.draggableId;
     !id ? process.env.NODE_ENV !== "production" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;
     !(typeof id === 'string') ? process.env.NODE_ENV !== "production" ? invariant(false, `Draggable requires a [string] draggableId.
@@ -6770,19 +6397,15 @@ function useValidation$1(props, contextId, getRef) {
     if (props.mapped.type === 'DRAGGING') {
       return;
     }
-
     checkIsValidInnerRef(getRef());
-
     if (props.isEnabled) {
       !findDragHandle(contextId, id) ? process.env.NODE_ENV !== "production" ? invariant(false, `${prefix(id)} Unable to find drag handle`) : invariant(false) : void 0;
     }
   });
 }
-
 function useClonePropValidation(isClone) {
   useDev(() => {
     const initialRef = React.useRef(isClone);
-
     useDevSetupWarning(() => {
       !(isClone === initialRef.current) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;
     }, [isClone]);
@@ -6807,7 +6430,6 @@ const Draggable = props => {
     ref.current = el;
   }, []);
   const getRef = useMemoOne.useCallback(() => ref.current, []);
-
   const {
     contextId,
     dragHandleUsageInstructionsId,
@@ -6823,7 +6445,6 @@ const Draggable = props => {
     type,
     droppableId
   }), [props.draggableId, props.index, type, droppableId]);
-
   const {
     children,
     draggableId,
@@ -6834,9 +6455,7 @@ const Draggable = props => {
     mapped,
     dropAnimationFinished: dropAnimationFinishedAction
   } = props;
-
   useValidation$1(props, contextId, getRef);
-
   useClonePropValidation(isClone);
   if (!isClone) {
     const forPublisher = useMemoOne.useMemo(() => ({
@@ -6849,7 +6468,6 @@ const Draggable = props => {
     }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
     useDraggablePublisher(forPublisher);
   }
-
   const dragHandleProps = useMemoOne.useMemo(() => isEnabled ? {
     tabIndex: 0,
     role: 'button',
@@ -6866,11 +6484,10 @@ const Draggable = props => {
     if (!mapped.dropping) {
       return;
     }
-
     if (event.propertyName !== 'transform') {
       return;
     }
-    if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+    if (React.version.startsWith('16') || React.version.startsWith('17')) {
       dropAnimationFinishedAction();
     } else {
       ReactDOM.flushSync(dropAnimationFinishedAction);
@@ -6899,7 +6516,7 @@ const Draggable = props => {
       droppableId: descriptor.droppableId
     }
   }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
-  return React__default["default"].createElement(React__default["default"].Fragment, null, children(provided, mapped.snapshot, rubric));
+  return React.createElement(React.Fragment, null, children(provided, mapped.snapshot, rubric));
 };
 var Draggable$1 = Draggable;
 
@@ -6926,11 +6543,11 @@ const getCombineWithFromImpact = impact => {
   return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;
 };
 function getDraggableSelector() {
-  const memoizedOffset = memoizeOne__default["default"]((x, y) => ({
+  const memoizedOffset = memoizeOne((x, y) => ({
     x,
     y
   }));
-  const getMemoizedSnapshot = memoizeOne__default["default"](function (mode, isClone, draggingOver, combineWith, dropping) {
+  const getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {
     if (draggingOver === void 0) {
       draggingOver = null;
     }
@@ -6951,9 +6568,7 @@ function getDraggableSelector() {
       combineTargetFor: null
     };
   });
-  const getMemoizedProps = memoizeOne__default["default"](function (offset, mode, dimension, isClone,
-  draggingOver,
-  combineWith, forceShouldAnimate) {
+  const getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
     if (draggingOver === void 0) {
       draggingOver = null;
     }
@@ -6989,7 +6604,6 @@ function getDraggableSelector() {
       const forceShouldAnimate = state.forceShouldAnimate;
       return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
     }
-
     if (state.phase === 'DROP_ANIMATING') {
       const completed = state.completed;
       if (completed.result.draggableId !== ownProps.draggableId) {
@@ -7002,7 +6616,6 @@ function getDraggableSelector() {
       const draggingOver = whatIsDraggedOverFromResult(result);
       const combineWith = getCombineWithFromResult(result);
       const duration = state.dropDuration;
-
       const dropping = {
         duration,
         curve: curves.drop,
@@ -7053,13 +6666,12 @@ const atRest = {
   }
 };
 function getSecondarySelector() {
-  const memoizedOffset = memoizeOne__default["default"]((x, y) => ({
+  const memoizedOffset = memoizeOne((x, y) => ({
     x,
     y
   }));
-  const getMemoizedSnapshot = memoizeOne__default["default"](getSecondarySnapshot);
-  const getMemoizedProps = memoizeOne__default["default"](function (offset,
-  combineTargetFor, shouldAnimateDisplacement) {
+  const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
+  const getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {
     if (combineTargetFor === void 0) {
       combineTargetFor = null;
     }
@@ -7073,7 +6685,6 @@ function getSecondarySelector() {
       }
     };
   });
-
   const getFallback = combineTargetFor => {
     return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
   };
@@ -7086,11 +6697,9 @@ function getSecondarySelector() {
       if (!isAfterCriticalInVirtualList) {
         return getFallback(combineTargetFor);
       }
-
       if (impact.displaced.invisible[ownId]) {
         return null;
       }
-
       const change = negate(afterCritical.displacedBy.point);
       const offset = memoizedOffset(change.x, change.y);
       return getMemoizedProps(offset, combineTargetFor, true);
@@ -7109,7 +6718,6 @@ function getSecondarySelector() {
       }
       return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
     }
-
     if (state.phase === 'DROP_ANIMATING') {
       const completed = state.completed;
       if (completed.result.draggableId === ownProps.draggableId) {
@@ -7117,12 +6725,10 @@ function getSecondarySelector() {
       }
       return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
     }
-
     return null;
   };
   return selector;
 }
-
 const makeMapStateToProps$1 = () => {
   const draggingSelector = getDraggableSelector();
   const secondarySelector = getSecondarySelector();
@@ -7132,15 +6738,10 @@ const makeMapStateToProps$1 = () => {
 const mapDispatchToProps$1 = {
   dropAnimationFinished: dropAnimationFinished
 };
-
-const ConnectedDraggable = reactRedux.connect(
-makeMapStateToProps$1, mapDispatchToProps$1,
-null,
-{
+const ConnectedDraggable = reactRedux.connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
   context: StoreContext,
   areStatePropsEqual: isStrictEqual
-}
-)(Draggable$1);
+})(Draggable$1);
 var ConnectedDraggable$1 = ConnectedDraggable;
 
 function PrivateDraggable(props) {
@@ -7149,14 +6750,13 @@ function PrivateDraggable(props) {
   if (isUsingCloneFor === props.draggableId && !props.isClone) {
     return null;
   }
-  return React__default["default"].createElement(ConnectedDraggable$1, props);
+  return React.createElement(ConnectedDraggable$1, props);
 }
-
 function PublicDraggable(props) {
   const isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
   const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
   const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
-  return React__default["default"].createElement(PrivateDraggable, _extends__default["default"]({}, props, {
+  return React.createElement(PrivateDraggable, _extends({}, props, {
     isClone: false,
     isEnabled: isEnabled,
     canDragInteractiveElements: canDragInteractiveElements,
@@ -7178,7 +6778,6 @@ const isElementScrollable = el => {
   };
   return isEither(overflow, isScroll) || isEither(overflow, isAuto);
 };
-
 const isBodyScrollable = () => {
   if (process.env.NODE_ENV === 'production') {
     return false;
@@ -7186,7 +6785,6 @@ const isBodyScrollable = () => {
   const body = getBodyElement();
   const html = document.documentElement;
   !html ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-
   if (!isElementScrollable(body)) {
     return false;
   }
@@ -7214,18 +6812,15 @@ const getClosestScrollable = el => {
   if (el == null) {
     return null;
   }
-
   if (el === document.body) {
     return isBodyScrollable() ? el : null;
   }
-
   if (el === document.documentElement) {
     return null;
   }
   if (!isElementScrollable(el)) {
     return getClosestScrollable(el.parentElement);
   }
-
   return el;
 };
 var getClosestScrollable$1 = getClosestScrollable;
@@ -7290,7 +6885,6 @@ var getDroppableDimension = (_ref => {
       scrollSize,
       client: frameClient
     } = closest;
-
     const maxScroll = getMaxScroll({
       scrollHeight: scrollSize.scrollHeight,
       scrollWidth: scrollSize.scrollWidth,
@@ -7336,29 +6930,23 @@ var getDroppableDimension = (_ref => {
 
 const getClient = (targetRef, closestScrollable) => {
   const base = cssBoxModel.getBox(targetRef);
-
   if (!closestScrollable) {
     return base;
   }
-
   if (targetRef !== closestScrollable) {
     return base;
   }
-
   const top = base.paddingBox.top - closestScrollable.scrollTop;
   const left = base.paddingBox.left - closestScrollable.scrollLeft;
   const bottom = top + closestScrollable.scrollHeight;
   const right = left + closestScrollable.scrollWidth;
-
   const paddingBox = {
     top,
     right,
     bottom,
     left
   };
-
   const borderBox = cssBoxModel.expand(paddingBox, base.border);
-
   const client = cssBoxModel.createBox({
     borderBox,
     margin: base.margin,
@@ -7435,7 +7023,7 @@ function useDroppablePublisher(args) {
     mode: args.mode
   }), [args.droppableId, args.mode, args.type]);
   const publishedDescriptorRef = React.useRef(descriptor);
-  const memoizedUpdateScroll = useMemoOne.useMemo(() => memoizeOne__default["default"]((x, y) => {
+  const memoizedUpdateScroll = useMemoOne.useMemo(() => memoizeOne((x, y) => {
     !whileDraggingRef.current ? process.env.NODE_ENV !== "production" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;
     const scroll = {
       x,
@@ -7454,7 +7042,7 @@ function useDroppablePublisher(args) {
     const scroll = getClosestScroll();
     memoizedUpdateScroll(scroll.x, scroll.y);
   }, [getClosestScroll, memoizedUpdateScroll]);
-  const scheduleScrollUpdate = useMemoOne.useMemo(() => rafSchd__default["default"](updateScroll), [updateScroll]);
+  const scheduleScrollUpdate = useMemoOne.useMemo(() => rafSchd(updateScroll), [updateScroll]);
   const onClosestScroll = useMemoOne.useCallback(() => {
     const dragging = whileDraggingRef.current;
     const closest = getClosestScrollableFromDrag(dragging);
@@ -7492,7 +7080,6 @@ function useDroppablePublisher(args) {
     const scrollable = env.closestScrollable;
     if (scrollable) {
       scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
-
       scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
       if (process.env.NODE_ENV !== 'production') {
         checkForNestedScrollContainers(scrollable);
@@ -7510,23 +7097,19 @@ function useDroppablePublisher(args) {
     const dragging = whileDraggingRef.current;
     !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;
     const closest = getClosestScrollableFromDrag(dragging);
-
     whileDraggingRef.current = null;
     if (!closest) {
       return;
     }
-
     scheduleScrollUpdate.cancel();
     closest.removeAttribute(scrollContainer.contextId);
-    closest.removeEventListener('scroll', onClosestScroll,
-    getListenerOptions(dragging.scrollOptions));
+    closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
   }, [onClosestScroll, scheduleScrollUpdate]);
   const scroll = useMemoOne.useCallback(change => {
     const dragging = whileDraggingRef.current;
     !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;
     const closest = getClosestScrollableFromDrag(dragging);
     !closest ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;
-
     closest.scrollTop += change.y;
     closest.scrollLeft += change.x;
   }, []);
@@ -7543,7 +7126,6 @@ function useDroppablePublisher(args) {
     descriptor,
     callbacks
   }), [callbacks, descriptor, uniqueId]);
-
   useLayoutEffect(() => {
     publishedDescriptorRef.current = entry.descriptor;
     registry.droppable.register(entry);
@@ -7555,14 +7137,12 @@ function useDroppablePublisher(args) {
       registry.droppable.unregister(entry);
     };
   }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
-
   useLayoutEffect(() => {
     if (!whileDraggingRef.current) {
       return;
     }
     marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
   }, [args.isDropDisabled, marshal]);
-
   useLayoutEffect(() => {
     if (!whileDraggingRef.current) {
       return;
@@ -7608,7 +7188,6 @@ const getStyle = _ref2 => {
   });
   return {
     display: placeholder.display,
-
     boxSizing: 'border-box',
     width: size.width,
     height: size.height,
@@ -7638,18 +7217,15 @@ const Placeholder = props => {
     contextId
   } = props;
   const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = React.useState(props.animate === 'open');
-
   React.useEffect(() => {
     if (!isAnimatingOpenOnMount) {
       return noop;
     }
-
     if (animate !== 'open') {
       tryClearAnimateOpenTimer();
       setIsAnimatingOpenOnMount(false);
       return noop;
     }
-
     if (animateOpenTimerRef.current) {
       return noop;
     }
@@ -7657,7 +7233,6 @@ const Placeholder = props => {
       animateOpenTimerRef.current = null;
       setIsAnimatingOpenOnMount(false);
     });
-
     return tryClearAnimateOpenTimer;
   }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
   const onSizeChangeEnd = useMemoOne.useCallback(event => {
@@ -7674,14 +7249,14 @@ const Placeholder = props => {
     animate: props.animate,
     placeholder: props.placeholder
   });
-  return React__default["default"].createElement(props.placeholder.tagName, {
+  return React.createElement(props.placeholder.tagName, {
     style,
     'data-rfd-placeholder-context-id': contextId,
     onTransitionEnd: onSizeChangeEnd,
     ref: props.innerRef
   });
 };
-var Placeholder$1 = React__default["default"].memo(Placeholder);
+var Placeholder$1 = React.memo(Placeholder);
 
 function isBoolean(value) {
   return typeof value === 'boolean';
@@ -7751,7 +7326,7 @@ function useValidation(args) {
   });
 }
 
-class AnimateInOut extends React__default["default"].PureComponent {
+class AnimateInOut extends React.PureComponent {
   constructor() {
     super(...arguments);
     this.state = {
@@ -7776,7 +7351,6 @@ class AnimateInOut extends React__default["default"].PureComponent {
         animate: 'none'
       };
     }
-
     if (props.on) {
       return {
         isVisible: true,
@@ -7784,7 +7358,6 @@ class AnimateInOut extends React__default["default"].PureComponent {
         animate: 'open'
       };
     }
-
     if (state.isVisible) {
       return {
         isVisible: true,
@@ -7792,7 +7365,6 @@ class AnimateInOut extends React__default["default"].PureComponent {
         animate: 'close'
       };
     }
-
     return {
       isVisible: false,
       animate: 'close',
@@ -7871,7 +7443,7 @@ const Droppable = props => {
     ignoreContainerClipping,
     getDroppableRef
   });
-  const placeholder = useMemoOne.useMemo(() => React__default["default"].createElement(AnimateInOut, {
+  const placeholder = useMemoOne.useMemo(() => React.createElement(AnimateInOut, {
     on: props.placeholder,
     shouldAnimate: props.shouldAnimatePlaceholder
   }, _ref => {
@@ -7880,7 +7452,7 @@ const Droppable = props => {
       data,
       animate
     } = _ref;
-    return React__default["default"].createElement(Placeholder$1, {
+    return React.createElement(Placeholder$1, {
       placeholder: data,
       onClose: onClose,
       innerRef: setPlaceholderRef,
@@ -7911,18 +7483,17 @@ const Droppable = props => {
       dragging,
       render
     } = useClone;
-    const node = React__default["default"].createElement(PrivateDraggable, {
+    const node = React.createElement(PrivateDraggable, {
       draggableId: dragging.draggableId,
       index: dragging.source.index,
       isClone: true,
-      isEnabled: true
-      ,
+      isEnabled: true,
       shouldRespectForcePress: false,
       canDragInteractiveElements: true
     }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));
-    return ReactDOM__default["default"].createPortal(node, getContainerForClone());
+    return ReactDOM.createPortal(node, getContainerForClone());
   }
-  return React__default["default"].createElement(DroppableContext.Provider, {
+  return React.createElement(DroppableContext.Provider, {
     value: droppableContext
   }, children(provided, snapshot), getClone());
 };
@@ -7930,7 +7501,20 @@ var Droppable$1 = Droppable;
 
 const isMatchingType = (type, critical) => type === critical.droppable.type;
 const getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
-
+function getBody() {
+  !document.body ? process.env.NODE_ENV !== "production" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;
+  return document.body;
+}
+const defaultProps = {
+  mode: 'standard',
+  type: 'DEFAULT',
+  direction: 'vertical',
+  isDropDisabled: false,
+  isCombineEnabled: false,
+  ignoreContainerClipping: false,
+  renderClone: null,
+  getContainerForClone: getBody
+};
 const makeMapStateToProps = () => {
   const idleWithAnimation = {
     placeholder: null,
@@ -7947,7 +7531,7 @@ const makeMapStateToProps = () => {
     ...idleWithAnimation,
     shouldAnimatePlaceholder: false
   };
-  const getDraggableRubric = memoizeOne__default["default"](descriptor => ({
+  const getDraggableRubric = memoizeOne(descriptor => ({
     draggableId: descriptor.id,
     type: descriptor.type,
     source: {
@@ -7955,7 +7539,7 @@ const makeMapStateToProps = () => {
       droppableId: descriptor.droppableId
     }
   }));
-  const getMapProps = memoizeOne__default["default"]((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
+  const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
     const draggableId = dragging.descriptor.id;
     const isHome = dragging.descriptor.droppableId === id;
     if (isHome) {
@@ -7979,7 +7563,6 @@ const makeMapStateToProps = () => {
     if (!isEnabled) {
       return idleWithoutAnimation;
     }
-
     if (!isDraggingOverForImpact) {
       return idleWithAnimation;
     }
@@ -7996,12 +7579,15 @@ const makeMapStateToProps = () => {
       useClone: null
     };
   });
-  const selector = (state, ownProps) => {
-
-    const id = ownProps.droppableId;
-    const type = ownProps.type;
-    const isEnabled = !ownProps.isDropDisabled;
-    const renderClone = ownProps.renderClone;
+  const selector = (state, _ref) => {
+    let {
+      droppableId,
+      type = defaultProps.type,
+      isDropDisabled = defaultProps.isDropDisabled,
+      renderClone = defaultProps.renderClone
+    } = _ref;
+    const id = droppableId;
+    const isEnabled = !isDropDisabled;
     if (isDragging(state)) {
       const critical = state.critical;
       if (!isMatchingType(type, critical)) {
@@ -8017,7 +7603,6 @@ const makeMapStateToProps = () => {
         return idleWithoutAnimation;
       }
       const dragging = getDraggable(completed.critical, state.dimensions);
-
       return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);
     }
     if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {
@@ -8025,20 +7610,17 @@ const makeMapStateToProps = () => {
       if (!isMatchingType(type, completed.critical)) {
         return idleWithoutAnimation;
       }
-
       const wasOver = whatIsDraggedOver(completed.impact) === id;
       const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === 'COMBINE');
       const isHome = completed.critical.droppable.id === id;
       if (wasOver) {
         return wasCombining ? idleWithAnimation : idleWithoutAnimation;
       }
-
       if (isHome) {
         return idleWithAnimation;
       }
       return idleWithoutAnimation;
     }
-
     return idleWithoutAnimation;
   };
   return selector;
@@ -8046,30 +7628,23 @@ const makeMapStateToProps = () => {
 const mapDispatchToProps = {
   updateViewportMaxScroll: updateViewportMaxScroll
 };
-function getBody() {
-  !document.body ? process.env.NODE_ENV !== "production" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;
-  return document.body;
-}
-const defaultProps = {
-  mode: 'standard',
-  type: 'DEFAULT',
-  direction: 'vertical',
-  isDropDisabled: false,
-  isCombineEnabled: false,
-  ignoreContainerClipping: false,
-  renderClone: null,
-  getContainerForClone: getBody
-};
-
-const ConnectedDroppable = reactRedux.connect(
-makeMapStateToProps,
-mapDispatchToProps,
-null, {
+const ConnectedDroppable = reactRedux.connect(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {
+  const props = {
+    ...ownProps,
+    ...stateProps,
+    ...dispatchProps
+  };
+  console.log('CHUJ');
+  for (const propName in defaultProps) {
+    if (props[propName] === undefined) {
+      props[propName] = defaultProps[propName];
+    }
+  }
+  return props;
+}, {
   context: StoreContext,
   areStatePropsEqual: isStrictEqual
-}
-)(Droppable$1);
-ConnectedDroppable.defaultProps = defaultProps;
+})(Droppable$1);
 var ConnectedDroppable$1 = ConnectedDroppable;
 
 exports.DragDropContext = DragDropContext;
diff --git a/dist/dnd.d.ts b/dist/dnd.d.ts
index 93962f6092a9e588d4a1737f5e9c2f187d1987b4..50f0e21de32872db470578db05e8f5b97861043a 100644
--- a/dist/dnd.d.ts
+++ b/dist/dnd.d.ts
@@ -1,19 +1,19 @@
 import { Position } from 'css-box-model';
 import { ReactNode, TransitionEventHandler, DragEventHandler, FunctionComponent } from 'react';
 
-declare type Id = string;
-declare type DraggableId = Id;
-declare type DroppableId = Id;
-declare type TypeId = Id;
-declare type ContextId = Id;
-declare type ElementId = Id;
-declare type DroppableMode = 'standard' | 'virtual';
+type Id = string;
+type DraggableId = Id;
+type DroppableId = Id;
+type TypeId = Id;
+type ContextId = Id;
+type ElementId = Id;
+type DroppableMode = 'standard' | 'virtual';
 interface DraggableOptions {
     canDragInteractiveElements: boolean;
     shouldRespectForcePress: boolean;
     isEnabled: boolean;
 }
-declare type Direction = 'horizontal' | 'vertical';
+type Direction = 'horizontal' | 'vertical';
 interface DraggableLocation {
     droppableId: DroppableId;
     index: number;
@@ -22,7 +22,7 @@ interface Combine {
     draggableId: DraggableId;
     droppableId: DroppableId;
 }
-declare type MovementMode = 'FLUID' | 'SNAP';
+type MovementMode = 'FLUID' | 'SNAP';
 interface DraggableRubric {
     draggableId: DraggableId;
     type: TypeId;
@@ -39,19 +39,19 @@ interface DragUpdate extends DragStart {
     destination: DraggableLocation | null;
     combine: Combine | null;
 }
-declare type DropReason = 'DROP' | 'CANCEL';
+type DropReason = 'DROP' | 'CANCEL';
 interface DropResult extends DragUpdate {
     reason: DropReason;
 }
-declare type Announce = (message: string) => void;
+type Announce = (message: string) => void;
 interface ResponderProvided {
     announce: Announce;
 }
-declare type OnBeforeCaptureResponder = (before: BeforeCapture) => void;
-declare type OnBeforeDragStartResponder = (start: DragStart) => void;
-declare type OnDragStartResponder = (start: DragStart, provided: ResponderProvided) => void;
-declare type OnDragUpdateResponder = (update: DragUpdate, provided: ResponderProvided) => void;
-declare type OnDragEndResponder = (result: DropResult, provided: ResponderProvided) => void;
+type OnBeforeCaptureResponder = (before: BeforeCapture) => void;
+type OnBeforeDragStartResponder = (start: DragStart) => void;
+type OnDragStartResponder = (start: DragStart, provided: ResponderProvided) => void;
+type OnDragUpdateResponder = (update: DragUpdate, provided: ResponderProvided) => void;
+type OnDragEndResponder = (result: DropResult, provided: ResponderProvided) => void;
 interface Responders {
     onBeforeCapture?: OnBeforeCaptureResponder;
     onBeforeDragStart?: OnBeforeDragStartResponder;
@@ -87,7 +87,7 @@ interface PreDragActions {
 interface TryGetLockOptions {
     sourceEvent?: Event;
 }
-declare type TryGetLock = (draggableId: DraggableId, forceStop?: () => void, options?: TryGetLockOptions) => PreDragActions | null;
+type TryGetLock = (draggableId: DraggableId, forceStop?: () => void, options?: TryGetLockOptions) => PreDragActions | null;
 interface SensorAPI {
     tryGetLock: TryGetLock;
     canGetLock: (id: DraggableId) => boolean;
@@ -96,9 +96,9 @@ interface SensorAPI {
     findClosestDraggableId: (event: Event) => DraggableId | null;
     findOptionsForDraggable: (id: DraggableId) => DraggableOptions | null;
 }
-declare type Sensor = (api: SensorAPI) => void;
+type Sensor = (api: SensorAPI) => void;
 
-declare type RecursivePartial<T> = {
+type RecursivePartial<T> = {
     [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends (...args: any) => any ? T[P] | undefined : T[P] extends object ? RecursivePartial<T[P]> : T[P];
 };
 
@@ -142,7 +142,7 @@ interface AutoScrollerOptions {
      */
     disabled: boolean;
 }
-declare type PartialAutoScrollerOptions = RecursivePartial<AutoScrollerOptions>;
+type PartialAutoScrollerOptions = RecursivePartial<AutoScrollerOptions>;
 
 interface DragDropContextProps extends Responders {
     children: ReactNode | null;
@@ -175,7 +175,7 @@ interface NotDraggingStyle {
     transform?: string;
     transition?: 'none';
 }
-declare type DraggableStyle = DraggingStyle | NotDraggingStyle;
+type DraggableStyle = DraggingStyle | NotDraggingStyle;
 interface DraggableProvidedDraggableProps {
     style?: DraggableStyle;
     'data-rfd-draggable-context-id': ContextId;
@@ -213,7 +213,7 @@ interface DraggableStateSnapshot {
     combineTargetFor: DraggableId | null;
     mode: MovementMode | null;
 }
-declare type DraggableChildrenFn = (provided: DraggableProvided, snapshot: DraggableStateSnapshot, rubic: DraggableRubric) => ReactNode | null;
+type DraggableChildrenFn = (provided: DraggableProvided, snapshot: DraggableStateSnapshot, rubic: DraggableRubric) => ReactNode | null;
 interface DraggableProps {
     draggableId: DraggableId;
     index: number;
diff --git a/dist/dnd.esm.js b/dist/dnd.esm.js
index 82fe002b0a10f263f7b8a5383e336abb44518349..6e758bd254834b9e3e8facec9e27ec62f00877e6 100644
--- a/dist/dnd.esm.js
+++ b/dist/dnd.esm.js
@@ -1,40 +1,59 @@
-import React, { useLayoutEffect as useLayoutEffect$1, useEffect, useRef, useState, useContext } from 'react';
+import React, {
+  useLayoutEffect as useLayoutEffect$1,
+  useEffect,
+  useRef,
+  useState,
+  useContext,
+} from 'react';
 import ReactDOM, { flushSync } from 'react-dom';
-import { createStore as createStore$1, applyMiddleware, compose, bindActionCreators } from 'redux';
+import {
+  createStore as createStore$1,
+  applyMiddleware,
+  compose,
+  bindActionCreators,
+} from 'redux';
 import { Provider, connect } from 'react-redux';
 import { useMemo, useCallback } from 'use-memo-one';
-import { getRect, expand, offset, withScroll, calculateBox, getBox, createBox } from 'css-box-model';
+import {
+  getRect,
+  expand,
+  offset,
+  withScroll,
+  calculateBox,
+  getBox,
+  createBox,
+} from 'css-box-model';
 import memoizeOne from 'memoize-one';
 import rafSchd from 'raf-schd';
 import _extends from '@babel/runtime/helpers/esm/extends';
 
 const isProduction$1 = process.env.NODE_ENV === 'production';
-
 const spacesAndTabs = /[ \t]{2,}/g;
 const lineStartWithSpaces = /^[ \t]*/gm;
-
-const clean$2 = value => value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
-const getDevMessage = message => clean$2(`
+const clean$2 = (value) =>
+  value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
+const getDevMessage = (message) =>
+  clean$2(`
   %c@hello-pangea/dnd
 
   %c${clean$2(message)}
 
   %c👷‍ This is a development only message. It will be removed in production builds.
 `);
-const getFormattedMessage = message => [getDevMessage(message),
-'color: #00C584; font-size: 1.2em; font-weight: bold;',
-'line-height: 1.5',
-'color: #723874;'];
+const getFormattedMessage = (message) => [
+  getDevMessage(message),
+  'color: #00C584; font-size: 1.2em; font-weight: bold;',
+  'line-height: 1.5',
+  'color: #723874;',
+];
 const isDisabledFlag = '__@hello-pangea/dnd-disable-dev-warnings';
 function log(type, message) {
   if (isProduction$1) {
     return;
   }
-
   if (typeof window !== 'undefined' && window[isDisabledFlag]) {
     return;
   }
-
   console[type](...getFormattedMessage(message));
 }
 const warning = log.bind(null, 'warn');
@@ -45,20 +64,19 @@ function noop$2() {}
 function getOptions(shared, fromBinding) {
   return {
     ...shared,
-    ...fromBinding
+    ...fromBinding,
   };
 }
 function bindEvents(el, bindings, sharedOptions) {
-  const unbindings = bindings.map(binding => {
+  const unbindings = bindings.map((binding) => {
     const options = getOptions(sharedOptions, binding.options);
     el.addEventListener(binding.eventName, binding.fn, options);
     return function unbind() {
       el.removeEventListener(binding.eventName, binding.fn, options);
     };
   });
-
   return function unbindAll() {
-    unbindings.forEach(unbind => {
+    unbindings.forEach((unbind) => {
       unbind();
     });
   };
@@ -70,7 +88,6 @@ class RbdInvariant extends Error {}
 RbdInvariant.prototype.toString = function toString() {
   return this.message;
 };
-
 function invariant(condition, message) {
   if (condition) {
     return;
@@ -87,14 +104,16 @@ class ErrorBoundary extends React.Component {
     super(...arguments);
     this.callbacks = null;
     this.unbind = noop$2;
-    this.onWindowError = event => {
+    this.onWindowError = (event) => {
       const callbacks = this.getCallbacks();
       if (callbacks.isDragging()) {
         callbacks.tryAbort();
-        process.env.NODE_ENV !== "production" ? warning(`
+        process.env.NODE_ENV !== 'production'
+          ? warning(`
         An error was caught by our window 'error' event listener while a drag was occurring.
         The active drag has been aborted.
-      `) : void 0;
+      `)
+          : void 0;
       }
       const err = event.error;
       if (err instanceof RbdInvariant) {
@@ -110,15 +129,17 @@ class ErrorBoundary extends React.Component {
       }
       return this.callbacks;
     };
-    this.setCallbacks = callbacks => {
+    this.setCallbacks = (callbacks) => {
       this.callbacks = callbacks;
     };
   }
   componentDidMount() {
-    this.unbind = bindEvents(window, [{
-      eventName: 'error',
-      fn: this.onWindowError
-    }]);
+    this.unbind = bindEvents(window, [
+      {
+        eventName: 'error',
+        fn: this.onWindowError,
+      },
+    ]);
   }
   componentDidCatch(err) {
     if (err instanceof RbdInvariant) {
@@ -128,7 +149,6 @@ class ErrorBoundary extends React.Component {
       this.setState({});
       return;
     }
-
     throw err;
   }
   componentWillUnmount() {
@@ -144,9 +164,8 @@ const dragHandleUsageInstructions = `
   When dragging you can use the arrow keys to move the item around and escape to cancel.
   Some screen readers may require you to be in focus mode or to use your pass through key
 `;
-const position = index => index + 1;
-
-const onDragStart = start => `
+const position = (index) => index + 1;
+const onDragStart = (start) => `
   You have lifted an item in position ${position(start.source.index)}
 `;
 const withLocation = (source, destination) => {
@@ -180,7 +199,7 @@ const withCombine = (id, source, combine) => {
       in list ${combine.droppableId}
     `;
 };
-const onDragUpdate = update => {
+const onDragUpdate = (update) => {
   const location = update.destination;
   if (location) {
     return withLocation(update.source, location);
@@ -191,11 +210,11 @@ const onDragUpdate = update => {
   }
   return 'You are over an area that cannot be dropped on';
 };
-const returnedToStart = source => `
+const returnedToStart = (source) => `
   The item has returned to its starting position
   of ${position(source.index)}
 `;
-const onDragEnd = result => {
+const onDragEnd = (result) => {
   if (result.reason === 'CANCEL') {
     return `
       Movement cancelled.
@@ -225,28 +244,28 @@ const preset = {
   dragHandleUsageInstructions,
   onDragStart,
   onDragUpdate,
-  onDragEnd
+  onDragEnd,
 };
 var preset$1 = preset;
 
 const origin = {
   x: 0,
-  y: 0
+  y: 0,
 };
 const add = (point1, point2) => ({
   x: point1.x + point2.x,
-  y: point1.y + point2.y
+  y: point1.y + point2.y,
 });
 const subtract = (point1, point2) => ({
   x: point1.x - point2.x,
-  y: point1.y - point2.y
+  y: point1.y - point2.y,
 });
-const isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;
-const negate = point => ({
+const isEqual$1 = (point1, point2) =>
+  point1.x === point2.x && point1.y === point2.y;
+const negate = (point) => ({
   x: point.x !== 0 ? -point.x : 0,
-  y: point.y !== 0 ? -point.y : 0
+  y: point.y !== 0 ? -point.y : 0,
 });
-
 const patch = function (line, value, otherValue) {
   if (otherValue === void 0) {
     otherValue = 0;
@@ -254,61 +273,65 @@ const patch = function (line, value, otherValue) {
   if (line === 'x') {
     return {
       x: value,
-      y: otherValue
+      y: otherValue,
     };
   }
   return {
     x: otherValue,
-    y: value
+    y: value,
   };
 };
-
-const distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
-
-const closest$1 = (target, points) => Math.min(...points.map(point => distance(target, point)));
-
-const apply = fn => point => ({
+const distance = (point1, point2) =>
+  Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
+const closest$1 = (target, points) =>
+  Math.min(...points.map((point) => distance(target, point)));
+const apply = (fn) => (point) => ({
   x: fn(point.x),
-  y: fn(point.y)
+  y: fn(point.y),
 });
 
-var executeClip = ((frame, subject) => {
+var executeClip = (frame, subject) => {
   const result = getRect({
     top: Math.max(subject.top, frame.top),
     right: Math.min(subject.right, frame.right),
     bottom: Math.min(subject.bottom, frame.bottom),
-    left: Math.max(subject.left, frame.left)
+    left: Math.max(subject.left, frame.left),
   });
   if (result.width <= 0 || result.height <= 0) {
     return null;
   }
   return result;
-});
+};
 
 const offsetByPosition = (spacing, point) => ({
   top: spacing.top + point.y,
   left: spacing.left + point.x,
   bottom: spacing.bottom + point.y,
-  right: spacing.right + point.x
+  right: spacing.right + point.x,
 });
-const getCorners = spacing => [{
-  x: spacing.left,
-  y: spacing.top
-}, {
-  x: spacing.right,
-  y: spacing.top
-}, {
-  x: spacing.left,
-  y: spacing.bottom
-}, {
-  x: spacing.right,
-  y: spacing.bottom
-}];
+const getCorners = (spacing) => [
+  {
+    x: spacing.left,
+    y: spacing.top,
+  },
+  {
+    x: spacing.right,
+    y: spacing.top,
+  },
+  {
+    x: spacing.left,
+    y: spacing.bottom,
+  },
+  {
+    x: spacing.right,
+    y: spacing.bottom,
+  },
+];
 const noSpacing = {
   top: 0,
   right: 0,
   bottom: 0,
-  left: 0
+  left: 0,
 };
 
 const scroll$1 = (target, frame) => {
@@ -321,7 +344,7 @@ const increase = (target, axis, withPlaceholder) => {
   if (withPlaceholder && withPlaceholder.increasedBy) {
     return {
       ...target,
-      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]
+      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line],
     };
   }
   return target;
@@ -332,29 +355,27 @@ const clip = (target, frame) => {
   }
   return getRect(target);
 };
-var getSubject = (_ref => {
-  let {
-    page,
-    withPlaceholder,
-    axis,
-    frame
-  } = _ref;
+var getSubject = (_ref) => {
+  let { page, withPlaceholder, axis, frame } = _ref;
   const scrolled = scroll$1(page.marginBox, frame);
   const increased = increase(scrolled, axis, withPlaceholder);
   const clipped = clip(increased, frame);
   return {
     page,
     withPlaceholder,
-    active: clipped
+    active: clipped,
   };
-});
+};
 
-var scrollDroppable = ((droppable, newScroll) => {
-  !droppable.frame ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
+var scrollDroppable = (droppable, newScroll) => {
+  !droppable.frame
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false)
+      : invariant(false)
+    : void 0;
   const scrollable = droppable.frame;
   const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
   const scrollDisplacement = negate(scrollDiff);
-
   const frame = {
     ...scrollable,
     scroll: {
@@ -362,39 +383,44 @@ var scrollDroppable = ((droppable, newScroll) => {
       current: newScroll,
       diff: {
         value: scrollDiff,
-        displacement: scrollDisplacement
+        displacement: scrollDisplacement,
       },
-      max: scrollable.scroll.max
-    }
+      max: scrollable.scroll.max,
+    },
   };
   const subject = getSubject({
     page: droppable.subject.page,
     withPlaceholder: droppable.subject.withPlaceholder,
     axis: droppable.axis,
-    frame
+    frame,
   });
   const result = {
     ...droppable,
     frame,
-    subject
+    subject,
   };
   return result;
-});
+};
 
-const toDroppableMap = memoizeOne(droppables => droppables.reduce((previous, current) => {
-  previous[current.descriptor.id] = current;
-  return previous;
-}, {}));
-const toDraggableMap = memoizeOne(draggables => draggables.reduce((previous, current) => {
-  previous[current.descriptor.id] = current;
-  return previous;
-}, {}));
-const toDroppableList = memoizeOne(droppables => Object.values(droppables));
-const toDraggableList = memoizeOne(draggables => Object.values(draggables));
+const toDroppableMap = memoizeOne((droppables) =>
+  droppables.reduce((previous, current) => {
+    previous[current.descriptor.id] = current;
+    return previous;
+  }, {}),
+);
+const toDraggableMap = memoizeOne((draggables) =>
+  draggables.reduce((previous, current) => {
+    previous[current.descriptor.id] = current;
+    return previous;
+  }, {}),
+);
+const toDroppableList = memoizeOne((droppables) => Object.values(droppables));
+const toDraggableList = memoizeOne((draggables) => Object.values(draggables));
 
 var getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {
-  const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId)
-  .sort((a, b) => a.descriptor.index - b.descriptor.index);
+  const result = toDraggableList(draggables)
+    .filter((draggable) => droppableId === draggable.descriptor.droppableId)
+    .sort((a, b) => a.descriptor.index - b.descriptor.index);
   return result;
 });
 
@@ -411,15 +437,17 @@ function tryGetCombine(impact) {
   return null;
 }
 
-var removeDraggableFromList = memoizeOne((remove, list) => list.filter(item => item.descriptor.id !== remove.descriptor.id));
+var removeDraggableFromList = memoizeOne((remove, list) =>
+  list.filter((item) => item.descriptor.id !== remove.descriptor.id),
+);
 
-var moveToNextCombine = (_ref => {
+var moveToNextCombine = (_ref) => {
   let {
     isMovingForward,
     draggable,
     destination,
     insideDestination,
-    previousImpact
+    previousImpact,
   } = _ref;
   if (!destination.isCombineEnabled) {
     return null;
@@ -433,12 +461,12 @@ var moveToNextCombine = (_ref => {
       type: 'COMBINE',
       combine: {
         draggableId: target,
-        droppableId: destination.descriptor.id
-      }
+        droppableId: destination.descriptor.id,
+      },
     };
     return {
       ...previousImpact,
-      at
+      at,
     };
   }
   const all = previousImpact.displaced.all;
@@ -446,8 +474,10 @@ var moveToNextCombine = (_ref => {
   if (isMovingForward) {
     return closestId ? getImpact(closestId) : null;
   }
-  const withoutDraggable = removeDraggableFromList(draggable, insideDestination);
-
+  const withoutDraggable = removeDraggableFromList(
+    draggable,
+    insideDestination,
+  );
   if (!closestId) {
     if (!withoutDraggable.length) {
       return null;
@@ -455,75 +485,92 @@ var moveToNextCombine = (_ref => {
     const last = withoutDraggable[withoutDraggable.length - 1];
     return getImpact(last.descriptor.id);
   }
-
-  const indexOfClosest = withoutDraggable.findIndex(d => d.descriptor.id === closestId);
-  !(indexOfClosest !== -1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find displaced item in set') : invariant(false) : void 0;
+  const indexOfClosest = withoutDraggable.findIndex(
+    (d) => d.descriptor.id === closestId,
+  );
+  !(indexOfClosest !== -1)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Could not find displaced item in set')
+      : invariant(false)
+    : void 0;
   const proposedIndex = indexOfClosest - 1;
-
   if (proposedIndex < 0) {
     return null;
   }
   const before = withoutDraggable[proposedIndex];
   return getImpact(before.descriptor.id);
-});
+};
 
-var isHomeOf = ((draggable, destination) => draggable.descriptor.droppableId === destination.descriptor.id);
+var isHomeOf = (draggable, destination) =>
+  draggable.descriptor.droppableId === destination.descriptor.id;
 
 const noDisplacedBy = {
   point: origin,
-  value: 0
+  value: 0,
 };
 const emptyGroups = {
   invisible: {},
   visible: {},
-  all: []
+  all: [],
 };
 const noImpact = {
   displaced: emptyGroups,
   displacedBy: noDisplacedBy,
-  at: null
+  at: null,
 };
 var noImpact$1 = noImpact;
 
-var isWithin = ((lowerBound, upperBound) => value => lowerBound <= value && value <= upperBound);
+var isWithin = (lowerBound, upperBound) => (value) =>
+  lowerBound <= value && value <= upperBound;
 
-var isPartiallyVisibleThroughFrame = (frame => {
+var isPartiallyVisibleThroughFrame = (frame) => {
   const isWithinVertical = isWithin(frame.top, frame.bottom);
   const isWithinHorizontal = isWithin(frame.left, frame.right);
-  return subject => {
-
-    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
+  return (subject) => {
+    const isContained =
+      isWithinVertical(subject.top) &&
+      isWithinVertical(subject.bottom) &&
+      isWithinHorizontal(subject.left) &&
+      isWithinHorizontal(subject.right);
     if (isContained) {
       return true;
     }
-    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
-    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
-
-    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
+    const isPartiallyVisibleVertically =
+      isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
+    const isPartiallyVisibleHorizontally =
+      isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
+    const isPartiallyContained =
+      isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
     if (isPartiallyContained) {
       return true;
     }
-    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
-    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
-
+    const isBiggerVertically =
+      subject.top < frame.top && subject.bottom > frame.bottom;
+    const isBiggerHorizontally =
+      subject.left < frame.left && subject.right > frame.right;
     const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
     if (isTargetBiggerThanFrame) {
       return true;
     }
-
-    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
+    const isTargetBiggerOnOneAxis =
+      (isBiggerVertically && isPartiallyVisibleHorizontally) ||
+      (isBiggerHorizontally && isPartiallyVisibleVertically);
     return isTargetBiggerOnOneAxis;
   };
-});
+};
 
-var isTotallyVisibleThroughFrame = (frame => {
+var isTotallyVisibleThroughFrame = (frame) => {
   const isWithinVertical = isWithin(frame.top, frame.bottom);
   const isWithinHorizontal = isWithin(frame.left, frame.right);
-  return subject => {
-    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
+  return (subject) => {
+    const isContained =
+      isWithinVertical(subject.top) &&
+      isWithinVertical(subject.bottom) &&
+      isWithinHorizontal(subject.left) &&
+      isWithinHorizontal(subject.right);
     return isContained;
   };
-});
+};
 
 const vertical = {
   direction: 'vertical',
@@ -534,7 +581,7 @@ const vertical = {
   size: 'height',
   crossAxisStart: 'left',
   crossAxisEnd: 'right',
-  crossAxisSize: 'width'
+  crossAxisSize: 'width',
 };
 const horizontal = {
   direction: 'horizontal',
@@ -545,84 +592,94 @@ const horizontal = {
   size: 'width',
   crossAxisStart: 'top',
   crossAxisEnd: 'bottom',
-  crossAxisSize: 'height'
+  crossAxisSize: 'height',
 };
 
-var isTotallyVisibleThroughFrameOnAxis = (axis => frame => {
+var isTotallyVisibleThroughFrameOnAxis = (axis) => (frame) => {
   const isWithinVertical = isWithin(frame.top, frame.bottom);
   const isWithinHorizontal = isWithin(frame.left, frame.right);
-  return subject => {
+  return (subject) => {
     if (axis === vertical) {
       return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
     }
-    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
+    return (
+      isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right)
+    );
   };
-});
+};
 
 const getDroppableDisplaced = (target, destination) => {
-  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
+  const displacement = destination.frame
+    ? destination.frame.scroll.diff.displacement
+    : origin;
   return offsetByPosition(target, displacement);
 };
 const isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {
   if (!destination.subject.active) {
     return false;
   }
-
   return isVisibleThroughFrameFn(destination.subject.active)(target);
 };
-const isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);
-const isVisible$1 = _ref => {
+const isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) =>
+  isVisibleThroughFrameFn(viewport)(target);
+const isVisible$1 = (_ref) => {
   let {
     target: toBeDisplaced,
     destination,
     viewport,
     withDroppableDisplacement,
-    isVisibleThroughFrameFn
+    isVisibleThroughFrameFn,
   } = _ref;
-  const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
-  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
+  const displacedTarget = withDroppableDisplacement
+    ? getDroppableDisplaced(toBeDisplaced, destination)
+    : toBeDisplaced;
+  return (
+    isVisibleInDroppable(
+      displacedTarget,
+      destination,
+      isVisibleThroughFrameFn,
+    ) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn)
+  );
 };
-const isPartiallyVisible = args => isVisible$1({
-  ...args,
-  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
-});
-const isTotallyVisible = args => isVisible$1({
-  ...args,
-  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
-});
-const isTotallyVisibleOnAxis = args => isVisible$1({
-  ...args,
-  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
-});
+const isPartiallyVisible = (args) =>
+  isVisible$1({
+    ...args,
+    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame,
+  });
+const isTotallyVisible = (args) =>
+  isVisible$1({
+    ...args,
+    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame,
+  });
+const isTotallyVisibleOnAxis = (args) =>
+  isVisible$1({
+    ...args,
+    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(
+      args.destination.axis,
+    ),
+  });
 
 const getShouldAnimate = (id, last, forceShouldAnimate) => {
   if (typeof forceShouldAnimate === 'boolean') {
     return forceShouldAnimate;
   }
-
   if (!last) {
     return true;
   }
-  const {
-    invisible,
-    visible
-  } = last;
-
+  const { invisible, visible } = last;
   if (invisible[id]) {
     return false;
   }
   const previous = visible[id];
   return previous ? previous.shouldAnimate : true;
 };
-
 function getTarget(draggable, displacedBy) {
   const marginBox = draggable.page.marginBox;
-
   const expandBy = {
     top: displacedBy.point.y,
     right: 0,
     bottom: 0,
-    left: displacedBy.point.x
+    left: displacedBy.point.x,
   };
   return getRect(expand(marginBox, expandBy));
 }
@@ -633,35 +690,37 @@ function getDisplacementGroups(_ref) {
     displacedBy,
     viewport,
     forceShouldAnimate,
-    last
+    last,
   } = _ref;
-  return afterDragging.reduce(function process(groups, draggable) {
-    const target = getTarget(draggable, displacedBy);
-    const id = draggable.descriptor.id;
-    groups.all.push(id);
-    const isVisible = isPartiallyVisible({
-      target,
-      destination,
-      viewport,
-      withDroppableDisplacement: true
-    });
-    if (!isVisible) {
-      groups.invisible[draggable.descriptor.id] = true;
+  return afterDragging.reduce(
+    function process(groups, draggable) {
+      const target = getTarget(draggable, displacedBy);
+      const id = draggable.descriptor.id;
+      groups.all.push(id);
+      const isVisible = isPartiallyVisible({
+        target,
+        destination,
+        viewport,
+        withDroppableDisplacement: true,
+      });
+      if (!isVisible) {
+        groups.invisible[draggable.descriptor.id] = true;
+        return groups;
+      }
+      const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
+      const displacement = {
+        draggableId: id,
+        shouldAnimate,
+      };
+      groups.visible[id] = displacement;
       return groups;
-    }
-
-    const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
-    const displacement = {
-      draggableId: id,
-      shouldAnimate
-    };
-    groups.visible[id] = displacement;
-    return groups;
-  }, {
-    all: [],
-    visible: {},
-    invisible: {}
-  });
+    },
+    {
+      all: [],
+      visible: {},
+      invisible: {},
+    },
+  );
 }
 
 function getIndexOfLastItem(draggables, options) {
@@ -669,18 +728,12 @@ function getIndexOfLastItem(draggables, options) {
     return 0;
   }
   const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
-
   return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
 }
 function goAtEnd(_ref) {
-  let {
-    insideDestination,
-    inHomeList,
-    displacedBy,
-    destination
-  } = _ref;
+  let { insideDestination, inHomeList, displacedBy, destination } = _ref;
   const newIndex = getIndexOfLastItem(insideDestination, {
-    inHomeList
+    inHomeList,
   });
   return {
     displaced: emptyGroups,
@@ -689,9 +742,9 @@ function goAtEnd(_ref) {
       type: 'REORDER',
       destination: {
         droppableId: destination.descriptor.id,
-        index: newIndex
-      }
-    }
+        index: newIndex,
+      },
+    },
   };
 }
 function calculateReorderImpact(_ref2) {
@@ -703,26 +756,26 @@ function calculateReorderImpact(_ref2) {
     displacedBy,
     last,
     index,
-    forceShouldAnimate
+    forceShouldAnimate,
   } = _ref2;
   const inHomeList = isHomeOf(draggable, destination);
-
   if (index == null) {
     return goAtEnd({
       insideDestination,
       inHomeList,
       displacedBy,
-      destination
+      destination,
     });
   }
-
-  const match = insideDestination.find(item => item.descriptor.index === index);
+  const match = insideDestination.find(
+    (item) => item.descriptor.index === index,
+  );
   if (!match) {
     return goAtEnd({
       insideDestination,
       inHomeList,
       displacedBy,
-      destination
+      destination,
     });
   }
   const withoutDragging = removeDraggableFromList(draggable, insideDestination);
@@ -734,7 +787,7 @@ function calculateReorderImpact(_ref2) {
     displacedBy,
     last,
     viewport: viewport.frame,
-    forceShouldAnimate
+    forceShouldAnimate,
   });
   return {
     displaced,
@@ -743,9 +796,9 @@ function calculateReorderImpact(_ref2) {
       type: 'REORDER',
       destination: {
         droppableId: destination.descriptor.id,
-        index
-      }
-    }
+        index,
+      },
+    },
   };
 }
 
@@ -753,21 +806,19 @@ function didStartAfterCritical(draggableId, afterCritical) {
   return Boolean(afterCritical.effected[draggableId]);
 }
 
-var fromCombine = (_ref => {
-  let {
-    isMovingForward,
-    destination,
-    draggables,
-    combine,
-    afterCritical
-  } = _ref;
+var fromCombine = (_ref) => {
+  let { isMovingForward, destination, draggables, combine, afterCritical } =
+    _ref;
   if (!destination.isCombineEnabled) {
     return null;
   }
   const combineId = combine.draggableId;
   const combineWith = draggables[combineId];
   const combineWithIndex = combineWith.descriptor.index;
-  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
+  const didCombineWithStartAfterCritical = didStartAfterCritical(
+    combineId,
+    afterCritical,
+  );
   if (didCombineWithStartAfterCritical) {
     if (isMovingForward) {
       return combineWithIndex;
@@ -778,24 +829,18 @@ var fromCombine = (_ref => {
     return combineWithIndex + 1;
   }
   return combineWithIndex;
-});
+};
 
-var fromReorder = (_ref => {
-  let {
-    isMovingForward,
-    isInHomeList,
-    insideDestination,
-    location
-  } = _ref;
+var fromReorder = (_ref) => {
+  let { isMovingForward, isInHomeList, insideDestination, location } = _ref;
   if (!insideDestination.length) {
     return null;
   }
   const currentIndex = location.index;
   const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
-
   const firstIndex = insideDestination[0].descriptor.index;
-  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
-
+  const lastIndex =
+    insideDestination[insideDestination.length - 1].descriptor.index;
   const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
   if (proposedIndex < firstIndex) {
     return null;
@@ -804,9 +849,9 @@ var fromReorder = (_ref => {
     return null;
   }
   return proposedIndex;
-});
+};
 
-var moveToNextIndex = (_ref => {
+var moveToNextIndex = (_ref) => {
   let {
     isMovingForward,
     isInHomeList,
@@ -816,16 +861,23 @@ var moveToNextIndex = (_ref => {
     insideDestination,
     previousImpact,
     viewport,
-    afterCritical
+    afterCritical,
   } = _ref;
   const wasAt = previousImpact.at;
-  !wasAt ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot move in direction without previous impact location') : invariant(false) : void 0;
+  !wasAt
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          'Cannot move in direction without previous impact location',
+        )
+      : invariant(false)
+    : void 0;
   if (wasAt.type === 'REORDER') {
     const newIndex = fromReorder({
       isMovingForward,
       isInHomeList,
       location: wasAt.destination,
-      insideDestination
+      insideDestination,
     });
     if (newIndex == null) {
       return null;
@@ -837,17 +889,16 @@ var moveToNextIndex = (_ref => {
       viewport,
       last: previousImpact.displaced,
       displacedBy: previousImpact.displacedBy,
-      index: newIndex
+      index: newIndex,
     });
   }
-
   const newIndex = fromCombine({
     isMovingForward,
     destination,
     displaced: previousImpact.displaced,
     draggables,
     combine: wasAt.combine,
-    afterCritical
+    afterCritical,
   });
   if (newIndex == null) {
     return null;
@@ -859,156 +910,138 @@ var moveToNextIndex = (_ref => {
     viewport,
     last: previousImpact.displaced,
     displacedBy: previousImpact.displacedBy,
-    index: newIndex
+    index: newIndex,
   });
-});
+};
 
-var getCombinedItemDisplacement = (_ref => {
-  let {
-    displaced,
-    afterCritical,
-    combineWith,
-    displacedBy
-  } = _ref;
-  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
+var getCombinedItemDisplacement = (_ref) => {
+  let { displaced, afterCritical, combineWith, displacedBy } = _ref;
+  const isDisplaced = Boolean(
+    displaced.visible[combineWith] || displaced.invisible[combineWith],
+  );
   if (didStartAfterCritical(combineWith, afterCritical)) {
     return isDisplaced ? origin : negate(displacedBy.point);
   }
   return isDisplaced ? displacedBy.point : origin;
-});
+};
 
-var whenCombining = (_ref => {
-  let {
-    afterCritical,
-    impact,
-    draggables
-  } = _ref;
+var whenCombining = (_ref) => {
+  let { afterCritical, impact, draggables } = _ref;
   const combine = tryGetCombine(impact);
-  !combine ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
+  !combine
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false)
+      : invariant(false)
+    : void 0;
   const combineWith = combine.draggableId;
   const center = draggables[combineWith].page.borderBox.center;
   const displaceBy = getCombinedItemDisplacement({
     displaced: impact.displaced,
     afterCritical,
     combineWith,
-    displacedBy: impact.displacedBy
+    displacedBy: impact.displacedBy,
   });
   return add(center, displaceBy);
-});
-
-const distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
-const distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
+};
 
-const getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
-const goAfter = _ref => {
-  let {
-    axis,
-    moveRelativeTo,
-    isMoving
-  } = _ref;
-  return patch(axis.line,
-  moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+const distanceFromStartToBorderBoxCenter = (axis, box) =>
+  box.margin[axis.start] + box.borderBox[axis.size] / 2;
+const distanceFromEndToBorderBoxCenter = (axis, box) =>
+  box.margin[axis.end] + box.borderBox[axis.size] / 2;
+const getCrossAxisBorderBoxCenter = (axis, target, isMoving) =>
+  target[axis.crossAxisStart] +
+  isMoving.margin[axis.crossAxisStart] +
+  isMoving.borderBox[axis.crossAxisSize] / 2;
+const goAfter = (_ref) => {
+  let { axis, moveRelativeTo, isMoving } = _ref;
+  return patch(
+    axis.line,
+    moveRelativeTo.marginBox[axis.end] +
+      distanceFromStartToBorderBoxCenter(axis, isMoving),
+    getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving),
+  );
 };
-const goBefore = _ref2 => {
-  let {
-    axis,
-    moveRelativeTo,
-    isMoving
-  } = _ref2;
-  return patch(axis.line,
-  moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+const goBefore = (_ref2) => {
+  let { axis, moveRelativeTo, isMoving } = _ref2;
+  return patch(
+    axis.line,
+    moveRelativeTo.marginBox[axis.start] -
+      distanceFromEndToBorderBoxCenter(axis, isMoving),
+    getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving),
+  );
 };
-const goIntoStart = _ref3 => {
-  let {
-    axis,
-    moveInto,
-    isMoving
-  } = _ref3;
-  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
+const goIntoStart = (_ref3) => {
+  let { axis, moveInto, isMoving } = _ref3;
+  return patch(
+    axis.line,
+    moveInto.contentBox[axis.start] +
+      distanceFromStartToBorderBoxCenter(axis, isMoving),
+    getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving),
+  );
 };
 
-var whenReordering = (_ref => {
-  let {
-    impact,
-    draggable,
+var whenReordering = (_ref) => {
+  let { impact, draggable, draggables, droppable, afterCritical } = _ref;
+  const insideDestination = getDraggablesInsideDroppable(
+    droppable.descriptor.id,
     draggables,
-    droppable,
-    afterCritical
-  } = _ref;
-  const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
+  );
   const draggablePage = draggable.page;
   const axis = droppable.axis;
-
   if (!insideDestination.length) {
     return goIntoStart({
       axis,
       moveInto: droppable.page,
-      isMoving: draggablePage
+      isMoving: draggablePage,
     });
   }
-  const {
-    displaced,
-    displacedBy
-  } = impact;
+  const { displaced, displacedBy } = impact;
   const closestAfter = displaced.all[0];
-
   if (closestAfter) {
     const closest = draggables[closestAfter];
-
     if (didStartAfterCritical(closestAfter, afterCritical)) {
       return goBefore({
         axis,
         moveRelativeTo: closest.page,
-        isMoving: draggablePage
+        isMoving: draggablePage,
       });
     }
-
     const withDisplacement = offset(closest.page, displacedBy.point);
     return goBefore({
       axis,
       moveRelativeTo: withDisplacement,
-      isMoving: draggablePage
+      isMoving: draggablePage,
     });
   }
-
   const last = insideDestination[insideDestination.length - 1];
-
   if (last.descriptor.id === draggable.descriptor.id) {
     return draggablePage.borderBox.center;
   }
   if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
-
     const page = offset(last.page, negate(afterCritical.displacedBy.point));
     return goAfter({
       axis,
       moveRelativeTo: page,
-      isMoving: draggablePage
+      isMoving: draggablePage,
     });
   }
-
   return goAfter({
     axis,
     moveRelativeTo: last.page,
-    isMoving: draggablePage
+    isMoving: draggablePage,
   });
-});
+};
 
-var withDroppableDisplacement = ((droppable, point) => {
+var withDroppableDisplacement = (droppable, point) => {
   const frame = droppable.frame;
   if (!frame) {
     return point;
   }
   return add(point, frame.scroll.diff.displacement);
-});
+};
 
-const getResultWithoutDroppableDisplacement = _ref => {
-  let {
-    impact,
-    draggable,
-    droppable,
-    draggables,
-    afterCritical
-  } = _ref;
+const getResultWithoutDroppableDisplacement = (_ref) => {
+  let { impact, draggable, droppable, draggables, afterCritical } = _ref;
   const original = draggable.page.borderBox.center;
   const at = impact.at;
   if (!droppable) {
@@ -1023,31 +1056,32 @@ const getResultWithoutDroppableDisplacement = _ref => {
       draggable,
       draggables,
       droppable,
-      afterCritical
+      afterCritical,
     });
   }
   return whenCombining({
     impact,
     draggables,
-    afterCritical
+    afterCritical,
   });
 };
-var getPageBorderBoxCenterFromImpact = (args => {
+var getPageBorderBoxCenterFromImpact = (args) => {
   const withoutDisplacement = getResultWithoutDroppableDisplacement(args);
   const droppable = args.droppable;
-  const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;
+  const withDisplacement = droppable
+    ? withDroppableDisplacement(droppable, withoutDisplacement)
+    : withoutDisplacement;
   return withDisplacement;
-});
+};
 
-var scrollViewport = ((viewport, newScroll) => {
+var scrollViewport = (viewport, newScroll) => {
   const diff = subtract(newScroll, viewport.scroll.initial);
   const displacement = negate(diff);
-
   const frame = getRect({
     top: newScroll.y,
     bottom: newScroll.y + viewport.frame.height,
     left: newScroll.x,
-    right: newScroll.x + viewport.frame.width
+    right: newScroll.x + viewport.frame.width,
   });
   const updated = {
     frame,
@@ -1057,15 +1091,15 @@ var scrollViewport = ((viewport, newScroll) => {
       current: newScroll,
       diff: {
         value: diff,
-        displacement
-      }
-    }
+        displacement,
+      },
+    },
   };
   return updated;
-});
+};
 
 function getDraggables$1(ids, draggables) {
-  return ids.map(id => draggables[id]);
+  return ids.map((id) => draggables[id]);
 }
 function tryGetVisible(id, groups) {
   for (let i = 0; i < groups.length; i++) {
@@ -1076,16 +1110,18 @@ function tryGetVisible(id, groups) {
   }
   return null;
 }
-var speculativelyIncrease = (_ref => {
-  let {
-    impact,
+var speculativelyIncrease = (_ref) => {
+  let { impact, viewport, destination, draggables, maxScrollChange } = _ref;
+  const scrolledViewport = scrollViewport(
     viewport,
-    destination,
-    draggables,
-    maxScrollChange
-  } = _ref;
-  const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
-  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
+    add(viewport.scroll.current, maxScrollChange),
+  );
+  const scrolledDroppable = destination.frame
+    ? scrollDroppable(
+        destination,
+        add(destination.frame.scroll.current, maxScrollChange),
+      )
+    : destination;
   const last = impact.displaced;
   const withViewportScroll = getDisplacementGroups({
     afterDragging: getDraggables$1(last.all, draggables),
@@ -1093,7 +1129,7 @@ var speculativelyIncrease = (_ref => {
     displacedBy: impact.displacedBy,
     viewport: scrolledViewport.frame,
     last,
-    forceShouldAnimate: false
+    forceShouldAnimate: false,
   });
   const withDroppableScroll = getDisplacementGroups({
     afterDragging: getDraggables$1(last.all, draggables),
@@ -1101,13 +1137,12 @@ var speculativelyIncrease = (_ref => {
     displacedBy: impact.displacedBy,
     viewport: viewport.frame,
     last,
-    forceShouldAnimate: false
+    forceShouldAnimate: false,
   });
   const invisible = {};
   const visible = {};
-  const groups = [
-  last, withViewportScroll, withDroppableScroll];
-  last.all.forEach(id => {
+  const groups = [last, withViewportScroll, withDroppableScroll];
+  last.all.forEach((id) => {
     const displacement = tryGetVisible(id, groups);
     if (displacement) {
       visible[id] = displacement;
@@ -1120,47 +1155,52 @@ var speculativelyIncrease = (_ref => {
     displaced: {
       all: last.all,
       invisible,
-      visible
-    }
+      visible,
+    },
   };
   return newImpact;
-});
+};
 
-var withViewportDisplacement = ((viewport, point) => add(viewport.scroll.diff.displacement, point));
+var withViewportDisplacement = (viewport, point) =>
+  add(viewport.scroll.diff.displacement, point);
 
-var getClientFromPageBorderBoxCenter = (_ref => {
-  let {
+var getClientFromPageBorderBoxCenter = (_ref) => {
+  let { pageBorderBoxCenter, draggable, viewport } = _ref;
+  const withoutPageScrollChange = withViewportDisplacement(
+    viewport,
     pageBorderBoxCenter,
-    draggable,
-    viewport
-  } = _ref;
-  const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
-  const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);
+  );
+  const offset = subtract(
+    withoutPageScrollChange,
+    draggable.page.borderBox.center,
+  );
   return add(draggable.client.borderBox.center, offset);
-});
+};
 
-var isTotallyVisibleInNewLocation = (_ref => {
+var isTotallyVisibleInNewLocation = (_ref) => {
   let {
     draggable,
     destination,
     newPageBorderBoxCenter,
     viewport,
     withDroppableDisplacement,
-    onlyOnMainAxis = false
+    onlyOnMainAxis = false,
   } = _ref;
-  const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);
+  const changeNeeded = subtract(
+    newPageBorderBoxCenter,
+    draggable.page.borderBox.center,
+  );
   const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);
-
   const args = {
     target: shifted,
     destination,
     withDroppableDisplacement,
-    viewport
+    viewport,
   };
   return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
-});
+};
 
-var moveToNextPlace = (_ref => {
+var moveToNextPlace = (_ref) => {
   let {
     isMovingForward,
     draggable,
@@ -1170,30 +1210,35 @@ var moveToNextPlace = (_ref => {
     viewport,
     previousPageBorderBoxCenter,
     previousClientSelection,
-    afterCritical
+    afterCritical,
   } = _ref;
   if (!destination.isEnabled) {
     return null;
   }
-  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
-  const isInHomeList = isHomeOf(draggable, destination);
-  const impact = moveToNextCombine({
-    isMovingForward,
-    draggable,
-    destination,
-    insideDestination,
-    previousImpact
-  }) || moveToNextIndex({
-    isMovingForward,
-    isInHomeList,
-    draggable,
+  const insideDestination = getDraggablesInsideDroppable(
+    destination.descriptor.id,
     draggables,
-    destination,
-    insideDestination,
-    previousImpact,
-    viewport,
-    afterCritical
-  });
+  );
+  const isInHomeList = isHomeOf(draggable, destination);
+  const impact =
+    moveToNextCombine({
+      isMovingForward,
+      draggable,
+      destination,
+      insideDestination,
+      previousImpact,
+    }) ||
+    moveToNextIndex({
+      isMovingForward,
+      isInHomeList,
+      draggable,
+      draggables,
+      destination,
+      insideDestination,
+      previousImpact,
+      viewport,
+      afterCritical,
+    });
   if (!impact) {
     return null;
   }
@@ -1202,7 +1247,7 @@ var moveToNextPlace = (_ref => {
     draggable,
     droppable: destination,
     draggables,
-    afterCritical
+    afterCritical,
   });
   const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
     draggable,
@@ -1210,18 +1255,18 @@ var moveToNextPlace = (_ref => {
     newPageBorderBoxCenter: pageBorderBoxCenter,
     viewport: viewport.frame,
     withDroppableDisplacement: false,
-    onlyOnMainAxis: true
+    onlyOnMainAxis: true,
   });
   if (isVisibleInNewLocation) {
     const clientSelection = getClientFromPageBorderBoxCenter({
       pageBorderBoxCenter,
       draggable,
-      viewport
+      viewport,
     });
     return {
       clientSelection,
       impact,
-      scrollJumpRequest: null
+      scrollJumpRequest: null,
     };
   }
   const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
@@ -1230,28 +1275,27 @@ var moveToNextPlace = (_ref => {
     viewport,
     destination,
     draggables,
-    maxScrollChange: distance
+    maxScrollChange: distance,
   });
   return {
     clientSelection: previousClientSelection,
     impact: cautious,
-    scrollJumpRequest: distance
+    scrollJumpRequest: distance,
   };
-});
+};
 
-const getKnownActive = droppable => {
+const getKnownActive = (droppable) => {
   const rect = droppable.subject.active;
-  !rect ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot get clipped area from droppable') : invariant(false) : void 0;
+  !rect
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Cannot get clipped area from droppable')
+      : invariant(false)
+    : void 0;
   return rect;
 };
-var getBestCrossAxisDroppable = (_ref => {
-  let {
-    isMovingForward,
-    pageBorderBoxCenter,
-    source,
-    droppables,
-    viewport
-  } = _ref;
+var getBestCrossAxisDroppable = (_ref) => {
+  let { isMovingForward, pageBorderBoxCenter, source, droppables, viewport } =
+    _ref;
   const active = source.subject.active;
   if (!active) {
     return null;
@@ -1259,125 +1303,163 @@ var getBestCrossAxisDroppable = (_ref => {
   const axis = source.axis;
   const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
   const candidates = toDroppableList(droppables)
-  .filter(droppable => droppable !== source)
-  .filter(droppable => droppable.isEnabled)
-  .filter(droppable => Boolean(droppable.subject.active))
-  .filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {
-    const activeOfTarget = getKnownActive(droppable);
-
-    if (isMovingForward) {
-      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
-    }
-    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
-  })
-  .filter(droppable => {
-    const activeOfTarget = getKnownActive(droppable);
-    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
-    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
-  })
-  .sort((a, b) => {
-    const first = getKnownActive(a)[axis.crossAxisStart];
-    const second = getKnownActive(b)[axis.crossAxisStart];
-    if (isMovingForward) {
-      return first - second;
-    }
-    return second - first;
-  })
-  .filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
-
+    .filter((droppable) => droppable !== source)
+    .filter((droppable) => droppable.isEnabled)
+    .filter((droppable) => Boolean(droppable.subject.active))
+    .filter((droppable) =>
+      isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable)),
+    )
+    .filter((droppable) => {
+      const activeOfTarget = getKnownActive(droppable);
+      if (isMovingForward) {
+        return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
+      }
+      return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
+    })
+    .filter((droppable) => {
+      const activeOfTarget = getKnownActive(droppable);
+      const isBetweenDestinationClipped = isWithin(
+        activeOfTarget[axis.start],
+        activeOfTarget[axis.end],
+      );
+      return (
+        isBetweenSourceClipped(activeOfTarget[axis.start]) ||
+        isBetweenSourceClipped(activeOfTarget[axis.end]) ||
+        isBetweenDestinationClipped(active[axis.start]) ||
+        isBetweenDestinationClipped(active[axis.end])
+      );
+    })
+    .sort((a, b) => {
+      const first = getKnownActive(a)[axis.crossAxisStart];
+      const second = getKnownActive(b)[axis.crossAxisStart];
+      if (isMovingForward) {
+        return first - second;
+      }
+      return second - first;
+    })
+    .filter(
+      (droppable, index, array) =>
+        getKnownActive(droppable)[axis.crossAxisStart] ===
+        getKnownActive(array[0])[axis.crossAxisStart],
+    );
   if (!candidates.length) {
     return null;
   }
-
   if (candidates.length === 1) {
     return candidates[0];
   }
-
-  const contains = candidates.filter(droppable => {
-    const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);
+  const contains = candidates.filter((droppable) => {
+    const isWithinDroppable = isWithin(
+      getKnownActive(droppable)[axis.start],
+      getKnownActive(droppable)[axis.end],
+    );
     return isWithinDroppable(pageBorderBoxCenter[axis.line]);
   });
   if (contains.length === 1) {
     return contains[0];
   }
-
   if (contains.length > 1) {
-    return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];
+    return contains.sort(
+      (a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start],
+    )[0];
   }
-
   return candidates.sort((a, b) => {
     const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));
-    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));
-
+    const second = closest$1(
+      pageBorderBoxCenter,
+      getCorners(getKnownActive(b)),
+    );
     if (first !== second) {
       return first - second;
     }
-
     return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
   })[0];
-});
+};
 
 const getCurrentPageBorderBoxCenter = (draggable, afterCritical) => {
   const original = draggable.page.borderBox.center;
-  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
+  return didStartAfterCritical(draggable.descriptor.id, afterCritical)
+    ? subtract(original, afterCritical.displacedBy.point)
+    : original;
 };
 const getCurrentPageBorderBox = (draggable, afterCritical) => {
   const original = draggable.page.borderBox;
-  return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
+  return didStartAfterCritical(draggable.descriptor.id, afterCritical)
+    ? offsetByPosition(original, negate(afterCritical.displacedBy.point))
+    : original;
 };
 
-var getClosestDraggable = (_ref => {
+var getClosestDraggable = (_ref) => {
   let {
     pageBorderBoxCenter,
     viewport,
     destination,
     insideDestination,
-    afterCritical
+    afterCritical,
   } = _ref;
-  const sorted = insideDestination.filter(draggable =>
-  isTotallyVisible({
-    target: getCurrentPageBorderBox(draggable, afterCritical),
-    destination,
-    viewport: viewport.frame,
-    withDroppableDisplacement: true
-  })).sort((a, b) => {
-    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
-    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
-
-    if (distanceToA < distanceToB) {
-      return -1;
-    }
-
-    if (distanceToB < distanceToA) {
-      return 1;
-    }
-
-    return a.descriptor.index - b.descriptor.index;
-  });
+  const sorted = insideDestination
+    .filter((draggable) =>
+      isTotallyVisible({
+        target: getCurrentPageBorderBox(draggable, afterCritical),
+        destination,
+        viewport: viewport.frame,
+        withDroppableDisplacement: true,
+      }),
+    )
+    .sort((a, b) => {
+      const distanceToA = distance(
+        pageBorderBoxCenter,
+        withDroppableDisplacement(
+          destination,
+          getCurrentPageBorderBoxCenter(a, afterCritical),
+        ),
+      );
+      const distanceToB = distance(
+        pageBorderBoxCenter,
+        withDroppableDisplacement(
+          destination,
+          getCurrentPageBorderBoxCenter(b, afterCritical),
+        ),
+      );
+      if (distanceToA < distanceToB) {
+        return -1;
+      }
+      if (distanceToB < distanceToA) {
+        return 1;
+      }
+      return a.descriptor.index - b.descriptor.index;
+    });
   return sorted[0] || null;
-});
+};
 
 var getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {
   const displacement = displaceBy[axis.line];
   return {
     value: displacement,
-    point: patch(axis.line, displacement)
+    point: patch(axis.line, displacement),
   };
 });
 
-const getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables) => {
+const getRequiredGrowthForPlaceholder = (
+  droppable,
+  placeholderSize,
+  draggables,
+) => {
   const axis = droppable.axis;
-
   if (droppable.descriptor.mode === 'virtual') {
     return patch(axis.line, placeholderSize[axis.line]);
   }
-
   const availableSpace = droppable.subject.page.contentBox[axis.size];
-  const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
-  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
+  const insideDroppable = getDraggablesInsideDroppable(
+    droppable.descriptor.id,
+    draggables,
+  );
+  const spaceUsed = insideDroppable.reduce(
+    (sum, dimension) => sum + dimension.client.marginBox[axis.size],
+    0,
+  );
   const requiredSpace = spaceUsed + placeholderSize[axis.line];
   const needsToGrowBy = requiredSpace - availableSpace;
-
   if (needsToGrowBy <= 0) {
     return null;
   }
@@ -1387,79 +1469,113 @@ const withMaxScroll = (frame, max) => ({
   ...frame,
   scroll: {
     ...frame.scroll,
-    max
-  }
+    max,
+  },
 });
 const addPlaceholder = (droppable, draggable, draggables) => {
   const frame = droppable.frame;
-  !!isHomeOf(draggable, droppable) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Should not add placeholder space to home list') : invariant(false) : void 0;
-  !!droppable.subject.withPlaceholder ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot add placeholder size to a subject when it already has one') : invariant(false) : void 0;
-  const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;
-  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);
+  !!isHomeOf(draggable, droppable)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Should not add placeholder space to home list')
+      : invariant(false)
+    : void 0;
+  !!droppable.subject.withPlaceholder
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          'Cannot add placeholder size to a subject when it already has one',
+        )
+      : invariant(false)
+    : void 0;
+  const placeholderSize = getDisplacedBy(
+    droppable.axis,
+    draggable.displaceBy,
+  ).point;
+  const requiredGrowth = getRequiredGrowthForPlaceholder(
+    droppable,
+    placeholderSize,
+    draggables,
+  );
   const added = {
     placeholderSize,
     increasedBy: requiredGrowth,
-    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null
+    oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null,
   };
   if (!frame) {
     const subject = getSubject({
       page: droppable.subject.page,
       withPlaceholder: added,
       axis: droppable.axis,
-      frame: droppable.frame
+      frame: droppable.frame,
     });
     return {
       ...droppable,
-      subject
+      subject,
     };
   }
-  const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
+  const maxScroll = requiredGrowth
+    ? add(frame.scroll.max, requiredGrowth)
+    : frame.scroll.max;
   const newFrame = withMaxScroll(frame, maxScroll);
   const subject = getSubject({
     page: droppable.subject.page,
     withPlaceholder: added,
     axis: droppable.axis,
-    frame: newFrame
+    frame: newFrame,
   });
   return {
     ...droppable,
     subject,
-    frame: newFrame
+    frame: newFrame,
   };
 };
-const removePlaceholder = droppable => {
+const removePlaceholder = (droppable) => {
   const added = droppable.subject.withPlaceholder;
-  !added ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot remove placeholder form subject when there was none') : invariant(false) : void 0;
+  !added
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          'Cannot remove placeholder form subject when there was none',
+        )
+      : invariant(false)
+    : void 0;
   const frame = droppable.frame;
   if (!frame) {
     const subject = getSubject({
       page: droppable.subject.page,
       axis: droppable.axis,
       frame: null,
-      withPlaceholder: null
+      withPlaceholder: null,
     });
     return {
       ...droppable,
-      subject
+      subject,
     };
   }
   const oldMaxScroll = added.oldFrameMaxScroll;
-  !oldMaxScroll ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected droppable with frame to have old max frame scroll when removing placeholder') : invariant(false) : void 0;
+  !oldMaxScroll
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          'Expected droppable with frame to have old max frame scroll when removing placeholder',
+        )
+      : invariant(false)
+    : void 0;
   const newFrame = withMaxScroll(frame, oldMaxScroll);
   const subject = getSubject({
     page: droppable.subject.page,
     axis: droppable.axis,
     frame: newFrame,
-    withPlaceholder: null
+    withPlaceholder: null,
   });
   return {
     ...droppable,
     subject,
-    frame: newFrame
+    frame: newFrame,
   };
 };
 
-var moveToNewDroppable = (_ref => {
+var moveToNewDroppable = (_ref) => {
   let {
     previousPageBorderBoxCenter,
     moveRelativeTo,
@@ -1468,13 +1584,12 @@ var moveToNewDroppable = (_ref => {
     draggables,
     destination,
     viewport,
-    afterCritical
+    afterCritical,
   } = _ref;
   if (!moveRelativeTo) {
     if (insideDestination.length) {
       return null;
     }
-
     const proposed = {
       displaced: emptyGroups,
       displacedBy: noDisplacedBy,
@@ -1482,31 +1597,34 @@ var moveToNewDroppable = (_ref => {
         type: 'REORDER',
         destination: {
           droppableId: destination.descriptor.id,
-          index: 0
-        }
-      }
+          index: 0,
+        },
+      },
     };
     const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
       impact: proposed,
       draggable,
       droppable: destination,
       draggables,
-      afterCritical
+      afterCritical,
     });
-
-    const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);
+    const withPlaceholder = isHomeOf(draggable, destination)
+      ? destination
+      : addPlaceholder(destination, draggable, draggables);
     const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
       draggable,
       destination: withPlaceholder,
       newPageBorderBoxCenter: proposedPageBorderBoxCenter,
       viewport: viewport.frame,
       withDroppableDisplacement: false,
-      onlyOnMainAxis: true
+      onlyOnMainAxis: true,
     });
     return isVisibleInNewLocation ? proposed : null;
   }
   const isGoingBeforeTarget = Boolean(
-  previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
+    previousPageBorderBoxCenter[destination.axis.line] <=
+      moveRelativeTo.page.borderBox.center[destination.axis.line],
+  );
   const proposedIndex = (() => {
     const relativeTo = moveRelativeTo.descriptor.index;
     if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {
@@ -1525,11 +1643,11 @@ var moveToNewDroppable = (_ref => {
     viewport,
     displacedBy,
     last: emptyGroups,
-    index: proposedIndex
+    index: proposedIndex,
   });
-});
+};
 
-var moveCrossAxis = (_ref => {
+var moveCrossAxis = (_ref) => {
   let {
     isMovingForward,
     previousPageBorderBoxCenter,
@@ -1538,27 +1656,28 @@ var moveCrossAxis = (_ref => {
     draggables,
     droppables,
     viewport,
-    afterCritical
+    afterCritical,
   } = _ref;
-
   const destination = getBestCrossAxisDroppable({
     isMovingForward,
     pageBorderBoxCenter: previousPageBorderBoxCenter,
     source: isOver,
     droppables,
-    viewport
+    viewport,
   });
-
   if (!destination) {
     return null;
   }
-  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
+  const insideDestination = getDraggablesInsideDroppable(
+    destination.descriptor.id,
+    draggables,
+  );
   const moveRelativeTo = getClosestDraggable({
     pageBorderBoxCenter: previousPageBorderBoxCenter,
     viewport,
     destination,
     insideDestination,
-    afterCritical
+    afterCritical,
   });
   const impact = moveToNewDroppable({
     previousPageBorderBoxCenter,
@@ -1568,7 +1687,7 @@ var moveCrossAxis = (_ref => {
     moveRelativeTo,
     insideDestination,
     viewport,
-    afterCritical
+    afterCritical,
   });
   if (!impact) {
     return null;
@@ -1578,21 +1697,21 @@ var moveCrossAxis = (_ref => {
     draggable,
     droppable: destination,
     draggables,
-    afterCritical
+    afterCritical,
   });
   const clientSelection = getClientFromPageBorderBoxCenter({
     pageBorderBoxCenter,
     draggable,
-    viewport
+    viewport,
   });
   return {
     clientSelection,
     impact,
-    scrollJumpRequest: null
+    scrollJumpRequest: null,
   };
-});
+};
 
-var whatIsDraggedOver = (impact => {
+var whatIsDraggedOver = (impact) => {
   const at = impact.at;
   if (!at) {
     return null;
@@ -1601,55 +1720,57 @@ var whatIsDraggedOver = (impact => {
     return at.destination.droppableId;
   }
   return at.combine.droppableId;
-});
+};
 
 const getDroppableOver$1 = (impact, droppables) => {
   const id = whatIsDraggedOver(impact);
   return id ? droppables[id] : null;
 };
-var moveInDirection = (_ref => {
-  let {
-    state,
-    type
-  } = _ref;
-  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);
+var moveInDirection = (_ref) => {
+  let { state, type } = _ref;
+  const isActuallyOver = getDroppableOver$1(
+    state.impact,
+    state.dimensions.droppables,
+  );
   const isMainAxisMovementAllowed = Boolean(isActuallyOver);
   const home = state.dimensions.droppables[state.critical.droppable.id];
   const isOver = isActuallyOver || home;
   const direction = isOver.axis.direction;
-  const isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');
-
+  const isMovingOnMainAxis =
+    (direction === 'vertical' &&
+      (type === 'MOVE_UP' || type === 'MOVE_DOWN')) ||
+    (direction === 'horizontal' &&
+      (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT'));
   if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
     return null;
   }
   const isMovingForward = type === 'MOVE_DOWN' || type === 'MOVE_RIGHT';
   const draggable = state.dimensions.draggables[state.critical.draggable.id];
   const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
-  const {
-    draggables,
-    droppables
-  } = state.dimensions;
-  return isMovingOnMainAxis ? moveToNextPlace({
-    isMovingForward,
-    previousPageBorderBoxCenter,
-    draggable,
-    destination: isOver,
-    draggables,
-    viewport: state.viewport,
-    previousClientSelection: state.current.client.selection,
-    previousImpact: state.impact,
-    afterCritical: state.afterCritical
-  }) : moveCrossAxis({
-    isMovingForward,
-    previousPageBorderBoxCenter,
-    draggable,
-    isOver,
-    draggables,
-    droppables,
-    viewport: state.viewport,
-    afterCritical: state.afterCritical
-  });
-});
+  const { draggables, droppables } = state.dimensions;
+  return isMovingOnMainAxis
+    ? moveToNextPlace({
+        isMovingForward,
+        previousPageBorderBoxCenter,
+        draggable,
+        destination: isOver,
+        draggables,
+        viewport: state.viewport,
+        previousClientSelection: state.current.client.selection,
+        previousImpact: state.impact,
+        afterCritical: state.afterCritical,
+      })
+    : moveCrossAxis({
+        isMovingForward,
+        previousPageBorderBoxCenter,
+        draggable,
+        isOver,
+        draggables,
+        droppables,
+        viewport: state.viewport,
+        afterCritical: state.afterCritical,
+      });
+};
 
 function isMovementAllowed(state) {
   return state.phase === 'DRAGGING' || state.phase === 'COLLECTING';
@@ -1664,66 +1785,61 @@ function isPositionInFrame(frame) {
 }
 
 function getHasOverlap(first, second) {
-  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
+  return (
+    first.left < second.right &&
+    first.right > second.left &&
+    first.top < second.bottom &&
+    first.bottom > second.top
+  );
 }
 function getFurthestAway(_ref) {
-  let {
-    pageBorderBox,
-    draggable,
-    candidates
-  } = _ref;
-
+  let { pageBorderBox, draggable, candidates } = _ref;
   const startCenter = draggable.page.borderBox.center;
-  const sorted = candidates.map(candidate => {
-    const axis = candidate.axis;
-    const target = patch(candidate.axis.line,
-    pageBorderBox.center[axis.line],
-    candidate.page.borderBox.center[axis.crossAxisLine]);
-    return {
-      id: candidate.descriptor.id,
-      distance: distance(startCenter, target)
-    };
-  })
-  .sort((a, b) => b.distance - a.distance);
-
+  const sorted = candidates
+    .map((candidate) => {
+      const axis = candidate.axis;
+      const target = patch(
+        candidate.axis.line,
+        pageBorderBox.center[axis.line],
+        candidate.page.borderBox.center[axis.crossAxisLine],
+      );
+      return {
+        id: candidate.descriptor.id,
+        distance: distance(startCenter, target),
+      };
+    })
+    .sort((a, b) => b.distance - a.distance);
   return sorted[0] ? sorted[0].id : null;
 }
 function getDroppableOver(_ref2) {
-  let {
-    pageBorderBox,
-    draggable,
-    droppables
-  } = _ref2;
-  const candidates = toDroppableList(droppables).filter(item => {
+  let { pageBorderBox, draggable, droppables } = _ref2;
+  const candidates = toDroppableList(droppables).filter((item) => {
     if (!item.isEnabled) {
       return false;
     }
-
     const active = item.subject.active;
     if (!active) {
       return false;
     }
-
     if (!getHasOverlap(pageBorderBox, active)) {
       return false;
     }
-
     if (isPositionInFrame(active)(pageBorderBox.center)) {
       return true;
     }
-
     const axis = item.axis;
     const childCenter = active.center[axis.crossAxisLine];
     const crossAxisStart = pageBorderBox[axis.crossAxisStart];
     const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
-    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
+    const isContained = isWithin(
+      active[axis.crossAxisStart],
+      active[axis.crossAxisEnd],
+    );
     const isStartContained = isContained(crossAxisStart);
     const isEndContained = isContained(crossAxisEnd);
-
     if (!isStartContained && !isEndContained) {
       return true;
     }
-
     if (isStartContained) {
       return crossAxisStart < childCenter;
     }
@@ -1732,42 +1848,34 @@ function getDroppableOver(_ref2) {
   if (!candidates.length) {
     return null;
   }
-
   if (candidates.length === 1) {
     return candidates[0].descriptor.id;
   }
-
   return getFurthestAway({
     pageBorderBox,
     draggable,
-    candidates
+    candidates,
   });
 }
 
-const offsetRectByPosition = (rect, point) => getRect(offsetByPosition(rect, point));
+const offsetRectByPosition = (rect, point) =>
+  getRect(offsetByPosition(rect, point));
 
-var withDroppableScroll = ((droppable, area) => {
+var withDroppableScroll = (droppable, area) => {
   const frame = droppable.frame;
   if (!frame) {
     return area;
   }
   return offsetRectByPosition(area, frame.scroll.diff.value);
-});
+};
 
 function getIsDisplaced(_ref) {
-  let {
-    displaced,
-    id
-  } = _ref;
+  let { displaced, id } = _ref;
   return Boolean(displaced.visible[id] || displaced.invisible[id]);
 }
 
 function atIndex(_ref) {
-  let {
-    draggable,
-    closest,
-    inHomeList
-  } = _ref;
+  let { draggable, closest, inHomeList } = _ref;
   if (!closest) {
     return null;
   }
@@ -1779,7 +1887,7 @@ function atIndex(_ref) {
   }
   return closest.descriptor.index;
 }
-var getReorderImpact = (_ref2 => {
+var getReorderImpact = (_ref2) => {
   let {
     pageBorderBoxWithDroppableScroll: targetRect,
     draggable,
@@ -1787,7 +1895,7 @@ var getReorderImpact = (_ref2 => {
     insideDestination,
     last,
     viewport,
-    afterCritical
+    afterCritical,
   } = _ref2;
   const axis = destination.axis;
   const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);
@@ -1795,35 +1903,31 @@ var getReorderImpact = (_ref2 => {
   const targetStart = targetRect[axis.start];
   const targetEnd = targetRect[axis.end];
   const withoutDragging = removeDraggableFromList(draggable, insideDestination);
-  const closest = withoutDragging.find(child => {
-    const id = child.descriptor.id;
-    const childCenter = child.page.borderBox.center[axis.line];
-    const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
-    const isDisplaced = getIsDisplaced({
-      displaced: last,
-      id
-    });
-
-    if (didStartAfterCritical$1) {
+  const closest =
+    withoutDragging.find((child) => {
+      const id = child.descriptor.id;
+      const childCenter = child.page.borderBox.center[axis.line];
+      const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
+      const isDisplaced = getIsDisplaced({
+        displaced: last,
+        id,
+      });
+      if (didStartAfterCritical$1) {
+        if (isDisplaced) {
+          return targetEnd <= childCenter;
+        }
+        return targetStart < childCenter - displacement;
+      }
       if (isDisplaced) {
-        return targetEnd <= childCenter;
+        return targetEnd <= childCenter + displacement;
       }
-
-      return targetStart < childCenter - displacement;
-    }
-
-    if (isDisplaced) {
-      return targetEnd <= childCenter + displacement;
-    }
-
-    return targetStart < childCenter;
-  }) || null;
+      return targetStart < childCenter;
+    }) || null;
   const newIndex = atIndex({
     draggable,
     closest,
-    inHomeList: isHomeOf(draggable, destination)
+    inHomeList: isHomeOf(draggable, destination),
   });
-
   return calculateReorderImpact({
     draggable,
     insideDestination,
@@ -1831,19 +1935,19 @@ var getReorderImpact = (_ref2 => {
     viewport,
     last,
     displacedBy,
-    index: newIndex
+    index: newIndex,
   });
-});
+};
 
 const combineThresholdDivisor = 4;
-var getCombineImpact = (_ref => {
+var getCombineImpact = (_ref) => {
   let {
     draggable,
     pageBorderBoxWithDroppableScroll: targetRect,
     previousImpact,
     destination,
     insideDestination,
-    afterCritical
+    afterCritical,
   } = _ref;
   if (!destination.isCombineEnabled) {
     return null;
@@ -1854,7 +1958,7 @@ var getCombineImpact = (_ref => {
   const targetStart = targetRect[axis.start];
   const targetEnd = targetRect[axis.end];
   const withoutDragging = removeDraggableFromList(draggable, insideDestination);
-  const combineWith = withoutDragging.find(child => {
+  const combineWith = withoutDragging.find((child) => {
     const id = child.descriptor.id;
     const childRect = child.page.borderBox;
     const childSize = childRect[axis.size];
@@ -1862,22 +1966,30 @@ var getCombineImpact = (_ref => {
     const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
     const isDisplaced = getIsDisplaced({
       displaced: previousImpact.displaced,
-      id
+      id,
     });
-
     if (didStartAfterCritical$1) {
       if (isDisplaced) {
-        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
+        return (
+          targetEnd > childRect[axis.start] + threshold &&
+          targetEnd < childRect[axis.end] - threshold
+        );
       }
-
-      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
+      return (
+        targetStart > childRect[axis.start] - displacement + threshold &&
+        targetStart < childRect[axis.end] - displacement - threshold
+      );
     }
-
     if (isDisplaced) {
-      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
-    }
-
-    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
+      return (
+        targetEnd > childRect[axis.start] + displacement + threshold &&
+        targetEnd < childRect[axis.end] + displacement - threshold
+      );
+    }
+    return (
+      targetStart > childRect[axis.start] + threshold &&
+      targetStart < childRect[axis.end] - threshold
+    );
   });
   if (!combineWith) {
     return null;
@@ -1889,14 +2001,14 @@ var getCombineImpact = (_ref => {
       type: 'COMBINE',
       combine: {
         draggableId: combineWith.descriptor.id,
-        droppableId: destination.descriptor.id
-      }
-    }
+        droppableId: destination.descriptor.id,
+      },
+    },
   };
   return impact;
-});
+};
 
-var getDragImpact = (_ref => {
+var getDragImpact = (_ref) => {
   let {
     pageOffset,
     draggable,
@@ -1904,180 +2016,169 @@ var getDragImpact = (_ref => {
     droppables,
     previousImpact,
     viewport,
-    afterCritical
+    afterCritical,
   } = _ref;
-  const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);
+  const pageBorderBox = offsetRectByPosition(
+    draggable.page.borderBox,
+    pageOffset,
+  );
   const destinationId = getDroppableOver({
     pageBorderBox,
     draggable,
-    droppables
+    droppables,
   });
-
   if (!destinationId) {
     return noImpact$1;
   }
   const destination = droppables[destinationId];
-  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
-
-  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
-
-  return getCombineImpact({
-    pageBorderBoxWithDroppableScroll,
-    draggable,
-    previousImpact,
-    destination,
-    insideDestination,
-    afterCritical
-  }) || getReorderImpact({
-    pageBorderBoxWithDroppableScroll,
-    draggable,
+  const insideDestination = getDraggablesInsideDroppable(
+    destination.descriptor.id,
+    draggables,
+  );
+  const pageBorderBoxWithDroppableScroll = withDroppableScroll(
     destination,
-    insideDestination,
-    last: previousImpact.displaced,
-    viewport,
-    afterCritical
-  });
-});
+    pageBorderBox,
+  );
+  return (
+    getCombineImpact({
+      pageBorderBoxWithDroppableScroll,
+      draggable,
+      previousImpact,
+      destination,
+      insideDestination,
+      afterCritical,
+    }) ||
+    getReorderImpact({
+      pageBorderBoxWithDroppableScroll,
+      draggable,
+      destination,
+      insideDestination,
+      last: previousImpact.displaced,
+      viewport,
+      afterCritical,
+    })
+  );
+};
 
-var patchDroppableMap = ((droppables, updated) => ({
+var patchDroppableMap = (droppables, updated) => ({
   ...droppables,
-  [updated.descriptor.id]: updated
-}));
+  [updated.descriptor.id]: updated,
+});
 
-const clearUnusedPlaceholder = _ref => {
-  let {
-    previousImpact,
-    impact,
-    droppables
-  } = _ref;
+const clearUnusedPlaceholder = (_ref) => {
+  let { previousImpact, impact, droppables } = _ref;
   const last = whatIsDraggedOver(previousImpact);
   const now = whatIsDraggedOver(impact);
   if (!last) {
     return droppables;
   }
-
   if (last === now) {
     return droppables;
   }
   const lastDroppable = droppables[last];
-
   if (!lastDroppable.subject.withPlaceholder) {
     return droppables;
   }
   const updated = removePlaceholder(lastDroppable);
   return patchDroppableMap(droppables, updated);
 };
-var recomputePlaceholders = (_ref2 => {
-  let {
-    draggable,
-    draggables,
-    droppables,
-    previousImpact,
-    impact
-  } = _ref2;
+var recomputePlaceholders = (_ref2) => {
+  let { draggable, draggables, droppables, previousImpact, impact } = _ref2;
   const cleaned = clearUnusedPlaceholder({
     previousImpact,
     impact,
-    droppables
+    droppables,
   });
   const isOver = whatIsDraggedOver(impact);
   if (!isOver) {
     return cleaned;
   }
   const droppable = droppables[isOver];
-
   if (isHomeOf(draggable, droppable)) {
     return cleaned;
   }
-
   if (droppable.subject.withPlaceholder) {
     return cleaned;
   }
-
   const patched = addPlaceholder(droppable, draggable, draggables);
   return patchDroppableMap(cleaned, patched);
-});
+};
 
-var update = (_ref => {
+var update = (_ref) => {
   let {
     state,
     clientSelection: forcedClientSelection,
     dimensions: forcedDimensions,
     viewport: forcedViewport,
     impact: forcedImpact,
-    scrollJumpRequest
+    scrollJumpRequest,
   } = _ref;
-
   const viewport = forcedViewport || state.viewport;
   const dimensions = forcedDimensions || state.dimensions;
-  const clientSelection = forcedClientSelection || state.current.client.selection;
+  const clientSelection =
+    forcedClientSelection || state.current.client.selection;
   const offset = subtract(clientSelection, state.initial.client.selection);
   const client = {
     offset,
     selection: clientSelection,
-    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)
+    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset),
   };
   const page = {
     selection: add(client.selection, viewport.scroll.current),
     borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
-    offset: add(client.offset, viewport.scroll.diff.value)
+    offset: add(client.offset, viewport.scroll.diff.value),
   };
   const current = {
     client,
-    page
+    page,
   };
-
   if (state.phase === 'COLLECTING') {
     return {
       ...state,
       dimensions,
       viewport,
-      current
+      current,
     };
   }
   const draggable = dimensions.draggables[state.critical.draggable.id];
-  const newImpact = forcedImpact || getDragImpact({
-    pageOffset: page.offset,
-    draggable,
-    draggables: dimensions.draggables,
-    droppables: dimensions.droppables,
-    previousImpact: state.impact,
-    viewport,
-    afterCritical: state.afterCritical
-  });
+  const newImpact =
+    forcedImpact ||
+    getDragImpact({
+      pageOffset: page.offset,
+      draggable,
+      draggables: dimensions.draggables,
+      droppables: dimensions.droppables,
+      previousImpact: state.impact,
+      viewport,
+      afterCritical: state.afterCritical,
+    });
   const withUpdatedPlaceholders = recomputePlaceholders({
     draggable,
     impact: newImpact,
     previousImpact: state.impact,
     draggables: dimensions.draggables,
-    droppables: dimensions.droppables
+    droppables: dimensions.droppables,
   });
   const result = {
     ...state,
     current,
     dimensions: {
       draggables: dimensions.draggables,
-      droppables: withUpdatedPlaceholders
+      droppables: withUpdatedPlaceholders,
     },
     impact: newImpact,
     viewport,
     scrollJumpRequest: scrollJumpRequest || null,
-    forceShouldAnimate: scrollJumpRequest ? false : null
+    forceShouldAnimate: scrollJumpRequest ? false : null,
   };
   return result;
-});
+};
 
 function getDraggables(ids, draggables) {
-  return ids.map(id => draggables[id]);
+  return ids.map((id) => draggables[id]);
 }
-var recompute = (_ref => {
-  let {
-    impact,
-    viewport,
-    draggables,
-    destination,
-    forceShouldAnimate
-  } = _ref;
+var recompute = (_ref) => {
+  let { impact, viewport, draggables, destination, forceShouldAnimate } = _ref;
   const last = impact.displaced;
   const afterDragging = getDraggables(last.all, draggables);
   const displaced = getDisplacementGroups({
@@ -2086,60 +2187,55 @@ var recompute = (_ref => {
     displacedBy: impact.displacedBy,
     viewport: viewport.frame,
     forceShouldAnimate,
-    last
+    last,
   });
   return {
     ...impact,
-    displaced
+    displaced,
   };
-});
+};
 
-var getClientBorderBoxCenter = (_ref => {
-  let {
-    impact,
-    draggable,
-    droppable,
-    draggables,
-    viewport,
-    afterCritical
-  } = _ref;
+var getClientBorderBoxCenter = (_ref) => {
+  let { impact, draggable, droppable, draggables, viewport, afterCritical } =
+    _ref;
   const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
     impact,
     draggable,
     draggables,
     droppable,
-    afterCritical
+    afterCritical,
   });
   return getClientFromPageBorderBoxCenter({
     pageBorderBoxCenter,
     draggable,
-    viewport
+    viewport,
   });
-});
+};
 
-var refreshSnap = (_ref => {
-  let {
-    state,
-    dimensions: forcedDimensions,
-    viewport: forcedViewport
-  } = _ref;
-  !(state.movementMode === 'SNAP') ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
+var refreshSnap = (_ref) => {
+  let { state, dimensions: forcedDimensions, viewport: forcedViewport } = _ref;
+  !(state.movementMode === 'SNAP')
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false)
+      : invariant(false)
+    : void 0;
   const needsVisibilityCheck = state.impact;
   const viewport = forcedViewport || state.viewport;
   const dimensions = forcedDimensions || state.dimensions;
-  const {
-    draggables,
-    droppables
-  } = dimensions;
+  const { draggables, droppables } = dimensions;
   const draggable = draggables[state.critical.draggable.id];
   const isOver = whatIsDraggedOver(needsVisibilityCheck);
-  !isOver ? process.env.NODE_ENV !== "production" ? invariant(false, 'Must be over a destination in SNAP movement mode') : invariant(false) : void 0;
+  !isOver
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Must be over a destination in SNAP movement mode')
+      : invariant(false)
+    : void 0;
   const destination = droppables[isOver];
   const impact = recompute({
     impact: needsVisibilityCheck,
     viewport,
     destination,
-    draggables
+    draggables,
   });
   const clientSelection = getClientBorderBoxCenter({
     impact,
@@ -2147,34 +2243,35 @@ var refreshSnap = (_ref => {
     droppable: destination,
     draggables,
     viewport,
-    afterCritical: state.afterCritical
+    afterCritical: state.afterCritical,
   });
   return update({
     impact,
     clientSelection,
     state,
     dimensions,
-    viewport
+    viewport,
   });
-});
+};
 
-var getHomeLocation = (descriptor => ({
+var getHomeLocation = (descriptor) => ({
   index: descriptor.index,
-  droppableId: descriptor.droppableId
-}));
+  droppableId: descriptor.droppableId,
+});
 
-var getLiftEffect = (_ref => {
-  let {
-    draggable,
-    home,
-    draggables,
-    viewport
-  } = _ref;
+var getLiftEffect = (_ref) => {
+  let { draggable, home, draggables, viewport } = _ref;
   const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);
-  const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);
-
+  const insideHome = getDraggablesInsideDroppable(
+    home.descriptor.id,
+    draggables,
+  );
   const rawIndex = insideHome.indexOf(draggable);
-  !(rawIndex !== -1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected draggable to be inside home list') : invariant(false) : void 0;
+  !(rawIndex !== -1)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Expected draggable to be inside home list')
+      : invariant(false)
+    : void 0;
   const afterDragging = insideHome.slice(rawIndex + 1);
   const effected = afterDragging.reduce((previous, item) => {
     previous[item.descriptor.id] = true;
@@ -2183,7 +2280,7 @@ var getLiftEffect = (_ref => {
   const afterCritical = {
     inVirtualList: home.descriptor.mode === 'virtual',
     displacedBy,
-    effected
+    effected,
   };
   const displaced = getDisplacementGroups({
     afterDragging,
@@ -2191,35 +2288,35 @@ var getLiftEffect = (_ref => {
     displacedBy,
     last: null,
     viewport: viewport.frame,
-    forceShouldAnimate: false
+    forceShouldAnimate: false,
   });
   const impact = {
     displaced,
     displacedBy,
     at: {
       type: 'REORDER',
-      destination: getHomeLocation(draggable.descriptor)
-    }
+      destination: getHomeLocation(draggable.descriptor),
+    },
   };
   return {
     impact,
-    afterCritical
+    afterCritical,
   };
-});
+};
 
-var patchDimensionMap = ((dimensions, updated) => ({
+var patchDimensionMap = (dimensions, updated) => ({
   draggables: dimensions.draggables,
-  droppables: patchDroppableMap(dimensions.droppables, updated)
-}));
+  droppables: patchDroppableMap(dimensions.droppables, updated),
+});
 
-const start = key => {
+const start = (key) => {
   if (process.env.NODE_ENV !== 'production') {
     {
       return;
     }
   }
 };
-const finish = key => {
+const finish = (key) => {
   if (process.env.NODE_ENV !== 'production') {
     {
       return;
@@ -2227,42 +2324,36 @@ const finish = key => {
   }
 };
 
-var offsetDraggable = (_ref => {
-  let {
-    draggable,
-    offset: offset$1,
-    initialWindowScroll
-  } = _ref;
+var offsetDraggable = (_ref) => {
+  let { draggable, offset: offset$1, initialWindowScroll } = _ref;
   const client = offset(draggable.client, offset$1);
   const page = withScroll(client, initialWindowScroll);
   const moved = {
     ...draggable,
     placeholder: {
       ...draggable.placeholder,
-      client
+      client,
     },
     client,
-    page
+    page,
   };
   return moved;
-});
+};
 
-var getFrame = (droppable => {
+var getFrame = (droppable) => {
   const frame = droppable.frame;
-  !frame ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected Droppable to have a frame') : invariant(false) : void 0;
+  !frame
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Expected Droppable to have a frame')
+      : invariant(false)
+    : void 0;
   return frame;
-});
-
-var adjustAdditionsForScrollChanges = (_ref => {
-  let {
-    additions,
-    updatedDroppables,
-    viewport
-  } = _ref;
+};
 
+var adjustAdditionsForScrollChanges = (_ref) => {
+  let { additions, updatedDroppables, viewport } = _ref;
   const windowScrollChange = viewport.scroll.diff.value;
-
-  return additions.map(draggable => {
+  return additions.map((draggable) => {
     const droppableId = draggable.descriptor.droppableId;
     const modified = updatedDroppables[droppableId];
     const frame = getFrame(modified);
@@ -2271,61 +2362,55 @@ var adjustAdditionsForScrollChanges = (_ref => {
     const moved = offsetDraggable({
       draggable,
       offset: totalChange,
-      initialWindowScroll: viewport.scroll.initial
+      initialWindowScroll: viewport.scroll.initial,
     });
     return moved;
   });
-});
+};
 
 const timingsKey = 'Processing dynamic changes';
-var publishWhileDraggingInVirtual = (_ref => {
-  let {
-    state,
-    published
-  } = _ref;
+var publishWhileDraggingInVirtual = (_ref) => {
+  let { state, published } = _ref;
   start(timingsKey);
-
-  const withScrollChange = published.modified.map(update => {
+  const withScrollChange = published.modified.map((update) => {
     const existing = state.dimensions.droppables[update.droppableId];
     const scrolled = scrollDroppable(existing, update.scroll);
     return scrolled;
   });
   const droppables = {
     ...state.dimensions.droppables,
-    ...toDroppableMap(withScrollChange)
+    ...toDroppableMap(withScrollChange),
   };
-  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
-    additions: published.additions,
-    updatedDroppables: droppables,
-    viewport: state.viewport
-  }));
+  const updatedAdditions = toDraggableMap(
+    adjustAdditionsForScrollChanges({
+      additions: published.additions,
+      updatedDroppables: droppables,
+      viewport: state.viewport,
+    }),
+  );
   const draggables = {
     ...state.dimensions.draggables,
-    ...updatedAdditions
+    ...updatedAdditions,
   };
-
-  published.removals.forEach(id => {
+  published.removals.forEach((id) => {
     delete draggables[id];
   });
   const dimensions = {
     droppables,
-    draggables
+    draggables,
   };
   const wasOverId = whatIsDraggedOver(state.impact);
   const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
   const draggable = dimensions.draggables[state.critical.draggable.id];
   const home = dimensions.droppables[state.critical.droppable.id];
-  const {
-    impact: onLiftImpact,
-    afterCritical
-  } = getLiftEffect({
+  const { impact: onLiftImpact, afterCritical } = getLiftEffect({
     draggable,
     home,
     draggables,
-    viewport: state.viewport
+    viewport: state.viewport,
   });
-  const previousImpact = wasOver && wasOver.isCombineEnabled ?
-  state.impact : onLiftImpact;
+  const previousImpact =
+    wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
   const impact = getDragImpact({
     pageOffset: state.current.page.offset,
     draggable: dimensions.draggables[state.critical.draggable.id],
@@ -2333,7 +2418,7 @@ var publishWhileDraggingInVirtual = (_ref => {
     droppables: dimensions.droppables,
     previousImpact,
     viewport: state.viewport,
-    afterCritical
+    afterCritical,
   });
   finish(timingsKey);
   const draggingState = {
@@ -2343,41 +2428,39 @@ var publishWhileDraggingInVirtual = (_ref => {
     onLiftImpact,
     dimensions,
     afterCritical,
-    forceShouldAnimate: false
+    forceShouldAnimate: false,
   };
   if (state.phase === 'COLLECTING') {
     return draggingState;
   }
-
   const dropPending = {
     ...draggingState,
     phase: 'DROP_PENDING',
     reason: state.reason,
-    isWaiting: false
+    isWaiting: false,
   };
   return dropPending;
-});
+};
 
-const isSnapping = state => state.movementMode === 'SNAP';
+const isSnapping = (state) => state.movementMode === 'SNAP';
 const postDroppableChange = (state, updated, isEnabledChanging) => {
   const dimensions = patchDimensionMap(state.dimensions, updated);
-
   if (!isSnapping(state) || isEnabledChanging) {
     return update({
       state,
-      dimensions
+      dimensions,
     });
   }
   return refreshSnap({
     state,
-    dimensions
+    dimensions,
   });
 };
 function removeScrollJumpRequest(state) {
   if (state.isDragging && state.movementMode === 'SNAP') {
     return {
       ...state,
-      scrollJumpRequest: null
+      scrollJumpRequest: null,
     };
   }
   return state;
@@ -2385,53 +2468,49 @@ function removeScrollJumpRequest(state) {
 const idle$2 = {
   phase: 'IDLE',
   completed: null,
-  shouldFlush: false
+  shouldFlush: false,
 };
-
-var reducer = (function (state, action) {
+var reducer = function (state, action) {
   if (state === void 0) {
     state = idle$2;
   }
   if (action.type === 'FLUSH') {
     return {
       ...idle$2,
-      shouldFlush: true
+      shouldFlush: true,
     };
   }
   if (action.type === 'INITIAL_PUBLISH') {
-    !(state.phase === 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase') : invariant(false) : void 0;
-    const {
-      critical,
-      clientSelection,
-      viewport,
-      dimensions,
-      movementMode
-    } = action.payload;
+    !(state.phase === 'IDLE')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'INITIAL_PUBLISH must come after a IDLE phase')
+        : invariant(false)
+      : void 0;
+    const { critical, clientSelection, viewport, dimensions, movementMode } =
+      action.payload;
     const draggable = dimensions.draggables[critical.draggable.id];
     const home = dimensions.droppables[critical.droppable.id];
     const client = {
       selection: clientSelection,
       borderBoxCenter: draggable.client.borderBox.center,
-      offset: origin
+      offset: origin,
     };
     const initial = {
       client,
       page: {
         selection: add(client.selection, viewport.scroll.initial),
         borderBoxCenter: add(client.selection, viewport.scroll.initial),
-        offset: add(client.selection, viewport.scroll.diff.value)
-      }
+        offset: add(client.selection, viewport.scroll.diff.value),
+      },
     };
-
-    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(item => !item.isFixedOnPage);
-    const {
-      impact,
-      afterCritical
-    } = getLiftEffect({
+    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(
+      (item) => !item.isFixedOnPage,
+    );
+    const { impact, afterCritical } = getLiftEffect({
       draggable,
       home,
       draggables: dimensions.draggables,
-      viewport
+      viewport,
     });
     const result = {
       phase: 'DRAGGING',
@@ -2447,7 +2526,7 @@ var reducer = (function (state, action) {
       onLiftImpact: impact,
       viewport,
       scrollJumpRequest: null,
-      forceShouldAnimate: null
+      forceShouldAnimate: null,
     };
     return result;
   }
@@ -2455,53 +2534,70 @@ var reducer = (function (state, action) {
     if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
       return state;
     }
-    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Collection cannot start from phase ${state.phase}`) : invariant(false) : void 0;
+    !(state.phase === 'DRAGGING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Collection cannot start from phase ${state.phase}`)
+        : invariant(false)
+      : void 0;
     const result = {
       ...state,
-      phase: 'COLLECTING'
+      phase: 'COLLECTING',
     };
     return result;
   }
   if (action.type === 'PUBLISH_WHILE_DRAGGING') {
-    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : invariant(false) : void 0;
+    !(state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Unexpected ${action.type} received in phase ${state.phase}`,
+          )
+        : invariant(false)
+      : void 0;
     return publishWhileDraggingInVirtual({
       state,
-      published: action.payload
+      published: action.payload,
     });
   }
   if (action.type === 'MOVE') {
     if (state.phase === 'DROP_PENDING') {
       return state;
     }
-    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : invariant(false) : void 0;
-    const {
-      client: clientSelection
-    } = action.payload;
-
+    !isMovementAllowed(state)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `${action.type} not permitted in phase ${state.phase}`,
+          )
+        : invariant(false)
+      : void 0;
+    const { client: clientSelection } = action.payload;
     if (isEqual$1(clientSelection, state.current.client.selection)) {
       return state;
     }
     return update({
       state,
       clientSelection,
-      impact: isSnapping(state) ? state.impact : null
+      impact: isSnapping(state) ? state.impact : null,
     });
   }
   if (action.type === 'UPDATE_DROPPABLE_SCROLL') {
     if (state.phase === 'DROP_PENDING') {
       return removeScrollJumpRequest(state);
     }
-
     if (state.phase === 'COLLECTING') {
       return removeScrollJumpRequest(state);
     }
-    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : invariant(false) : void 0;
-    const {
-      id,
-      newScroll
-    } = action.payload;
+    !isMovementAllowed(state)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `${action.type} not permitted in phase ${state.phase}`,
+          )
+        : invariant(false)
+      : void 0;
+    const { id, newScroll } = action.payload;
     const target = state.dimensions.droppables[id];
-
     if (!target) {
       return state;
     }
@@ -2512,18 +2608,36 @@ var reducer = (function (state, action) {
     if (state.phase === 'DROP_PENDING') {
       return state;
     }
-    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant(false) : void 0;
-    const {
-      id,
-      isEnabled
-    } = action.payload;
+    !isMovementAllowed(state)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Attempting to move in an unsupported phase ${state.phase}`,
+          )
+        : invariant(false)
+      : void 0;
+    const { id, isEnabled } = action.payload;
     const target = state.dimensions.droppables[id];
-    !target ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : invariant(false) : void 0;
-    !(target.isEnabled !== isEnabled) ? process.env.NODE_ENV !== "production" ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}
-      but it is already ${String(target.isEnabled)}`) : invariant(false) : void 0;
+    !target
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Cannot find Droppable[id: ${id}] to toggle its enabled state`,
+          )
+        : invariant(false)
+      : void 0;
+    !(target.isEnabled !== isEnabled)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Trying to set droppable isEnabled to ${String(isEnabled)}
+      but it is already ${String(target.isEnabled)}`,
+          )
+        : invariant(false)
+      : void 0;
     const updated = {
       ...target,
-      isEnabled
+      isEnabled,
     };
     return postDroppableChange(state, updated, true);
   }
@@ -2531,18 +2645,38 @@ var reducer = (function (state, action) {
     if (state.phase === 'DROP_PENDING') {
       return state;
     }
-    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant(false) : void 0;
-    const {
-      id,
-      isCombineEnabled
-    } = action.payload;
+    !isMovementAllowed(state)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Attempting to move in an unsupported phase ${state.phase}`,
+          )
+        : invariant(false)
+      : void 0;
+    const { id, isCombineEnabled } = action.payload;
     const target = state.dimensions.droppables[id];
-    !target ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : invariant(false) : void 0;
-    !(target.isCombineEnabled !== isCombineEnabled) ? process.env.NODE_ENV !== "production" ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}
-      but it is already ${String(target.isCombineEnabled)}`) : invariant(false) : void 0;
+    !target
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`,
+          )
+        : invariant(false)
+      : void 0;
+    !(target.isCombineEnabled !== isCombineEnabled)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Trying to set droppable isCombineEnabled to ${String(
+              isCombineEnabled,
+            )}
+      but it is already ${String(target.isCombineEnabled)}`,
+          )
+        : invariant(false)
+      : void 0;
     const updated = {
       ...target,
-      isCombineEnabled
+      isCombineEnabled,
     };
     return postDroppableChange(state, updated, true);
   }
@@ -2550,10 +2684,20 @@ var reducer = (function (state, action) {
     if (state.phase === 'DROP_PENDING' || state.phase === 'DROP_ANIMATING') {
       return state;
     }
-    !isMovementAllowed(state) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot move by window in phase ${state.phase}`) : invariant(false) : void 0;
-    !state.isWindowScrollAllowed ? process.env.NODE_ENV !== "production" ? invariant(false, 'Window scrolling is currently not supported for fixed lists') : invariant(false) : void 0;
+    !isMovementAllowed(state)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot move by window in phase ${state.phase}`)
+        : invariant(false)
+      : void 0;
+    !state.isWindowScrollAllowed
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Window scrolling is currently not supported for fixed lists',
+          )
+        : invariant(false)
+      : void 0;
     const newScroll = action.payload.newScroll;
-
     if (isEqual$1(state.viewport.scroll.current, newScroll)) {
       return removeScrollJumpRequest(state);
     }
@@ -2561,12 +2705,12 @@ var reducer = (function (state, action) {
     if (isSnapping(state)) {
       return refreshSnap({
         state,
-        viewport
+        viewport,
       });
     }
     return update({
       state,
-      viewport
+      viewport,
     });
   }
   if (action.type === 'UPDATE_VIEWPORT_MAX_SCROLL') {
@@ -2581,25 +2725,35 @@ var reducer = (function (state, action) {
       ...state.viewport,
       scroll: {
         ...state.viewport.scroll,
-        max: maxScroll
-      }
+        max: maxScroll,
+      },
     };
-
     return {
       ...state,
-      viewport: withMaxScroll
+      viewport: withMaxScroll,
     };
   }
-  if (action.type === 'MOVE_UP' || action.type === 'MOVE_DOWN' || action.type === 'MOVE_LEFT' || action.type === 'MOVE_RIGHT') {
+  if (
+    action.type === 'MOVE_UP' ||
+    action.type === 'MOVE_DOWN' ||
+    action.type === 'MOVE_LEFT' ||
+    action.type === 'MOVE_RIGHT'
+  ) {
     if (state.phase === 'COLLECTING' || state.phase === 'DROP_PENDING') {
       return state;
     }
-    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== "production" ? invariant(false, `${action.type} received while not in DRAGGING phase`) : invariant(false) : void 0;
+    !(state.phase === 'DRAGGING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `${action.type} received while not in DRAGGING phase`,
+          )
+        : invariant(false)
+      : void 0;
     const result = moveInDirection({
       state,
-      type: action.type
+      type: action.type,
     });
-
     if (!result) {
       return state;
     }
@@ -2607,146 +2761,148 @@ var reducer = (function (state, action) {
       state,
       impact: result.impact,
       clientSelection: result.clientSelection,
-      scrollJumpRequest: result.scrollJumpRequest
+      scrollJumpRequest: result.scrollJumpRequest,
     });
   }
   if (action.type === 'DROP_PENDING') {
     const reason = action.payload.reason;
-    !(state.phase === 'COLLECTING') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Can only move into the DROP_PENDING phase from the COLLECTING phase') : invariant(false) : void 0;
+    !(state.phase === 'COLLECTING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Can only move into the DROP_PENDING phase from the COLLECTING phase',
+          )
+        : invariant(false)
+      : void 0;
     const newState = {
       ...state,
       phase: 'DROP_PENDING',
       isWaiting: true,
-      reason
+      reason,
     };
     return newState;
   }
   if (action.type === 'DROP_ANIMATE') {
-    const {
-      completed,
-      dropDuration,
-      newHomeClientOffset
-    } = action.payload;
-    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : invariant(false) : void 0;
-
+    const { completed, dropDuration, newHomeClientOffset } = action.payload;
+    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot animate drop from phase ${state.phase}`)
+        : invariant(false)
+      : void 0;
     const result = {
       phase: 'DROP_ANIMATING',
       completed,
       dropDuration,
       newHomeClientOffset,
-      dimensions: state.dimensions
+      dimensions: state.dimensions,
     };
     return result;
   }
-
   if (action.type === 'DROP_COMPLETE') {
-    const {
-      completed
-    } = action.payload;
+    const { completed } = action.payload;
     return {
       phase: 'IDLE',
       completed,
-      shouldFlush: false
+      shouldFlush: false,
     };
   }
   return state;
-});
+};
 
-const beforeInitialCapture = args => ({
+const beforeInitialCapture = (args) => ({
   type: 'BEFORE_INITIAL_CAPTURE',
-  payload: args
+  payload: args,
 });
-const lift$1 = args => ({
+const lift$1 = (args) => ({
   type: 'LIFT',
-  payload: args
+  payload: args,
 });
-const initialPublish = args => ({
+const initialPublish = (args) => ({
   type: 'INITIAL_PUBLISH',
-  payload: args
+  payload: args,
 });
-const publishWhileDragging = args => ({
+const publishWhileDragging = (args) => ({
   type: 'PUBLISH_WHILE_DRAGGING',
-  payload: args
+  payload: args,
 });
 const collectionStarting = () => ({
   type: 'COLLECTION_STARTING',
-  payload: null
+  payload: null,
 });
-const updateDroppableScroll = args => ({
+const updateDroppableScroll = (args) => ({
   type: 'UPDATE_DROPPABLE_SCROLL',
-  payload: args
+  payload: args,
 });
-const updateDroppableIsEnabled = args => ({
+const updateDroppableIsEnabled = (args) => ({
   type: 'UPDATE_DROPPABLE_IS_ENABLED',
-  payload: args
+  payload: args,
 });
-const updateDroppableIsCombineEnabled = args => ({
+const updateDroppableIsCombineEnabled = (args) => ({
   type: 'UPDATE_DROPPABLE_IS_COMBINE_ENABLED',
-  payload: args
+  payload: args,
 });
-const move = args => ({
+const move = (args) => ({
   type: 'MOVE',
-  payload: args
+  payload: args,
 });
-const moveByWindowScroll = args => ({
+const moveByWindowScroll = (args) => ({
   type: 'MOVE_BY_WINDOW_SCROLL',
-  payload: args
+  payload: args,
 });
-const updateViewportMaxScroll = args => ({
+const updateViewportMaxScroll = (args) => ({
   type: 'UPDATE_VIEWPORT_MAX_SCROLL',
-  payload: args
+  payload: args,
 });
 const moveUp = () => ({
   type: 'MOVE_UP',
-  payload: null
+  payload: null,
 });
 const moveDown = () => ({
   type: 'MOVE_DOWN',
-  payload: null
+  payload: null,
 });
 const moveRight = () => ({
   type: 'MOVE_RIGHT',
-  payload: null
+  payload: null,
 });
 const moveLeft = () => ({
   type: 'MOVE_LEFT',
-  payload: null
+  payload: null,
 });
 const flush = () => ({
   type: 'FLUSH',
-  payload: null
+  payload: null,
 });
-const animateDrop = args => ({
+const animateDrop = (args) => ({
   type: 'DROP_ANIMATE',
-  payload: args
+  payload: args,
 });
-const completeDrop = args => ({
+const completeDrop = (args) => ({
   type: 'DROP_COMPLETE',
-  payload: args
+  payload: args,
 });
-const drop$1 = args => ({
+const drop$1 = (args) => ({
   type: 'DROP',
-  payload: args
+  payload: args,
 });
-const dropPending = args => ({
+const dropPending = (args) => ({
   type: 'DROP_PENDING',
-  payload: args
+  payload: args,
 });
 const dropAnimationFinished = () => ({
   type: 'DROP_ANIMATION_FINISHED',
-  payload: null
+  payload: null,
 });
 
 function checkIndexes(insideDestination) {
   if (insideDestination.length <= 1) {
     return;
   }
-  const indexes = insideDestination.map(d => d.descriptor.index);
+  const indexes = insideDestination.map((d) => d.descriptor.index);
   const errors = {};
   for (let i = 1; i < indexes.length; i++) {
     const current = indexes[i];
     const previous = indexes[i - 1];
-
     if (current !== previous + 1) {
       errors[current] = true;
     }
@@ -2754,125 +2910,127 @@ function checkIndexes(insideDestination) {
   if (!Object.keys(errors).length) {
     return;
   }
-  const formatted = indexes.map(index => {
-    const hasError = Boolean(errors[index]);
-    return hasError ? `[🔥${index}]` : `${index}`;
-  }).join(', ');
-  process.env.NODE_ENV !== "production" ? warning(`
+  const formatted = indexes
+    .map((index) => {
+      const hasError = Boolean(errors[index]);
+      return hasError ? `[🔥${index}]` : `${index}`;
+    })
+    .join(', ');
+  process.env.NODE_ENV !== 'production'
+    ? warning(`
     Detected non-consecutive <Draggable /> indexes.
 
     (This can cause unexpected bugs)
 
     ${formatted}
-  `) : void 0;
+  `)
+    : void 0;
 }
 function validateDimensions(critical, dimensions) {
   if (process.env.NODE_ENV !== 'production') {
-    const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);
+    const insideDestination = getDraggablesInsideDroppable(
+      critical.droppable.id,
+      dimensions.draggables,
+    );
     checkIndexes(insideDestination);
   }
 }
 
-var lift = (marshal => _ref => {
-  let {
-    getState,
-    dispatch
-  } = _ref;
-  return next => action => {
+var lift = (marshal) => (_ref) => {
+  let { getState, dispatch } = _ref;
+  return (next) => (action) => {
     if (action.type !== 'LIFT') {
       next(action);
       return;
     }
-    const {
-      id,
-      clientSelection,
-      movementMode
-    } = action.payload;
+    const { id, clientSelection, movementMode } = action.payload;
     const initial = getState();
-
     if (initial.phase === 'DROP_ANIMATING') {
-      dispatch(completeDrop({
-        completed: initial.completed
-      }));
-    }
-    !(getState().phase === 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected phase to start a drag') : invariant(false) : void 0;
-
+      dispatch(
+        completeDrop({
+          completed: initial.completed,
+        }),
+      );
+    }
+    !(getState().phase === 'IDLE')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Unexpected phase to start a drag')
+        : invariant(false)
+      : void 0;
     dispatch(flush());
-
-    dispatch(beforeInitialCapture({
-      draggableId: id,
-      movementMode
-    }));
-
+    dispatch(
+      beforeInitialCapture({
+        draggableId: id,
+        movementMode,
+      }),
+    );
     const scrollOptions = {
-      shouldPublishImmediately: movementMode === 'SNAP'
+      shouldPublishImmediately: movementMode === 'SNAP',
     };
     const request = {
       draggableId: id,
-      scrollOptions
+      scrollOptions,
     };
-    const {
-      critical,
-      dimensions,
-      viewport
-    } = marshal.startPublishing(request);
+    const { critical, dimensions, viewport } = marshal.startPublishing(request);
     validateDimensions(critical, dimensions);
-
-    dispatch(initialPublish({
-      critical,
-      dimensions,
-      clientSelection,
-      movementMode,
-      viewport
-    }));
+    dispatch(
+      initialPublish({
+        critical,
+        dimensions,
+        clientSelection,
+        movementMode,
+        viewport,
+      }),
+    );
   };
-});
+};
 
-var style = (marshal => () => next => action => {
+var style = (marshal) => () => (next) => (action) => {
   if (action.type === 'INITIAL_PUBLISH') {
     marshal.dragging();
   }
   if (action.type === 'DROP_ANIMATE') {
     marshal.dropping(action.payload.completed.result.reason);
   }
-
   if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {
     marshal.resting();
   }
   next(action);
-});
+};
 
 const curves = {
   outOfTheWay: 'cubic-bezier(0.2, 0, 0, 1)',
-  drop: 'cubic-bezier(.2,1,.1,1)'
+  drop: 'cubic-bezier(.2,1,.1,1)',
 };
 const combine = {
   opacity: {
     drop: 0,
-    combining: 0.7
+    combining: 0.7,
   },
   scale: {
-    drop: 0.75
-  }
+    drop: 0.75,
+  },
 };
 const timings = {
   outOfTheWay: 0.2,
   minDropTime: 0.33,
-  maxDropTime: 0.55
+  maxDropTime: 0.55,
 };
-
 const outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
 const transitions = {
   fluid: `opacity ${outOfTheWayTiming}`,
   snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,
-  drop: duration => {
+  drop: (duration) => {
     const timing = `${duration}s ${curves.drop}`;
     return `transform ${timing}, opacity ${timing}`;
   },
   outOfTheWay: `transform ${outOfTheWayTiming}`,
-  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`
+  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`,
 };
-const moveTo = offset => isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;
+const moveTo = (offset) =>
+  isEqual$1(offset, origin)
+    ? undefined
+    : `translate(${offset.x}px, ${offset.y}px)`;
 const transforms = {
   moveTo,
   drop: (offset, isCombining) => {
@@ -2880,28 +3038,19 @@ const transforms = {
     if (!translate) {
       return undefined;
     }
-
     if (!isCombining) {
       return translate;
     }
-
     return `${translate} scale(${combine.scale.drop})`;
-  }
+  },
 };
 
-const {
-  minDropTime,
-  maxDropTime
-} = timings;
+const { minDropTime, maxDropTime } = timings;
 const dropTimeRange = maxDropTime - minDropTime;
 const maxDropTimeAtDistance = 1500;
 const cancelDropModifier = 0.6;
-var getDropDuration = (_ref => {
-  let {
-    current,
-    destination,
-    reason
-  } = _ref;
+var getDropDuration = (_ref) => {
+  let { current, destination, reason } = _ref;
   const distance$1 = distance(current, destination);
   if (distance$1 <= 0) {
     return minDropTime;
@@ -2909,25 +3058,16 @@ var getDropDuration = (_ref => {
   if (distance$1 >= maxDropTimeAtDistance) {
     return maxDropTime;
   }
-
   const percentage = distance$1 / maxDropTimeAtDistance;
   const duration = minDropTime + dropTimeRange * percentage;
-  const withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;
+  const withDuration =
+    reason === 'CANCEL' ? duration * cancelDropModifier : duration;
   return Number(withDuration.toFixed(2));
-});
+};
 
-var getNewHomeClientOffset = (_ref => {
-  let {
-    impact,
-    draggable,
-    dimensions,
-    viewport,
-    afterCritical
-  } = _ref;
-  const {
-    draggables,
-    droppables
-  } = dimensions;
+var getNewHomeClientOffset = (_ref) => {
+  let { impact, draggable, dimensions, viewport, afterCritical } = _ref;
+  const { draggables, droppables } = dimensions;
   const droppableId = whatIsDraggedOver(impact);
   const destination = droppableId ? droppables[droppableId] : null;
   const home = droppables[draggable.descriptor.droppableId];
@@ -2937,103 +3077,96 @@ var getNewHomeClientOffset = (_ref => {
     draggables,
     afterCritical,
     droppable: destination || home,
-    viewport
+    viewport,
   });
   const offset = subtract(newClientCenter, draggable.client.borderBox.center);
   return offset;
-});
+};
 
-var getDropImpact = (_ref => {
-  let {
-    draggables,
-    reason,
-    lastImpact,
-    home,
-    viewport,
-    onLiftImpact
-  } = _ref;
+var getDropImpact = (_ref) => {
+  let { draggables, reason, lastImpact, home, viewport, onLiftImpact } = _ref;
   if (!lastImpact.at || reason !== 'DROP') {
-
     const recomputedHomeImpact = recompute({
       draggables,
       impact: onLiftImpact,
       destination: home,
       viewport,
-      forceShouldAnimate: true
+      forceShouldAnimate: true,
     });
     return {
       impact: recomputedHomeImpact,
-      didDropInsideDroppable: false
+      didDropInsideDroppable: false,
     };
   }
-
   if (lastImpact.at.type === 'REORDER') {
     return {
       impact: lastImpact,
-      didDropInsideDroppable: true
+      didDropInsideDroppable: true,
     };
   }
-
   const withoutMovement = {
     ...lastImpact,
-    displaced: emptyGroups
+    displaced: emptyGroups,
   };
   return {
     impact: withoutMovement,
-    didDropInsideDroppable: true
+    didDropInsideDroppable: true,
   };
-});
+};
 
-const dropMiddleware = _ref => {
-  let {
-    getState,
-    dispatch
-  } = _ref;
-  return next => action => {
+const dropMiddleware = (_ref) => {
+  let { getState, dispatch } = _ref;
+  return (next) => (action) => {
     if (action.type !== 'DROP') {
       next(action);
       return;
     }
     const state = getState();
     const reason = action.payload.reason;
-
     if (state.phase === 'COLLECTING') {
-      dispatch(dropPending({
-        reason
-      }));
+      dispatch(
+        dropPending({
+          reason,
+        }),
+      );
       return;
     }
-
     if (state.phase === 'IDLE') {
       return;
     }
-
     const isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;
-    !!isWaitingForDrop ? process.env.NODE_ENV !== "production" ? invariant(false, 'A DROP action occurred while DROP_PENDING and still waiting') : invariant(false) : void 0;
-    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot drop in phase: ${state.phase}`) : invariant(false) : void 0;
-
+    !!isWaitingForDrop
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'A DROP action occurred while DROP_PENDING and still waiting',
+          )
+        : invariant(false)
+      : void 0;
+    !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot drop in phase: ${state.phase}`)
+        : invariant(false)
+      : void 0;
     const critical = state.critical;
     const dimensions = state.dimensions;
     const draggable = dimensions.draggables[state.critical.draggable.id];
-
-    const {
-      impact,
-      didDropInsideDroppable
-    } = getDropImpact({
+    const { impact, didDropInsideDroppable } = getDropImpact({
       reason,
       lastImpact: state.impact,
       afterCritical: state.afterCritical,
       onLiftImpact: state.onLiftImpact,
       home: state.dimensions.droppables[state.critical.droppable.id],
       viewport: state.viewport,
-      draggables: state.dimensions.draggables
+      draggables: state.dimensions.draggables,
     });
-
-    const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
+    const destination = didDropInsideDroppable
+      ? tryGetDestination(impact)
+      : null;
     const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;
     const source = {
       index: critical.draggable.index,
-      droppableId: critical.droppable.id
+      droppableId: critical.droppable.id,
     };
     const result = {
       draggableId: draggable.descriptor.id,
@@ -3042,69 +3175,69 @@ const dropMiddleware = _ref => {
       reason,
       mode: state.movementMode,
       destination,
-      combine
+      combine,
     };
     const newHomeClientOffset = getNewHomeClientOffset({
       impact,
       draggable,
       dimensions,
       viewport: state.viewport,
-      afterCritical: state.afterCritical
+      afterCritical: state.afterCritical,
     });
     const completed = {
       critical: state.critical,
       afterCritical: state.afterCritical,
       result,
-      impact
+      impact,
     };
     const isAnimationRequired =
-    !isEqual$1(state.current.client.offset, newHomeClientOffset) ||
-    Boolean(result.combine);
+      !isEqual$1(state.current.client.offset, newHomeClientOffset) ||
+      Boolean(result.combine);
     if (!isAnimationRequired) {
-      dispatch(completeDrop({
-        completed
-      }));
+      dispatch(
+        completeDrop({
+          completed,
+        }),
+      );
       return;
     }
     const dropDuration = getDropDuration({
       current: state.current.client.offset,
       destination: newHomeClientOffset,
-      reason
+      reason,
     });
     const args = {
       newHomeClientOffset,
       dropDuration,
-      completed
+      completed,
     };
     dispatch(animateDrop(args));
   };
 };
 var drop = dropMiddleware;
 
-var getWindowScroll = (() => ({
+var getWindowScroll = () => ({
   x: window.pageXOffset,
-  y: window.pageYOffset
-}));
+  y: window.pageYOffset,
+});
 
 function getWindowScrollBinding(update) {
   return {
     eventName: 'scroll',
     options: {
       passive: true,
-      capture: false
+      capture: false,
     },
-    fn: event => {
+    fn: (event) => {
       if (event.target !== window && event.target !== window.document) {
         return;
       }
       update();
-    }
+    },
   };
 }
 function getScrollListener(_ref) {
-  let {
-    onWindowScroll
-  } = _ref;
+  let { onWindowScroll } = _ref;
   function updateScroll() {
     onWindowScroll(getWindowScroll());
   }
@@ -3115,11 +3248,19 @@ function getScrollListener(_ref) {
     return unbind !== noop$2;
   }
   function start() {
-    !!isActive() ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot start scroll listener when already active') : invariant(false) : void 0;
+    !!isActive()
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot start scroll listener when already active')
+        : invariant(false)
+      : void 0;
     unbind = bindEvents(window, [binding]);
   }
   function stop() {
-    !isActive() ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot stop scroll listener when not active') : invariant(false) : void 0;
+    !isActive()
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot stop scroll listener when not active')
+        : invariant(false)
+      : void 0;
     scheduled.cancel();
     unbind();
     unbind = noop$2;
@@ -3127,20 +3268,25 @@ function getScrollListener(_ref) {
   return {
     start,
     stop,
-    isActive
+    isActive,
   };
 }
 
-const shouldEnd = action => action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
-const scrollListener = store => {
+const shouldEnd = (action) =>
+  action.type === 'DROP_COMPLETE' ||
+  action.type === 'DROP_ANIMATE' ||
+  action.type === 'FLUSH';
+const scrollListener = (store) => {
   const listener = getScrollListener({
-    onWindowScroll: newScroll => {
-      store.dispatch(moveByWindowScroll({
-        newScroll
-      }));
-    }
+    onWindowScroll: (newScroll) => {
+      store.dispatch(
+        moveByWindowScroll({
+          newScroll,
+        }),
+      );
+    },
   });
-  return next => action => {
+  return (next) => (action) => {
     if (!listener.isActive() && action.type === 'INITIAL_PUBLISH') {
       listener.start();
     }
@@ -3152,47 +3298,53 @@ const scrollListener = store => {
 };
 var scrollListener$1 = scrollListener;
 
-var getExpiringAnnounce = (announce => {
+var getExpiringAnnounce = (announce) => {
   let wasCalled = false;
   let isExpired = false;
-
   const timeoutId = setTimeout(() => {
     isExpired = true;
   });
-  const result = message => {
+  const result = (message) => {
     if (wasCalled) {
-      process.env.NODE_ENV !== "production" ? warning('Announcement already made. Not making a second announcement') : void 0;
+      process.env.NODE_ENV !== 'production'
+        ? warning('Announcement already made. Not making a second announcement')
+        : void 0;
       return;
     }
     if (isExpired) {
-      process.env.NODE_ENV !== "production" ? warning(`
+      process.env.NODE_ENV !== 'production'
+        ? warning(`
         Announcements cannot be made asynchronously.
         Default message has already been announced.
-      `) : void 0;
+      `)
+        : void 0;
       return;
     }
     wasCalled = true;
     announce(message);
     clearTimeout(timeoutId);
   };
-
   result.wasCalled = () => wasCalled;
   return result;
-});
+};
 
-var getAsyncMarshal = (() => {
+var getAsyncMarshal = () => {
   const entries = [];
-  const execute = timerId => {
-    const index = entries.findIndex(item => item.timerId === timerId);
-    !(index !== -1) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find timer') : invariant(false) : void 0;
+  const execute = (timerId) => {
+    const index = entries.findIndex((item) => item.timerId === timerId);
+    !(index !== -1)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Could not find timer')
+        : invariant(false)
+      : void 0;
     const [entry] = entries.splice(index, 1);
     entry.callback();
   };
-  const add = fn => {
+  const add = (fn) => {
     const timerId = setTimeout(() => execute(timerId));
     const entry = {
       timerId,
-      callback: fn
+      callback: fn,
     };
     entries.push(entry);
   };
@@ -3202,44 +3354,52 @@ var getAsyncMarshal = (() => {
     }
     const shallow = [...entries];
     entries.length = 0;
-    shallow.forEach(entry => {
+    shallow.forEach((entry) => {
       clearTimeout(entry.timerId);
       entry.callback();
     });
   };
   return {
     add,
-    flush
+    flush,
   };
-});
+};
 
 const areLocationsEqual = (first, second) => {
   if (first == null && second == null) {
     return true;
   }
-
   if (first == null || second == null) {
     return false;
   }
-
-  return first.droppableId === second.droppableId && first.index === second.index;
+  return (
+    first.droppableId === second.droppableId && first.index === second.index
+  );
 };
 const isCombineEqual = (first, second) => {
   if (first == null && second == null) {
     return true;
   }
-
   if (first == null || second == null) {
     return false;
   }
-  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
+  return (
+    first.draggableId === second.draggableId &&
+    first.droppableId === second.droppableId
+  );
 };
 const isCriticalEqual = (first, second) => {
   if (first === second) {
     return true;
   }
-  const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
-  const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
+  const isDraggableEqual =
+    first.draggable.id === second.draggable.id &&
+    first.draggable.droppableId === second.draggable.droppableId &&
+    first.draggable.type === second.draggable.type &&
+    first.draggable.index === second.draggable.index;
+  const isDroppableEqual =
+    first.droppable.id === second.droppable.id &&
+    first.droppable.type === second.droppable.type;
   return isDraggableEqual && isDroppableEqual;
 };
 
@@ -3253,44 +3413,56 @@ const getDragStart = (critical, mode) => ({
   type: critical.droppable.type,
   source: {
     droppableId: critical.droppable.id,
-    index: critical.draggable.index
+    index: critical.draggable.index,
   },
-  mode
+  mode,
 });
-function execute(responder, data, announce,
-getDefaultMessage) {
+function execute(responder, data, announce, getDefaultMessage) {
   if (!responder) {
     announce(getDefaultMessage(data));
     return;
   }
   const willExpire = getExpiringAnnounce(announce);
   const provided = {
-    announce: willExpire
+    announce: willExpire,
   };
-
   responder(data, provided);
   if (!willExpire.wasCalled()) {
     announce(getDefaultMessage(data));
   }
 }
-var getPublisher = ((getResponders, announce) => {
+var getPublisher = (getResponders, announce) => {
   const asyncMarshal = getAsyncMarshal();
   let dragging = null;
   const beforeCapture = (draggableId, mode) => {
-    !!dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onBeforeCapture as a drag start has already been published') : invariant(false) : void 0;
+    !!dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot fire onBeforeCapture as a drag start has already been published',
+          )
+        : invariant(false)
+      : void 0;
     withTimings('onBeforeCapture', () => {
       const fn = getResponders().onBeforeCapture;
       if (fn) {
         const before = {
           draggableId,
-          mode
+          mode,
         };
         fn(before);
       }
     });
   };
   const beforeStart = (critical, mode) => {
-    !!dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;
+    !!dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot fire onBeforeDragStart as a drag start has already been published',
+          )
+        : invariant(false)
+      : void 0;
     withTimings('onBeforeDragStart', () => {
       const fn = getResponders().onBeforeDragStart;
       if (fn) {
@@ -3299,31 +3471,54 @@ var getPublisher = ((getResponders, announce) => {
     });
   };
   const start = (critical, mode) => {
-    !!dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onBeforeDragStart as a drag start has already been published') : invariant(false) : void 0;
+    !!dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot fire onBeforeDragStart as a drag start has already been published',
+          )
+        : invariant(false)
+      : void 0;
     const data = getDragStart(critical, mode);
     dragging = {
       mode,
       lastCritical: critical,
       lastLocation: data.source,
-      lastCombine: null
+      lastCombine: null,
     };
-
     asyncMarshal.add(() => {
-      withTimings('onDragStart', () => execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));
+      withTimings('onDragStart', () =>
+        execute(
+          getResponders().onDragStart,
+          data,
+          announce,
+          preset$1.onDragStart,
+        ),
+      );
     });
   };
-
   const update = (critical, impact) => {
     const location = tryGetDestination(impact);
     const combine = tryGetCombine(impact);
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onDragMove when onDragStart has not been called') : invariant(false) : void 0;
-
-    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot fire onDragMove when onDragStart has not been called',
+          )
+        : invariant(false)
+      : void 0;
+    const hasCriticalChanged = !isCriticalEqual(
+      critical,
+      dragging.lastCritical,
+    );
     if (hasCriticalChanged) {
       dragging.lastCritical = critical;
     }
-
-    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
+    const hasLocationChanged = !areLocationsEqual(
+      dragging.lastLocation,
+      location,
+    );
     if (hasLocationChanged) {
       dragging.lastLocation = location;
     }
@@ -3331,29 +3526,47 @@ var getPublisher = ((getResponders, announce) => {
     if (hasGroupingChanged) {
       dragging.lastCombine = combine;
     }
-
     if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
       return;
     }
     const data = {
       ...getDragStart(critical, dragging.mode),
       combine,
-      destination: location
+      destination: location,
     };
     asyncMarshal.add(() => {
-      withTimings('onDragUpdate', () => execute(getResponders().onDragUpdate, data, announce, preset$1.onDragUpdate));
+      withTimings('onDragUpdate', () =>
+        execute(
+          getResponders().onDragUpdate,
+          data,
+          announce,
+          preset$1.onDragUpdate,
+        ),
+      );
     });
   };
   const flush = () => {
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Can only flush responders while dragging') : invariant(false) : void 0;
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Can only flush responders while dragging')
+        : invariant(false)
+      : void 0;
     asyncMarshal.flush();
   };
-  const drop = result => {
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fire onDragEnd when there is no matching onDragStart') : invariant(false) : void 0;
+  const drop = (result) => {
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot fire onDragEnd when there is no matching onDragStart',
+          )
+        : invariant(false)
+      : void 0;
     dragging = null;
-    withTimings('onDragEnd', () => execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));
+    withTimings('onDragEnd', () =>
+      execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd),
+    );
   };
-
   const abort = () => {
     if (!dragging) {
       return;
@@ -3362,7 +3575,7 @@ var getPublisher = ((getResponders, announce) => {
       ...getDragStart(dragging.lastCritical, dragging.mode),
       combine: null,
       destination: null,
-      reason: 'CANCEL'
+      reason: 'CANCEL',
     };
     drop(result);
   };
@@ -3373,15 +3586,18 @@ var getPublisher = ((getResponders, announce) => {
     update,
     flush,
     drop,
-    abort
+    abort,
   };
-});
+};
 
-var responders = ((getResponders, announce) => {
+var responders = (getResponders, announce) => {
   const publisher = getPublisher(getResponders, announce);
-  return store => next => action => {
+  return (store) => (next) => (action) => {
     if (action.type === 'BEFORE_INITIAL_CAPTURE') {
-      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
+      publisher.beforeCapture(
+        action.payload.draggableId,
+        action.payload.movementMode,
+      );
       return;
     }
     if (action.type === 'INITIAL_PUBLISH') {
@@ -3391,7 +3607,6 @@ var responders = ((getResponders, announce) => {
       publisher.start(critical, action.payload.movementMode);
       return;
     }
-
     if (action.type === 'DROP_COMPLETE') {
       const result = action.payload.completed.result;
       publisher.flush();
@@ -3399,35 +3614,41 @@ var responders = ((getResponders, announce) => {
       publisher.drop(result);
       return;
     }
-
     next(action);
-
     if (action.type === 'FLUSH') {
       publisher.abort();
       return;
     }
-
     const state = store.getState();
     if (state.phase === 'DRAGGING') {
       publisher.update(state.critical, state.impact);
     }
   };
-});
+};
 
-const dropAnimationFinishMiddleware = store => next => action => {
+const dropAnimationFinishMiddleware = (store) => (next) => (action) => {
   if (action.type !== 'DROP_ANIMATION_FINISHED') {
     next(action);
     return;
   }
   const state = store.getState();
-  !(state.phase === 'DROP_ANIMATING') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot finish a drop animating when no drop is occurring') : invariant(false) : void 0;
-  store.dispatch(completeDrop({
-    completed: state.completed
-  }));
+  !(state.phase === 'DROP_ANIMATING')
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          'Cannot finish a drop animating when no drop is occurring',
+        )
+      : invariant(false)
+    : void 0;
+  store.dispatch(
+    completeDrop({
+      completed: state.completed,
+    }),
+  );
 };
 var dropAnimationFinish = dropAnimationFinishMiddleware;
 
-const dropAnimationFlushOnScrollMiddleware = store => {
+const dropAnimationFlushOnScrollMiddleware = (store) => {
   let unbind = null;
   let frameId = null;
   function clear() {
@@ -3440,8 +3661,12 @@ const dropAnimationFlushOnScrollMiddleware = store => {
       unbind = null;
     }
   }
-  return next => action => {
-    if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATION_FINISHED') {
+  return (next) => (action) => {
+    if (
+      action.type === 'FLUSH' ||
+      action.type === 'DROP_COMPLETE' ||
+      action.type === 'DROP_ANIMATION_FINISHED'
+    ) {
       clear();
     }
     next(action);
@@ -3453,16 +3678,15 @@ const dropAnimationFlushOnScrollMiddleware = store => {
       options: {
         capture: true,
         passive: false,
-        once: true
+        once: true,
       },
       fn: function flushDropAnimation() {
         const state = store.getState();
         if (state.phase === 'DROP_ANIMATING') {
           store.dispatch(dropAnimationFinished());
         }
-      }
+      },
     };
-
     frameId = requestAnimationFrame(() => {
       frameId = null;
       unbind = bindEvents(window, [binding]);
@@ -3471,18 +3695,20 @@ const dropAnimationFlushOnScrollMiddleware = store => {
 };
 var dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;
 
-var dimensionMarshalStopper = (marshal => () => next => action => {
+var dimensionMarshalStopper = (marshal) => () => (next) => (action) => {
   if (
-  action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' ||
-  action.type === 'DROP_ANIMATE') {
+    action.type === 'DROP_COMPLETE' ||
+    action.type === 'FLUSH' ||
+    action.type === 'DROP_ANIMATE'
+  ) {
     marshal.stopPublishing();
   }
   next(action);
-});
+};
 
-var focus = (marshal => {
+var focus = (marshal) => {
   let isWatching = false;
-  return () => next => action => {
+  return () => (next) => (action) => {
     if (action.type === 'INITIAL_PUBLISH') {
       isWatching = true;
       marshal.tryRecordFocus(action.payload.critical.draggable.id);
@@ -3502,17 +3728,19 @@ var focus = (marshal => {
     if (action.type === 'DROP_COMPLETE') {
       isWatching = false;
       const result = action.payload.completed.result;
-
       if (result.combine) {
         marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
       }
       marshal.tryRestoreFocusRecorded();
     }
   };
-});
+};
 
-const shouldStop = action => action.type === 'DROP_COMPLETE' || action.type === 'DROP_ANIMATE' || action.type === 'FLUSH';
-var autoScroll = (autoScroller => store => next => action => {
+const shouldStop = (action) =>
+  action.type === 'DROP_COMPLETE' ||
+  action.type === 'DROP_ANIMATE' ||
+  action.type === 'FLUSH';
+var autoScroll = (autoScroller) => (store) => (next) => (action) => {
   if (shouldStop(action)) {
     autoScroller.stop();
     next(action);
@@ -3521,67 +3749,85 @@ var autoScroll = (autoScroller => store => next => action => {
   if (action.type === 'INITIAL_PUBLISH') {
     next(action);
     const state = store.getState();
-    !(state.phase === 'DRAGGING') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected phase to be DRAGGING after INITIAL_PUBLISH') : invariant(false) : void 0;
+    !(state.phase === 'DRAGGING')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Expected phase to be DRAGGING after INITIAL_PUBLISH',
+          )
+        : invariant(false)
+      : void 0;
     autoScroller.start(state);
     return;
   }
-
   next(action);
   autoScroller.scroll(store.getState());
-});
+};
 
-const pendingDrop = store => next => action => {
+const pendingDrop = (store) => (next) => (action) => {
   next(action);
   if (action.type !== 'PUBLISH_WHILE_DRAGGING') {
     return;
   }
-
   const postActionState = store.getState();
-
   if (postActionState.phase !== 'DROP_PENDING') {
     return;
   }
-
   if (postActionState.isWaiting) {
     return;
   }
-  store.dispatch(drop$1({
-    reason: postActionState.reason
-  }));
+  store.dispatch(
+    drop$1({
+      reason: postActionState.reason,
+    }),
+  );
 };
 var pendingDrop$1 = pendingDrop;
 
-const composeEnhancers = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
-  name: '@hello-pangea/dnd'
-}) : compose;
-var createStore = (_ref => {
+const composeEnhancers =
+  process.env.NODE_ENV !== 'production' &&
+  typeof window !== 'undefined' &&
+  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
+    ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
+        name: '@hello-pangea/dnd',
+      })
+    : compose;
+var createStore = (_ref) => {
   let {
     dimensionMarshal,
     focusMarshal,
     styleMarshal,
     getResponders,
     announce,
-    autoScroller
+    autoScroller,
   } = _ref;
-  return createStore$1(reducer, composeEnhancers(applyMiddleware(
-
-  style(styleMarshal),
-  dimensionMarshalStopper(dimensionMarshal),
-  lift(dimensionMarshal), drop,
-  dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal),
-  responders(getResponders, announce))));
-});
+  return createStore$1(
+    reducer,
+    composeEnhancers(
+      applyMiddleware(
+        style(styleMarshal),
+        dimensionMarshalStopper(dimensionMarshal),
+        lift(dimensionMarshal),
+        drop,
+        dropAnimationFinish,
+        dropAnimationFlushOnScroll,
+        pendingDrop$1,
+        autoScroll(autoScroller),
+        scrollListener$1,
+        focus(focusMarshal),
+        responders(getResponders, announce),
+      ),
+    ),
+  );
+};
 
 const clean$1 = () => ({
   additions: {},
   removals: {},
-  modified: {}
+  modified: {},
 });
 function createPublisher(_ref) {
-  let {
-    registry,
-    callbacks
-  } = _ref;
+  let { registry, callbacks } = _ref;
   let staging = clean$1();
   let frameId = null;
   const collect = () => {
@@ -3592,33 +3838,29 @@ function createPublisher(_ref) {
     frameId = requestAnimationFrame(() => {
       frameId = null;
       start();
-      const {
-        additions,
-        removals,
-        modified
-      } = staging;
-      const added = Object.keys(additions).map(
-      id => registry.draggable.getById(id).getDimension(origin))
-      .sort((a, b) => a.descriptor.index - b.descriptor.index);
-      const updated = Object.keys(modified).map(id => {
+      const { additions, removals, modified } = staging;
+      const added = Object.keys(additions)
+        .map((id) => registry.draggable.getById(id).getDimension(origin))
+        .sort((a, b) => a.descriptor.index - b.descriptor.index);
+      const updated = Object.keys(modified).map((id) => {
         const entry = registry.droppable.getById(id);
         const scroll = entry.callbacks.getScrollWhileDragging();
         return {
           droppableId: id,
-          scroll
+          scroll,
         };
       });
       const result = {
         additions: added,
         removals: Object.keys(removals),
-        modified: updated
+        modified: updated,
       };
       staging = clean$1();
       finish();
       callbacks.publish(result);
     });
   };
-  const add = entry => {
+  const add = (entry) => {
     const id = entry.descriptor.id;
     staging.additions[id] = entry;
     staging.modified[entry.descriptor.droppableId] = true;
@@ -3627,7 +3869,7 @@ function createPublisher(_ref) {
     }
     collect();
   };
-  const remove = entry => {
+  const remove = (entry) => {
     const descriptor = entry.descriptor;
     staging.removals[descriptor.id] = true;
     staging.modified[descriptor.droppableId] = true;
@@ -3647,67 +3889,65 @@ function createPublisher(_ref) {
   return {
     add,
     remove,
-    stop
+    stop,
   };
 }
 
-var getMaxScroll = (_ref => {
-  let {
-    scrollHeight,
-    scrollWidth,
-    height,
-    width
-  } = _ref;
+var getMaxScroll = (_ref) => {
+  let { scrollHeight, scrollWidth, height, width } = _ref;
   const maxScroll = subtract(
-  {
-    x: scrollWidth,
-    y: scrollHeight
-  },
-  {
-    x: width,
-    y: height
-  });
+    {
+      x: scrollWidth,
+      y: scrollHeight,
+    },
+    {
+      x: width,
+      y: height,
+    },
+  );
   const adjustedMaxScroll = {
     x: Math.max(0, maxScroll.x),
-    y: Math.max(0, maxScroll.y)
+    y: Math.max(0, maxScroll.y),
   };
   return adjustedMaxScroll;
-});
+};
 
-var getDocumentElement = (() => {
+var getDocumentElement = () => {
   const doc = document.documentElement;
-  !doc ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot find document.documentElement') : invariant(false) : void 0;
+  !doc
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Cannot find document.documentElement')
+      : invariant(false)
+    : void 0;
   return doc;
-});
+};
 
-var getMaxWindowScroll = (() => {
+var getMaxWindowScroll = () => {
   const doc = getDocumentElement();
   const maxScroll = getMaxScroll({
     scrollHeight: doc.scrollHeight,
     scrollWidth: doc.scrollWidth,
     width: doc.clientWidth,
-    height: doc.clientHeight
+    height: doc.clientHeight,
   });
   return maxScroll;
-});
+};
 
-var getViewport = (() => {
+var getViewport = () => {
   const scroll = getWindowScroll();
   const maxScroll = getMaxWindowScroll();
   const top = scroll.y;
   const left = scroll.x;
-
   const doc = getDocumentElement();
   const width = doc.clientWidth;
   const height = doc.clientHeight;
-
   const right = left + width;
   const bottom = top + height;
   const frame = getRect({
     top,
     left,
     right,
-    bottom
+    bottom,
   });
   const viewport = {
     frame,
@@ -3717,37 +3957,39 @@ var getViewport = (() => {
       max: maxScroll,
       diff: {
         value: origin,
-        displacement: origin
-      }
-    }
+        displacement: origin,
+      },
+    },
   };
   return viewport;
-});
+};
 
-var getInitialPublish = (_ref => {
-  let {
-    critical,
-    scrollOptions,
-    registry
-  } = _ref;
+var getInitialPublish = (_ref) => {
+  let { critical, scrollOptions, registry } = _ref;
   start();
   const viewport = getViewport();
   const windowScroll = viewport.scroll.current;
   const home = critical.droppable;
-  const droppables = registry.droppable.getAllByType(home.type).map(entry => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));
-  const draggables = registry.draggable.getAllByType(critical.draggable.type).map(entry => entry.getDimension(windowScroll));
+  const droppables = registry.droppable
+    .getAllByType(home.type)
+    .map((entry) =>
+      entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions),
+    );
+  const draggables = registry.draggable
+    .getAllByType(critical.draggable.type)
+    .map((entry) => entry.getDimension(windowScroll));
   const dimensions = {
     draggables: toDraggableMap(draggables),
-    droppables: toDroppableMap(droppables)
+    droppables: toDroppableMap(droppables),
   };
   finish();
   const result = {
     dimensions,
     critical,
-    viewport
+    viewport,
   };
   return result;
-});
+};
 
 function shouldPublishUpdate(registry, dragging, entry) {
   if (entry.descriptor.id === dragging.id) {
@@ -3758,55 +4000,76 @@ function shouldPublishUpdate(registry, dragging, entry) {
   }
   const home = registry.droppable.getById(entry.descriptor.droppableId);
   if (home.descriptor.mode !== 'virtual') {
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]
       while a drag is occurring. This is only supported for virtual lists.
 
       See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md
-    `) : void 0;
+    `)
+      : void 0;
     return false;
   }
   return true;
 }
-var createDimensionMarshal = ((registry, callbacks) => {
+var createDimensionMarshal = (registry, callbacks) => {
   let collection = null;
   const publisher = createPublisher({
     callbacks: {
       publish: callbacks.publishWhileDragging,
-      collectionStarting: callbacks.collectionStarting
+      collectionStarting: callbacks.collectionStarting,
     },
-    registry
+    registry,
   });
   const updateDroppableIsEnabled = (id, isEnabled) => {
-    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : invariant(false) : void 0;
-
+    !registry.droppable.exists(id)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Cannot update is enabled flag of Droppable ${id} as it is not registered`,
+          )
+        : invariant(false)
+      : void 0;
     if (!collection) {
       return;
     }
-
     callbacks.updateDroppableIsEnabled({
       id,
-      isEnabled
+      isEnabled,
     });
   };
   const updateDroppableIsCombineEnabled = (id, isCombineEnabled) => {
     if (!collection) {
       return;
     }
-    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : invariant(false) : void 0;
+    !registry.droppable.exists(id)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`,
+          )
+        : invariant(false)
+      : void 0;
     callbacks.updateDroppableIsCombineEnabled({
       id,
-      isCombineEnabled
+      isCombineEnabled,
     });
   };
   const updateDroppableScroll = (id, newScroll) => {
     if (!collection) {
       return;
     }
-    !registry.droppable.exists(id) ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : invariant(false) : void 0;
+    !registry.droppable.exists(id)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Cannot update the scroll on Droppable ${id} as it is not registered`,
+          )
+        : invariant(false)
+      : void 0;
     callbacks.updateDroppableScroll({
       id,
-      newScroll
+      newScroll,
     });
   };
   const scrollDroppable = (id, change) => {
@@ -3820,15 +4083,22 @@ var createDimensionMarshal = ((registry, callbacks) => {
       return;
     }
     publisher.stop();
-
     const home = collection.critical.droppable;
-    registry.droppable.getAllByType(home.type).forEach(entry => entry.callbacks.dragStopped());
-
+    registry.droppable
+      .getAllByType(home.type)
+      .forEach((entry) => entry.callbacks.dragStopped());
     collection.unsubscribe();
     collection = null;
   };
-  const subscriber = event => {
-    !collection ? process.env.NODE_ENV !== "production" ? invariant(false, 'Should only be subscribed when a collection is occurring') : invariant(false) : void 0;
+  const subscriber = (event) => {
+    !collection
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Should only be subscribed when a collection is occurring',
+          )
+        : invariant(false)
+      : void 0;
     const dragging = collection.critical.draggable;
     if (event.type === 'ADDITION') {
       if (shouldPublishUpdate(registry, dragging, event.value)) {
@@ -3841,23 +4111,30 @@ var createDimensionMarshal = ((registry, callbacks) => {
       }
     }
   };
-  const startPublishing = request => {
-    !!collection ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot start capturing critical dimensions as there is already a collection') : invariant(false) : void 0;
+  const startPublishing = (request) => {
+    !!collection
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot start capturing critical dimensions as there is already a collection',
+          )
+        : invariant(false)
+      : void 0;
     const entry = registry.draggable.getById(request.draggableId);
     const home = registry.droppable.getById(entry.descriptor.droppableId);
     const critical = {
       draggable: entry.descriptor,
-      droppable: home.descriptor
+      droppable: home.descriptor,
     };
     const unsubscribe = registry.subscribe(subscriber);
     collection = {
       critical,
-      unsubscribe
+      unsubscribe,
     };
     return getInitialPublish({
       critical,
       registry,
-      scrollOptions: request.scrollOptions
+      scrollOptions: request.scrollOptions,
     });
   };
   const marshal = {
@@ -3866,55 +4143,53 @@ var createDimensionMarshal = ((registry, callbacks) => {
     scrollDroppable,
     updateDroppableScroll,
     startPublishing,
-    stopPublishing
+    stopPublishing,
   };
   return marshal;
-});
+};
 
-var canStartDrag = ((state, id) => {
+var canStartDrag = (state, id) => {
   if (state.phase === 'IDLE') {
     return true;
   }
-
   if (state.phase !== 'DROP_ANIMATING') {
     return false;
   }
-
   if (state.completed.result.draggableId === id) {
     return false;
   }
-
   return state.completed.result.reason === 'DROP';
-});
+};
 
-var scrollWindow = (change => {
+var scrollWindow = (change) => {
   window.scrollBy(change.x, change.y);
-});
-
-const getScrollableDroppables = memoizeOne(droppables => toDroppableList(droppables).filter(droppable => {
-  if (!droppable.isEnabled) {
-    return false;
-  }
+};
 
-  if (!droppable.frame) {
-    return false;
-  }
-  return true;
-}));
+const getScrollableDroppables = memoizeOne((droppables) =>
+  toDroppableList(droppables).filter((droppable) => {
+    if (!droppable.isEnabled) {
+      return false;
+    }
+    if (!droppable.frame) {
+      return false;
+    }
+    return true;
+  }),
+);
 const getScrollableDroppableOver = (target, droppables) => {
-  const maybe = getScrollableDroppables(droppables).find(droppable => {
-    !droppable.frame ? process.env.NODE_ENV !== "production" ? invariant(false, 'Invalid result') : invariant(false) : void 0;
-    return isPositionInFrame(droppable.frame.pageMarginBox)(target);
-  }) || null;
+  const maybe =
+    getScrollableDroppables(droppables).find((droppable) => {
+      !droppable.frame
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'Invalid result')
+          : invariant(false)
+        : void 0;
+      return isPositionInFrame(droppable.frame.pageMarginBox)(target);
+    }) || null;
   return maybe;
 };
-var getBestScrollableDroppable = (_ref => {
-  let {
-    center,
-    destination,
-    droppables
-  } = _ref;
-
+var getBestScrollableDroppable = (_ref) => {
+  let { center, destination, droppables } = _ref;
   if (destination) {
     const dimension = droppables[destination];
     if (!dimension.frame) {
@@ -3922,89 +4197,93 @@ var getBestScrollableDroppable = (_ref => {
     }
     return dimension;
   }
-
   const dimension = getScrollableDroppableOver(center, droppables);
   return dimension;
-});
+};
 
 const defaultAutoScrollerOptions = {
   startFromPercentage: 0.25,
   maxScrollAtPercentage: 0.05,
   maxPixelScroll: 28,
-  ease: percentage => percentage ** 2,
+  ease: (percentage) => percentage ** 2,
   durationDampening: {
     stopDampeningAt: 1200,
-    accelerateAt: 360
+    accelerateAt: 360,
   },
-  disabled: false
+  disabled: false,
 };
 
-var getDistanceThresholds = (function (container, axis, getAutoScrollerOptions) {
+var getDistanceThresholds = function (container, axis, getAutoScrollerOptions) {
   if (getAutoScrollerOptions === void 0) {
     getAutoScrollerOptions = () => defaultAutoScrollerOptions;
   }
   const autoScrollerOptions = getAutoScrollerOptions();
-  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;
-  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;
+  const startScrollingFrom =
+    container[axis.size] * autoScrollerOptions.startFromPercentage;
+  const maxScrollValueAt =
+    container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;
   const thresholds = {
     startScrollingFrom,
-    maxScrollValueAt
+    maxScrollValueAt,
   };
   return thresholds;
-});
+};
 
-var getPercentage = (_ref => {
-  let {
-    startOfRange,
-    endOfRange,
-    current
-  } = _ref;
+var getPercentage = (_ref) => {
+  let { startOfRange, endOfRange, current } = _ref;
   const range = endOfRange - startOfRange;
   if (range === 0) {
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       Detected distance range of 0 in the fluid auto scroller
       This is unexpected and would cause a divide by 0 issue.
       Not allowing an auto scroll
-    `) : void 0;
+    `)
+      : void 0;
     return 0;
   }
   const currentInRange = current - startOfRange;
   const percentage = currentInRange / range;
   return percentage;
-});
+};
 
 var minScroll = 1;
 
-var getValueFromDistance = (function (distanceToEdge, thresholds, getAutoScrollerOptions) {
+var getValueFromDistance = function (
+  distanceToEdge,
+  thresholds,
+  getAutoScrollerOptions,
+) {
   if (getAutoScrollerOptions === void 0) {
     getAutoScrollerOptions = () => defaultAutoScrollerOptions;
   }
   const autoScrollerOptions = getAutoScrollerOptions();
-
   if (distanceToEdge > thresholds.startScrollingFrom) {
     return 0;
   }
-
   if (distanceToEdge <= thresholds.maxScrollValueAt) {
     return autoScrollerOptions.maxPixelScroll;
   }
-
   if (distanceToEdge === thresholds.startScrollingFrom) {
     return minScroll;
   }
-
   const percentageFromMaxScrollValueAt = getPercentage({
     startOfRange: thresholds.maxScrollValueAt,
     endOfRange: thresholds.startScrollingFrom,
-    current: distanceToEdge
+    current: distanceToEdge,
   });
   const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
-  const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
-
+  const scroll =
+    autoScrollerOptions.maxPixelScroll *
+    autoScrollerOptions.ease(percentageFromStartScrollingFrom);
   return Math.ceil(scroll);
-});
+};
 
-var dampenValueByTime = ((proposedScroll, dragStartTime, getAutoScrollerOptions) => {
+var dampenValueByTime = (
+  proposedScroll,
+  dragStartTime,
+  getAutoScrollerOptions,
+) => {
   const autoScrollerOptions = getAutoScrollerOptions();
   const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;
   const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;
@@ -4012,54 +4291,62 @@ var dampenValueByTime = ((proposedScroll, dragStartTime, getAutoScrollerOptions)
   const endOfRange = stopAt;
   const now = Date.now();
   const runTime = now - startOfRange;
-
   if (runTime >= stopAt) {
     return proposedScroll;
   }
-
   if (runTime < accelerateAt) {
     return minScroll;
   }
   const betweenAccelerateAtAndStopAtPercentage = getPercentage({
     startOfRange: accelerateAt,
     endOfRange,
-    current: runTime
+    current: runTime,
   });
-  const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);
+  const scroll =
+    proposedScroll *
+    autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);
   return Math.ceil(scroll);
-});
+};
 
-var getValue = (_ref => {
+var getValue = (_ref) => {
   let {
     distanceToEdge,
     thresholds,
     dragStartTime,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
-  const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
-
+  const scroll = getValueFromDistance(
+    distanceToEdge,
+    thresholds,
+    getAutoScrollerOptions,
+  );
   if (scroll === 0) {
     return 0;
   }
-
   if (!shouldUseTimeDampening) {
     return scroll;
   }
+  return Math.max(
+    dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions),
+    minScroll,
+  );
+};
 
-  return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);
-});
-
-var getScrollOnAxis = (_ref => {
+var getScrollOnAxis = (_ref) => {
   let {
     container,
     distanceToEdges,
     dragStartTime,
     axis,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
-  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);
+  const thresholds = getDistanceThresholds(
+    container,
+    axis,
+    getAutoScrollerOptions,
+  );
   const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
   if (isCloserToEnd) {
     return getValue({
@@ -4067,65 +4354,60 @@ var getScrollOnAxis = (_ref => {
       thresholds,
       dragStartTime,
       shouldUseTimeDampening,
-      getAutoScrollerOptions
+      getAutoScrollerOptions,
     });
   }
-  return -1 * getValue({
-    distanceToEdge: distanceToEdges[axis.start],
-    thresholds,
-    dragStartTime,
-    shouldUseTimeDampening,
-    getAutoScrollerOptions
-  });
-});
+  return (
+    -1 *
+    getValue({
+      distanceToEdge: distanceToEdges[axis.start],
+      thresholds,
+      dragStartTime,
+      shouldUseTimeDampening,
+      getAutoScrollerOptions,
+    })
+  );
+};
 
-var adjustForSizeLimits = (_ref => {
-  let {
-    container,
-    subject,
-    proposedScroll
-  } = _ref;
+var adjustForSizeLimits = (_ref) => {
+  let { container, subject, proposedScroll } = _ref;
   const isTooBigVertically = subject.height > container.height;
   const isTooBigHorizontally = subject.width > container.width;
-
   if (!isTooBigHorizontally && !isTooBigVertically) {
     return proposedScroll;
   }
-
   if (isTooBigHorizontally && isTooBigVertically) {
     return null;
   }
-
   return {
     x: isTooBigHorizontally ? 0 : proposedScroll.x,
-    y: isTooBigVertically ? 0 : proposedScroll.y
+    y: isTooBigVertically ? 0 : proposedScroll.y,
   };
-});
+};
 
-const clean = apply(value => value === 0 ? 0 : value);
-var getScroll$1 = (_ref => {
+const clean = apply((value) => (value === 0 ? 0 : value));
+var getScroll$1 = (_ref) => {
   let {
     dragStartTime,
     container,
     subject,
     center,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
   const distanceToEdges = {
     top: center.y - container.top,
     right: container.right - center.x,
     bottom: container.bottom - center.y,
-    left: center.x - container.left
+    left: center.x - container.left,
   };
-
   const y = getScrollOnAxis({
     container,
     distanceToEdges,
     dragStartTime,
     axis: vertical,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   const x = getScrollOnAxis({
     container,
@@ -4133,29 +4415,27 @@ var getScroll$1 = (_ref => {
     dragStartTime,
     axis: horizontal,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   const required = clean({
     x,
-    y
+    y,
   });
-
   if (isEqual$1(required, origin)) {
     return null;
   }
-
   const limited = adjustForSizeLimits({
     container,
     subject,
-    proposedScroll: required
+    proposedScroll: required,
   });
   if (!limited) {
     return null;
   }
   return isEqual$1(limited, origin) ? null : limited;
-});
+};
 
-const smallestSigned = apply(value => {
+const smallestSigned = apply((value) => {
   if (value === 0) {
     return 0;
   }
@@ -4171,16 +4451,12 @@ const getOverlap = (() => {
     }
     return 0;
   };
-  return _ref => {
-    let {
-      current,
-      max,
-      change
-    } = _ref;
+  return (_ref) => {
+    let { current, max, change } = _ref;
     const targetScroll = add(current, change);
     const overlap = {
       x: getRemainder(targetScroll.x, max.x),
-      y: getRemainder(targetScroll.y, max.y)
+      y: getRemainder(targetScroll.y, max.y),
     };
     if (isEqual$1(overlap, origin)) {
       return null;
@@ -4188,42 +4464,35 @@ const getOverlap = (() => {
     return overlap;
   };
 })();
-const canPartiallyScroll = _ref2 => {
-  let {
-    max: rawMax,
-    current,
-    change
-  } = _ref2;
+const canPartiallyScroll = (_ref2) => {
+  let { max: rawMax, current, change } = _ref2;
   const max = {
     x: Math.max(current.x, rawMax.x),
-    y: Math.max(current.y, rawMax.y)
+    y: Math.max(current.y, rawMax.y),
   };
-
   const smallestChange = smallestSigned(change);
   const overlap = getOverlap({
     max,
     current,
-    change: smallestChange
+    change: smallestChange,
   });
-
   if (!overlap) {
     return true;
   }
-
   if (smallestChange.x !== 0 && overlap.x === 0) {
     return true;
   }
-
   if (smallestChange.y !== 0 && overlap.y === 0) {
     return true;
   }
   return false;
 };
-const canScrollWindow = (viewport, change) => canPartiallyScroll({
-  current: viewport.scroll.current,
-  max: viewport.scroll.max,
-  change
-});
+const canScrollWindow = (viewport, change) =>
+  canPartiallyScroll({
+    current: viewport.scroll.current,
+    max: viewport.scroll.max,
+    change,
+  });
 const getWindowOverlap = (viewport, change) => {
   if (!canScrollWindow(viewport, change)) {
     return null;
@@ -4233,19 +4502,18 @@ const getWindowOverlap = (viewport, change) => {
   return getOverlap({
     current,
     max,
-    change
+    change,
   });
 };
 const canScrollDroppable = (droppable, change) => {
   const frame = droppable.frame;
-
   if (!frame) {
     return false;
   }
   return canPartiallyScroll({
     current: frame.scroll.current,
     max: frame.scroll.max,
-    change
+    change,
   });
 };
 const getDroppableOverlap = (droppable, change) => {
@@ -4259,18 +4527,18 @@ const getDroppableOverlap = (droppable, change) => {
   return getOverlap({
     current: frame.scroll.current,
     max: frame.scroll.max,
-    change
+    change,
   });
 };
 
-var getWindowScrollChange = (_ref => {
+var getWindowScrollChange = (_ref) => {
   let {
     viewport,
     subject,
     center,
     dragStartTime,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
   const scroll = getScroll$1({
     dragStartTime,
@@ -4278,22 +4546,21 @@ var getWindowScrollChange = (_ref => {
     subject,
     center,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   return scroll && canScrollWindow(viewport, scroll) ? scroll : null;
-});
+};
 
-var getDroppableScrollChange = (_ref => {
+var getDroppableScrollChange = (_ref) => {
   let {
     droppable,
     subject,
     center,
     dragStartTime,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
   const frame = droppable.frame;
-
   if (!frame) {
     return null;
   }
@@ -4303,19 +4570,19 @@ var getDroppableScrollChange = (_ref => {
     subject,
     center,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;
-});
+};
 
-var scroll = (_ref => {
+var scroll = (_ref) => {
   let {
     state,
     dragStartTime,
     shouldUseTimeDampening,
     scrollWindow,
     scrollDroppable,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   } = _ref;
   const center = state.current.page.borderBoxCenter;
   const draggable = state.dimensions.draggables[state.critical.draggable.id];
@@ -4328,7 +4595,7 @@ var scroll = (_ref => {
       subject,
       center,
       shouldUseTimeDampening,
-      getAutoScrollerOptions
+      getAutoScrollerOptions,
     });
     if (change) {
       scrollWindow(change);
@@ -4338,7 +4605,7 @@ var scroll = (_ref => {
   const droppable = getBestScrollableDroppable({
     center,
     destination: whatIsDraggedOver(state.impact),
-    droppables: state.dimensions.droppables
+    droppables: state.dimensions.droppables,
   });
   if (!droppable) {
     return;
@@ -4349,40 +4616,45 @@ var scroll = (_ref => {
     subject,
     center,
     shouldUseTimeDampening,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   if (change) {
     scrollDroppable(droppable.descriptor.id, change);
   }
-});
+};
 
-var createFluidScroller = (_ref => {
+var createFluidScroller = (_ref) => {
   let {
     scrollWindow,
     scrollDroppable,
-    getAutoScrollerOptions = () => defaultAutoScrollerOptions
+    getAutoScrollerOptions = () => defaultAutoScrollerOptions,
   } = _ref;
   const scheduleWindowScroll = rafSchd(scrollWindow);
   const scheduleDroppableScroll = rafSchd(scrollDroppable);
   let dragging = null;
-  const tryScroll = state => {
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot fluid scroll if not dragging') : invariant(false) : void 0;
-    const {
-      shouldUseTimeDampening,
-      dragStartTime
-    } = dragging;
+  const tryScroll = (state) => {
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot fluid scroll if not dragging')
+        : invariant(false)
+      : void 0;
+    const { shouldUseTimeDampening, dragStartTime } = dragging;
     scroll({
       state,
       scrollWindow: scheduleWindowScroll,
       scrollDroppable: scheduleDroppableScroll,
       dragStartTime,
       shouldUseTimeDampening,
-      getAutoScrollerOptions
+      getAutoScrollerOptions,
     });
   };
-  const start$1 = state => {
+  const start$1 = (state) => {
     start();
-    !!dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot start auto scrolling when already started') : invariant(false) : void 0;
+    !!dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot start auto scrolling when already started')
+        : invariant(false)
+      : void 0;
     const dragStartTime = Date.now();
     let wasScrollNeeded = false;
     const fakeScrollCallback = () => {
@@ -4394,14 +4666,13 @@ var createFluidScroller = (_ref => {
       shouldUseTimeDampening: false,
       scrollWindow: fakeScrollCallback,
       scrollDroppable: fakeScrollCallback,
-      getAutoScrollerOptions
+      getAutoScrollerOptions,
     });
     dragging = {
       dragStartTime,
-      shouldUseTimeDampening: wasScrollNeeded
+      shouldUseTimeDampening: wasScrollNeeded,
     };
     finish();
-
     if (wasScrollNeeded) {
       tryScroll(state);
     }
@@ -4417,20 +4688,16 @@ var createFluidScroller = (_ref => {
   return {
     start: start$1,
     stop,
-    scroll: tryScroll
+    scroll: tryScroll,
   };
-});
+};
 
-var createJumpScroller = (_ref => {
-  let {
-    move,
-    scrollDroppable,
-    scrollWindow
-  } = _ref;
+var createJumpScroller = (_ref) => {
+  let { move, scrollDroppable, scrollWindow } = _ref;
   const moveByOffset = (state, offset) => {
     const client = add(state.current.client.selection, offset);
     move({
-      client
+      client,
     });
   };
   const scrollDroppableAsMuchAsItCan = (droppable, change) => {
@@ -4438,18 +4705,20 @@ var createJumpScroller = (_ref => {
       return change;
     }
     const overlap = getDroppableOverlap(droppable, change);
-
     if (!overlap) {
       scrollDroppable(droppable.descriptor.id, change);
       return null;
     }
-
     const whatTheDroppableCanScroll = subtract(change, overlap);
     scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);
     const remainder = subtract(change, whatTheDroppableCanScroll);
     return remainder;
   };
-  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change) => {
+  const scrollWindowAsMuchAsItCan = (
+    isWindowScrollAllowed,
+    viewport,
+    change,
+  ) => {
     if (!isWindowScrollAllowed) {
       return change;
     }
@@ -4457,62 +4726,64 @@ var createJumpScroller = (_ref => {
       return change;
     }
     const overlap = getWindowOverlap(viewport, change);
-
     if (!overlap) {
       scrollWindow(change);
       return null;
     }
-
     const whatTheWindowCanScroll = subtract(change, overlap);
     scrollWindow(whatTheWindowCanScroll);
     const remainder = subtract(change, whatTheWindowCanScroll);
     return remainder;
   };
-  const jumpScroller = state => {
+  const jumpScroller = (state) => {
     const request = state.scrollJumpRequest;
     if (!request) {
       return;
     }
     const destination = whatIsDraggedOver(state.impact);
-    !destination ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot perform a jump scroll when there is no destination') : invariant(false) : void 0;
-
-    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
-
+    !destination
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot perform a jump scroll when there is no destination',
+          )
+        : invariant(false)
+      : void 0;
+    const droppableRemainder = scrollDroppableAsMuchAsItCan(
+      state.dimensions.droppables[destination],
+      request,
+    );
     if (!droppableRemainder) {
       return;
     }
     const viewport = state.viewport;
-    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
-
+    const windowRemainder = scrollWindowAsMuchAsItCan(
+      state.isWindowScrollAllowed,
+      viewport,
+      droppableRemainder,
+    );
     if (!windowRemainder) {
       return;
     }
-
     moveByOffset(state, windowRemainder);
   };
   return jumpScroller;
-});
+};
 
-var createAutoScroller = (_ref => {
-  let {
-    scrollDroppable,
-    scrollWindow,
-    move,
-    getAutoScrollerOptions
-  } = _ref;
+var createAutoScroller = (_ref) => {
+  let { scrollDroppable, scrollWindow, move, getAutoScrollerOptions } = _ref;
   const fluidScroller = createFluidScroller({
     scrollWindow,
     scrollDroppable,
-    getAutoScrollerOptions
+    getAutoScrollerOptions,
   });
   const jumpScroll = createJumpScroller({
     move,
     scrollWindow,
-    scrollDroppable
+    scrollDroppable,
   });
-  const scroll = state => {
+  const scroll = (state) => {
     const autoScrollerOptions = getAutoScrollerOptions();
-
     if (autoScrollerOptions.disabled || state.phase !== 'DRAGGING') {
       return;
     }
@@ -4528,10 +4799,10 @@ var createAutoScroller = (_ref => {
   const scroller = {
     scroll,
     start: fluidScroller.start,
-    stop: fluidScroller.stop
+    stop: fluidScroller.stop,
   };
   return scroller;
-});
+};
 
 const prefix = 'data-rfd';
 const dragHandle = (() => {
@@ -4539,7 +4810,7 @@ const dragHandle = (() => {
   return {
     base,
     draggableId: `${base}-draggable-id`,
-    contextId: `${base}-context-id`
+    contextId: `${base}-context-id`,
   };
 })();
 const draggable = (() => {
@@ -4547,7 +4818,7 @@ const draggable = (() => {
   return {
     base,
     contextId: `${base}-context-id`,
-    id: `${base}-id`
+    id: `${base}-id`,
   };
 })();
 const droppable = (() => {
@@ -4555,25 +4826,28 @@ const droppable = (() => {
   return {
     base,
     contextId: `${base}-context-id`,
-    id: `${base}-id`
+    id: `${base}-id`,
   };
 })();
 const scrollContainer = {
-  contextId: `${prefix}-scroll-container-context-id`
+  contextId: `${prefix}-scroll-container-context-id`,
 };
 
-const makeGetSelector = context => attribute => `[${attribute}="${context}"]`;
-const getStyles = (rules, property) => rules.map(rule => {
-  const value = rule.styles[property];
-  if (!value) {
-    return '';
-  }
-  return `${rule.selector} { ${value} }`;
-}).join(' ');
+const makeGetSelector = (context) => (attribute) =>
+  `[${attribute}="${context}"]`;
+const getStyles = (rules, property) =>
+  rules
+    .map((rule) => {
+      const value = rule.styles[property];
+      if (!value) {
+        return '';
+      }
+      return `${rule.selector} { ${value} }`;
+    })
+    .join(' ');
 const noPointerEvents = 'pointer-events: none;';
-var getStyles$1 = (contextId => {
+var getStyles$1 = (contextId) => {
   const getSelector = makeGetSelector(contextId);
-
   const dragHandle$1 = (() => {
     const grabCursor = `
       cursor: -webkit-grab;
@@ -4589,11 +4863,10 @@ var getStyles$1 = (contextId => {
         `,
         resting: grabCursor,
         dragging: noPointerEvents,
-        dropAnimating: grabCursor
-      }
+        dropAnimating: grabCursor,
+      },
     };
   })();
-
   const draggable$1 = (() => {
     const transition = `
       transition: ${transitions.outOfTheWay};
@@ -4603,18 +4876,16 @@ var getStyles$1 = (contextId => {
       styles: {
         dragging: transition,
         dropAnimating: transition,
-        userCancel: transition
-      }
+        userCancel: transition,
+      },
     };
   })();
-
   const droppable$1 = {
     selector: getSelector(droppable.contextId),
     styles: {
-      always: `overflow-anchor: none;`
-    }
+      always: `overflow-anchor: none;`,
+    },
   };
-
   const body = {
     selector: 'body',
     styles: {
@@ -4626,8 +4897,8 @@ var getStyles$1 = (contextId => {
         -moz-user-select: none;
         -ms-user-select: none;
         overflow-anchor: none;
-      `
-    }
+      `,
+    },
   };
   const rules = [draggable$1, dragHandle$1, droppable$1, body];
   return {
@@ -4635,19 +4906,28 @@ var getStyles$1 = (contextId => {
     resting: getStyles(rules, 'resting'),
     dragging: getStyles(rules, 'dragging'),
     dropAnimating: getStyles(rules, 'dropAnimating'),
-    userCancel: getStyles(rules, 'userCancel')
+    userCancel: getStyles(rules, 'userCancel'),
   };
-});
+};
 
-const useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect$1 : useEffect;
+const useIsomorphicLayoutEffect =
+  typeof window !== 'undefined' &&
+  typeof window.document !== 'undefined' &&
+  typeof window.document.createElement !== 'undefined'
+    ? useLayoutEffect$1
+    : useEffect;
 var useLayoutEffect = useIsomorphicLayoutEffect;
 
 const getHead = () => {
   const head = document.querySelector('head');
-  !head ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot find the head to append a style to') : invariant(false) : void 0;
+  !head
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Cannot find the head to append a style to')
+      : invariant(false)
+    : void 0;
   return head;
 };
-const createStyleEl = nonce => {
+const createStyleEl = (nonce) => {
   const el = document.createElement('style');
   if (nonce) {
     el.setAttribute('nonce', nonce);
@@ -4659,65 +4939,96 @@ function useStyleMarshal(contextId, nonce) {
   const styles = useMemo(() => getStyles$1(contextId), [contextId]);
   const alwaysRef = useRef(null);
   const dynamicRef = useRef(null);
-
   const setDynamicStyle = useCallback(
-  memoizeOne(proposed => {
-    const el = dynamicRef.current;
-    !el ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;
-    el.textContent = proposed;
-  }), []);
-  const setAlwaysStyle = useCallback(proposed => {
+    memoizeOne((proposed) => {
+      const el = dynamicRef.current;
+      !el
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(
+              false,
+              'Cannot set dynamic style element if it is not set',
+            )
+          : invariant(false)
+        : void 0;
+      el.textContent = proposed;
+    }),
+    [],
+  );
+  const setAlwaysStyle = useCallback((proposed) => {
     const el = alwaysRef.current;
-    !el ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot set dynamic style element if it is not set') : invariant(false) : void 0;
+    !el
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot set dynamic style element if it is not set')
+        : invariant(false)
+      : void 0;
     el.textContent = proposed;
   }, []);
-
   useLayoutEffect(() => {
-    !(!alwaysRef.current && !dynamicRef.current) ? process.env.NODE_ENV !== "production" ? invariant(false, 'style elements already mounted') : invariant(false) : void 0;
+    !(!alwaysRef.current && !dynamicRef.current)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'style elements already mounted')
+        : invariant(false)
+      : void 0;
     const always = createStyleEl(nonce);
     const dynamic = createStyleEl(nonce);
-
     alwaysRef.current = always;
     dynamicRef.current = dynamic;
-
     always.setAttribute(`${prefix}-always`, contextId);
     dynamic.setAttribute(`${prefix}-dynamic`, contextId);
-
     getHead().appendChild(always);
     getHead().appendChild(dynamic);
-
     setAlwaysStyle(styles.always);
     setDynamicStyle(styles.resting);
     return () => {
-      const remove = ref => {
+      const remove = (ref) => {
         const current = ref.current;
-        !current ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot unmount ref as it is not set') : invariant(false) : void 0;
+        !current
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false, 'Cannot unmount ref as it is not set')
+            : invariant(false)
+          : void 0;
         getHead().removeChild(current);
         ref.current = null;
       };
       remove(alwaysRef);
       remove(dynamicRef);
     };
-  }, [nonce, setAlwaysStyle, setDynamicStyle, styles.always, styles.resting, contextId]);
-  const dragging = useCallback(() => setDynamicStyle(styles.dragging), [setDynamicStyle, styles.dragging]);
-  const dropping = useCallback(reason => {
-    if (reason === 'DROP') {
-      setDynamicStyle(styles.dropAnimating);
-      return;
-    }
-    setDynamicStyle(styles.userCancel);
-  }, [setDynamicStyle, styles.dropAnimating, styles.userCancel]);
+  }, [
+    nonce,
+    setAlwaysStyle,
+    setDynamicStyle,
+    styles.always,
+    styles.resting,
+    contextId,
+  ]);
+  const dragging = useCallback(
+    () => setDynamicStyle(styles.dragging),
+    [setDynamicStyle, styles.dragging],
+  );
+  const dropping = useCallback(
+    (reason) => {
+      if (reason === 'DROP') {
+        setDynamicStyle(styles.dropAnimating);
+        return;
+      }
+      setDynamicStyle(styles.userCancel);
+    },
+    [setDynamicStyle, styles.dropAnimating, styles.userCancel],
+  );
   const resting = useCallback(() => {
     if (!dynamicRef.current) {
       return;
     }
     setDynamicStyle(styles.resting);
   }, [setDynamicStyle, styles.resting]);
-  const marshal = useMemo(() => ({
-    dragging,
-    dropping,
-    resting
-  }), [dragging, dropping, resting]);
+  const marshal = useMemo(
+    () => ({
+      dragging,
+      dropping,
+      resting,
+    }),
+    [dragging, dropping, resting],
+  );
   return marshal;
 }
 
@@ -4725,10 +5036,7 @@ function querySelectorAll(parentNode, selector) {
   return Array.from(parentNode.querySelectorAll(selector));
 }
 
-var getWindowFromEl = (el => {
-  var _el$ownerDocument;
-  return (el == null ? void 0 : (_el$ownerDocument = el.ownerDocument) == null ? void 0 : _el$ownerDocument.defaultView) || window;
-});
+var getWindowFromEl = (el) => el?.ownerDocument?.defaultView || window;
 
 function isHtmlElement(el) {
   return el instanceof getWindowFromEl(el).HTMLElement;
@@ -4738,18 +5046,26 @@ function findDragHandle(contextId, draggableId) {
   const selector = `[${dragHandle.contextId}="${contextId}"]`;
   const possible = querySelectorAll(document, selector);
   if (!possible.length) {
-    process.env.NODE_ENV !== "production" ? warning(`Unable to find any drag handles in the context "${contextId}"`) : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning(`Unable to find any drag handles in the context "${contextId}"`)
+      : void 0;
     return null;
   }
-  const handle = possible.find(el => {
+  const handle = possible.find((el) => {
     return el.getAttribute(dragHandle.draggableId) === draggableId;
   });
   if (!handle) {
-    process.env.NODE_ENV !== "production" ? warning(`Unable to find drag handle with id "${draggableId}" as no handle with a matching id was found`) : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning(
+          `Unable to find drag handle with id "${draggableId}" as no handle with a matching id was found`,
+        )
+      : void 0;
     return null;
   }
   if (!isHtmlElement(handle)) {
-    process.env.NODE_ENV !== "production" ? warning('drag handle needs to be a HTMLElement') : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning('drag handle needs to be a HTMLElement')
+      : void 0;
     return null;
   }
   return handle;
@@ -4763,7 +5079,7 @@ function useFocusMarshal(contextId) {
   const register = useCallback(function register(id, focus) {
     const entry = {
       id,
-      focus
+      focus,
     };
     entriesRef.current[id] = entry;
     return function unregister() {
@@ -4774,41 +5090,48 @@ function useFocusMarshal(contextId) {
       }
     };
   }, []);
-  const tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {
-    const handle = findDragHandle(contextId, tryGiveFocusTo);
-    if (handle && handle !== document.activeElement) {
-      handle.focus();
-    }
-  }, [contextId]);
-  const tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {
+  const tryGiveFocus = useCallback(
+    function tryGiveFocus(tryGiveFocusTo) {
+      const handle = findDragHandle(contextId, tryGiveFocusTo);
+      if (handle && handle !== document.activeElement) {
+        handle.focus();
+      }
+    },
+    [contextId],
+  );
+  const tryShiftRecord = useCallback(function tryShiftRecord(
+    previous,
+    redirectTo,
+  ) {
     if (recordRef.current === previous) {
       recordRef.current = redirectTo;
     }
-  }, []);
-  const tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {
-    if (restoreFocusFrameRef.current) {
-      return;
-    }
-
-    if (!isMountedRef.current) {
-      return;
-    }
-    restoreFocusFrameRef.current = requestAnimationFrame(() => {
-      restoreFocusFrameRef.current = null;
-      const record = recordRef.current;
-      if (record) {
-        tryGiveFocus(record);
+  },
+  []);
+  const tryRestoreFocusRecorded = useCallback(
+    function tryRestoreFocusRecorded() {
+      if (restoreFocusFrameRef.current) {
+        return;
       }
-    });
-  }, [tryGiveFocus]);
+      if (!isMountedRef.current) {
+        return;
+      }
+      restoreFocusFrameRef.current = requestAnimationFrame(() => {
+        restoreFocusFrameRef.current = null;
+        const record = recordRef.current;
+        if (record) {
+          tryGiveFocus(record);
+        }
+      });
+    },
+    [tryGiveFocus],
+  );
   const tryRecordFocus = useCallback(function tryRecordFocus(id) {
     recordRef.current = null;
     const focused = document.activeElement;
-
     if (!focused) {
       return;
     }
-
     if (focused.getAttribute(dragHandle.draggableId) !== id) {
       return;
     }
@@ -4824,26 +5147,28 @@ function useFocusMarshal(contextId) {
       }
     };
   }, []);
-  const marshal = useMemo(() => ({
-    register,
-    tryRecordFocus,
-    tryRestoreFocusRecorded,
-    tryShiftRecord
-  }), [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
+  const marshal = useMemo(
+    () => ({
+      register,
+      tryRecordFocus,
+      tryRestoreFocusRecorded,
+      tryShiftRecord,
+    }),
+    [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord],
+  );
   return marshal;
 }
 
 function createRegistry() {
   const entries = {
     draggables: {},
-    droppables: {}
+    droppables: {},
   };
   const subscribers = [];
   function subscribe(cb) {
     subscribers.push(cb);
     return function unsubscribe() {
       const index = subscribers.indexOf(cb);
-
       if (index === -1) {
         return;
       }
@@ -4852,7 +5177,7 @@ function createRegistry() {
   }
   function notify(event) {
     if (subscribers.length) {
-      subscribers.forEach(cb => cb(event));
+      subscribers.forEach((cb) => cb(event));
     }
   }
   function findDraggableById(id) {
@@ -4860,75 +5185,78 @@ function createRegistry() {
   }
   function getDraggableById(id) {
     const entry = findDraggableById(id);
-    !entry ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot find draggable entry with id [${id}]`) : invariant(false) : void 0;
+    !entry
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot find draggable entry with id [${id}]`)
+        : invariant(false)
+      : void 0;
     return entry;
   }
   const draggableAPI = {
-    register: entry => {
+    register: (entry) => {
       entries.draggables[entry.descriptor.id] = entry;
       notify({
         type: 'ADDITION',
-        value: entry
+        value: entry,
       });
     },
     update: (entry, last) => {
       const current = entries.draggables[last.descriptor.id];
-
       if (!current) {
         return;
       }
-
       if (current.uniqueId !== entry.uniqueId) {
         return;
       }
-
       delete entries.draggables[last.descriptor.id];
       entries.draggables[entry.descriptor.id] = entry;
     },
-    unregister: entry => {
+    unregister: (entry) => {
       const draggableId = entry.descriptor.id;
       const current = findDraggableById(draggableId);
-
       if (!current) {
         return;
       }
-
       if (entry.uniqueId !== current.uniqueId) {
         return;
       }
       delete entries.draggables[draggableId];
-
       if (entries.droppables[entry.descriptor.droppableId]) {
         notify({
           type: 'REMOVAL',
-          value: entry
+          value: entry,
         });
       }
     },
     getById: getDraggableById,
     findById: findDraggableById,
-    exists: id => Boolean(findDraggableById(id)),
-    getAllByType: type => Object.values(entries.draggables).filter(entry => entry.descriptor.type === type)
+    exists: (id) => Boolean(findDraggableById(id)),
+    getAllByType: (type) =>
+      Object.values(entries.draggables).filter(
+        (entry) => entry.descriptor.type === type,
+      ),
   };
   function findDroppableById(id) {
     return entries.droppables[id] || null;
   }
   function getDroppableById(id) {
     const entry = findDroppableById(id);
-    !entry ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot find droppable entry with id [${id}]`) : invariant(false) : void 0;
+    !entry
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot find droppable entry with id [${id}]`)
+        : invariant(false)
+      : void 0;
     return entry;
   }
   const droppableAPI = {
-    register: entry => {
+    register: (entry) => {
       entries.droppables[entry.descriptor.id] = entry;
     },
-    unregister: entry => {
+    unregister: (entry) => {
       const current = findDroppableById(entry.descriptor.id);
-
       if (!current) {
         return;
       }
-
       if (entry.uniqueId !== current.uniqueId) {
         return;
       }
@@ -4936,8 +5264,11 @@ function createRegistry() {
     },
     getById: getDroppableById,
     findById: findDroppableById,
-    exists: id => Boolean(findDroppableById(id)),
-    getAllByType: type => Object.values(entries.droppables).filter(entry => entry.descriptor.type === type)
+    exists: (id) => Boolean(findDroppableById(id)),
+    getAllByType: (type) =>
+      Object.values(entries.droppables).filter(
+        (entry) => entry.descriptor.type === type,
+      ),
   };
   function clean() {
     entries.draggables = {};
@@ -4948,7 +5279,7 @@ function createRegistry() {
     draggable: draggableAPI,
     droppable: droppableAPI,
     subscribe,
-    clean
+    clean,
   };
 }
 
@@ -4968,11 +5299,15 @@ function useRegistry() {
 
 var StoreContext = React.createContext(null);
 
-var getBodyElement = (() => {
+var getBodyElement = () => {
   const body = document.body;
-  !body ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot find document.body') : invariant(false) : void 0;
+  !body
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Cannot find document.body')
+      : invariant(false)
+    : void 0;
   return body;
-});
+};
 
 const visuallyHidden = {
   position: 'absolute',
@@ -4983,46 +5318,45 @@ const visuallyHidden = {
   padding: '0',
   overflow: 'hidden',
   clip: 'rect(0 0 0 0)',
-  'clip-path': 'inset(100%)'
+  'clip-path': 'inset(100%)',
 };
 var visuallyHidden$1 = visuallyHidden;
 
-const getId = contextId => `rfd-announcement-${contextId}`;
+const getId = (contextId) => `rfd-announcement-${contextId}`;
 function useAnnouncer(contextId) {
   const id = useMemo(() => getId(contextId), [contextId]);
   const ref = useRef(null);
-  useEffect(function setup() {
-    const el = document.createElement('div');
-    ref.current = el;
-
-    el.id = id;
-
-    el.setAttribute('aria-live', 'assertive');
-    el.setAttribute('aria-atomic', 'true');
-
-    _extends(el.style, visuallyHidden$1);
-
-    getBodyElement().appendChild(el);
-    return function cleanup() {
-
-      setTimeout(function remove() {
-        const body = getBodyElement();
-        if (body.contains(el)) {
-          body.removeChild(el);
-        }
-        if (el === ref.current) {
-          ref.current = null;
-        }
-      });
-    };
-  }, [id]);
-  const announce = useCallback(message => {
+  useEffect(
+    function setup() {
+      const el = document.createElement('div');
+      ref.current = el;
+      el.id = id;
+      el.setAttribute('aria-live', 'assertive');
+      el.setAttribute('aria-atomic', 'true');
+      _extends(el.style, visuallyHidden$1);
+      getBodyElement().appendChild(el);
+      return function cleanup() {
+        setTimeout(function remove() {
+          const body = getBodyElement();
+          if (body.contains(el)) {
+            body.removeChild(el);
+          }
+          if (el === ref.current) {
+            ref.current = null;
+          }
+        });
+      };
+    },
+    [id],
+  );
+  const announce = useCallback((message) => {
     const el = ref.current;
     if (el) {
       el.textContent = message;
       return;
     }
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       A screen reader message was trying to be announced but it was unable to do so.
       This can occur if you unmount your <DragDropContext /> in your onDragEnd.
       Consider calling provided.announce() before the unmount so that the instruction will
@@ -5031,14 +5365,15 @@ function useAnnouncer(contextId) {
       Message not passed to screen reader:
 
       "${message}"
-    `) : void 0;
+    `)
+      : void 0;
   }, []);
   return announce;
 }
 
 let count$1 = 0;
 const defaults = {
-  separator: '::'
+  separator: '::',
 };
 function resetDeprecatedUniqueId() {
   count$1 = 0;
@@ -5047,68 +5382,74 @@ function useDeprecatedUniqueId(prefix, options) {
   if (options === void 0) {
     options = defaults;
   }
-  return useMemo(() => `${prefix}${options.separator}${count$1++}`, [options.separator, prefix]);
+  return useMemo(
+    () => `${prefix}${options.separator}${count$1++}`,
+    [options.separator, prefix],
+  );
 }
 function useUniqueId(prefix, options) {
   if (options === void 0) {
     options = defaults;
   }
   const id = React.useId();
-  return useMemo(() => `${prefix}${options.separator}${id}`, [options.separator, prefix, id]);
+  return useMemo(
+    () => `${prefix}${options.separator}${id}`,
+    [options.separator, prefix, id],
+  );
 }
-
 var useUniqueId$1 = 'useId' in React ? useUniqueId : useDeprecatedUniqueId;
 
 function getElementId(_ref) {
-  let {
-    contextId,
-    uniqueId
-  } = _ref;
+  let { contextId, uniqueId } = _ref;
   return `rfd-hidden-text-${contextId}-${uniqueId}`;
 }
 function useHiddenTextElement(_ref2) {
-  let {
-    contextId,
-    text
-  } = _ref2;
+  let { contextId, text } = _ref2;
   const uniqueId = useUniqueId$1('hidden-text', {
-    separator: '-'
+    separator: '-',
   });
-  const id = useMemo(() => getElementId({
-    contextId,
-    uniqueId
-  }), [uniqueId, contextId]);
-  useEffect(function mount() {
-    const el = document.createElement('div');
-
-    el.id = id;
-
-    el.textContent = text;
-
-    el.style.display = 'none';
-
-    getBodyElement().appendChild(el);
-    return function unmount() {
-      const body = getBodyElement();
-      if (body.contains(el)) {
-        body.removeChild(el);
-      }
-    };
-  }, [id, text]);
+  const id = useMemo(
+    () =>
+      getElementId({
+        contextId,
+        uniqueId,
+      }),
+    [uniqueId, contextId],
+  );
+  useEffect(
+    function mount() {
+      const el = document.createElement('div');
+      el.id = id;
+      el.textContent = text;
+      el.style.display = 'none';
+      getBodyElement().appendChild(el);
+      return function unmount() {
+        const body = getBodyElement();
+        if (body.contains(el)) {
+          body.removeChild(el);
+        }
+      };
+    },
+    [id, text],
+  );
   return id;
 }
 
 var AppContext = React.createContext(null);
 
 var peerDependencies = {
-	react: "^16.8.5 || ^17.0.0 || ^18.0.0",
-	"react-dom": "^16.8.5 || ^17.0.0 || ^18.0.0"
+  react: '^16.8.5 || ^17.0.0 || ^18.0.0',
+  'react-dom': '^16.8.5 || ^17.0.0 || ^18.0.0',
 };
 
 const semver = /(\d+)\.(\d+)\.(\d+)/;
-const getVersion = value => {
+const getVersion = (value) => {
   const result = semver.exec(value);
-  !(result != null) ? process.env.NODE_ENV !== "production" ? invariant(false, `Unable to parse React version ${value}`) : invariant(false) : void 0;
+  !(result != null)
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, `Unable to parse React version ${value}`)
+      : invariant(false)
+    : void 0;
   const major = Number(result[1]);
   const minor = Number(result[2]);
   const patch = Number(result[3]);
@@ -5116,7 +5457,7 @@ const getVersion = value => {
     major,
     minor,
     patch,
-    raw: value
+    raw: value,
   };
 };
 const isSatisfied = (expected, actual) => {
@@ -5126,29 +5467,29 @@ const isSatisfied = (expected, actual) => {
   if (actual.major < expected.major) {
     return false;
   }
-
   if (actual.minor > expected.minor) {
     return true;
   }
   if (actual.minor < expected.minor) {
     return false;
   }
-
   return actual.patch >= expected.patch;
 };
-var checkReactVersion = ((peerDepValue, actualValue) => {
+var checkReactVersion = (peerDepValue, actualValue) => {
   const peerDep = getVersion(peerDepValue);
   const actual = getVersion(actualValue);
   if (isSatisfied(peerDep, actual)) {
     return;
   }
-  process.env.NODE_ENV !== "production" ? warning(`
+  process.env.NODE_ENV !== 'production'
+    ? warning(`
     React version: [${actual.raw}]
     does not satisfy expected peer dependency version: [${peerDep.raw}]
 
     This can result in run time bugs, and even fatal crashes
-  `) : void 0;
-});
+  `)
+    : void 0;
+};
 
 const suffix = `
   We expect a html5 doctype: <!doctype html>
@@ -5156,32 +5497,38 @@ const suffix = `
 
   More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md
 `;
-var checkDoctype = (doc => {
+var checkDoctype = (doc) => {
   const doctype = doc.doctype;
   if (!doctype) {
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       No <!doctype html> found.
 
       ${suffix}
-    `) : void 0;
+    `)
+      : void 0;
     return;
   }
   if (doctype.name.toLowerCase() !== 'html') {
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       Unexpected <!doctype> found: (${doctype.name})
 
       ${suffix}
-    `) : void 0;
+    `)
+      : void 0;
   }
   if (doctype.publicId !== '') {
-    process.env.NODE_ENV !== "production" ? warning(`
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       Unexpected <!doctype> publicId found: (${doctype.publicId})
       A html5 doctype does not have a publicId
 
       ${suffix}
-    `) : void 0;
+    `)
+      : void 0;
   }
-});
+};
 
 function useDev(useHook) {
   if (process.env.NODE_ENV !== 'production') {
@@ -5214,11 +5561,9 @@ function useStartupValidation() {
 
 function usePrevious(current) {
   const ref = useRef(current);
-
   useEffect(() => {
     ref.current = current;
   });
-
   return ref;
 }
 
@@ -5231,15 +5576,23 @@ function create() {
     return value === lock;
   }
   function claim(abandon) {
-    !!lock ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot claim lock as it is already claimed') : invariant(false) : void 0;
+    !!lock
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot claim lock as it is already claimed')
+        : invariant(false)
+      : void 0;
     const newLock = {
-      abandon
+      abandon,
     };
     lock = newLock;
     return newLock;
   }
   function release() {
-    !lock ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot release lock when there is no lock') : invariant(false) : void 0;
+    !lock
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot release lock when there is no lock')
+        : invariant(false)
+      : void 0;
     lock = null;
   }
   function tryAbandon() {
@@ -5253,7 +5606,7 @@ function create() {
     isActive,
     claim,
     release,
-    tryAbandon
+    tryAbandon,
   };
 }
 
@@ -5279,221 +5632,236 @@ const arrowDown = 40;
 
 const preventedKeys = {
   [enter]: true,
-  [tab]: true
+  [tab]: true,
 };
-var preventStandardKeyEvents = (event => {
+var preventStandardKeyEvents = (event) => {
   if (preventedKeys[event.keyCode]) {
     event.preventDefault();
   }
-});
+};
 
 const supportedEventName = (() => {
   const base = 'visibilitychange';
-
   if (typeof document === 'undefined') {
     return base;
   }
-
-  const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];
-  const supported = candidates.find(eventName => `on${eventName}` in document);
-  return supported || base;
+  const candidates = [
+    base,
+    `ms${base}`,
+    `webkit${base}`,
+    `moz${base}`,
+    `o${base}`,
+  ];
+  const supported = candidates.find(
+    (eventName) => `on${eventName}` in document,
+  );
+  return supported || base;
 })();
 var supportedPageVisibilityEventName = supportedEventName;
 
 const primaryButton = 0;
 const sloppyClickThreshold = 5;
 function isSloppyClickThresholdExceeded(original, current) {
-  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
+  return (
+    Math.abs(current.x - original.x) >= sloppyClickThreshold ||
+    Math.abs(current.y - original.y) >= sloppyClickThreshold
+  );
 }
 const idle$1 = {
-  type: 'IDLE'
+  type: 'IDLE',
 };
 function getCaptureBindings(_ref) {
-  let {
-    cancel,
-    completed,
-    getPhase,
-    setPhase
-  } = _ref;
-  return [{
-    eventName: 'mousemove',
-    fn: event => {
-      const {
-        button,
-        clientX,
-        clientY
-      } = event;
-      if (button !== primaryButton) {
-        return;
-      }
-      const point = {
-        x: clientX,
-        y: clientY
-      };
-      const phase = getPhase();
-
-      if (phase.type === 'DRAGGING') {
+  let { cancel, completed, getPhase, setPhase } = _ref;
+  return [
+    {
+      eventName: 'mousemove',
+      fn: (event) => {
+        const { button, clientX, clientY } = event;
+        if (button !== primaryButton) {
+          return;
+        }
+        const point = {
+          x: clientX,
+          y: clientY,
+        };
+        const phase = getPhase();
+        if (phase.type === 'DRAGGING') {
+          event.preventDefault();
+          phase.actions.move(point);
+          return;
+        }
+        !(phase.type === 'PENDING')
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false, 'Cannot be IDLE')
+            : invariant(false)
+          : void 0;
+        const pending = phase.point;
+        if (!isSloppyClickThresholdExceeded(pending, point)) {
+          return;
+        }
         event.preventDefault();
-        phase.actions.move(point);
-        return;
-      }
-
-      !(phase.type === 'PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot be IDLE') : invariant(false) : void 0;
-      const pending = phase.point;
-
-      if (!isSloppyClickThresholdExceeded(pending, point)) {
-        return;
-      }
-
-      event.preventDefault();
-
-      const actions = phase.actions.fluidLift(point);
-      setPhase({
-        type: 'DRAGGING',
-        actions
-      });
-    }
-  }, {
-    eventName: 'mouseup',
-    fn: event => {
-      const phase = getPhase();
-      if (phase.type !== 'DRAGGING') {
-        cancel();
-        return;
-      }
-
-      event.preventDefault();
-      phase.actions.drop({
-        shouldBlockNextClick: true
-      });
-      completed();
-    }
-  }, {
-    eventName: 'mousedown',
-    fn: event => {
-      if (getPhase().type === 'DRAGGING') {
+        const actions = phase.actions.fluidLift(point);
+        setPhase({
+          type: 'DRAGGING',
+          actions,
+        });
+      },
+    },
+    {
+      eventName: 'mouseup',
+      fn: (event) => {
+        const phase = getPhase();
+        if (phase.type !== 'DRAGGING') {
+          cancel();
+          return;
+        }
         event.preventDefault();
-      }
-      cancel();
-    }
-  }, {
-    eventName: 'keydown',
-    fn: event => {
-      const phase = getPhase();
-      if (phase.type === 'PENDING') {
+        phase.actions.drop({
+          shouldBlockNextClick: true,
+        });
+        completed();
+      },
+    },
+    {
+      eventName: 'mousedown',
+      fn: (event) => {
+        if (getPhase().type === 'DRAGGING') {
+          event.preventDefault();
+        }
         cancel();
-        return;
-      }
-
-      if (event.keyCode === escape) {
+      },
+    },
+    {
+      eventName: 'keydown',
+      fn: (event) => {
+        const phase = getPhase();
+        if (phase.type === 'PENDING') {
+          cancel();
+          return;
+        }
+        if (event.keyCode === escape) {
+          event.preventDefault();
+          cancel();
+          return;
+        }
+        preventStandardKeyEvents(event);
+      },
+    },
+    {
+      eventName: 'resize',
+      fn: cancel,
+    },
+    {
+      eventName: 'scroll',
+      options: {
+        passive: true,
+        capture: false,
+      },
+      fn: () => {
+        if (getPhase().type === 'PENDING') {
+          cancel();
+        }
+      },
+    },
+    {
+      eventName: 'webkitmouseforcedown',
+      fn: (event) => {
+        const phase = getPhase();
+        !(phase.type !== 'IDLE')
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false, 'Unexpected phase')
+            : invariant(false)
+          : void 0;
+        if (phase.actions.shouldRespectForcePress()) {
+          cancel();
+          return;
+        }
         event.preventDefault();
-        cancel();
-        return;
-      }
-      preventStandardKeyEvents(event);
-    }
-  }, {
-    eventName: 'resize',
-    fn: cancel
-  }, {
-    eventName: 'scroll',
-    options: {
-      passive: true,
-      capture: false
+      },
     },
-    fn: () => {
-      if (getPhase().type === 'PENDING') {
-        cancel();
-      }
-    }
-  },
-  {
-    eventName: 'webkitmouseforcedown',
-    fn: event => {
-      const phase = getPhase();
-      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected phase') : invariant(false) : void 0;
-      if (phase.actions.shouldRespectForcePress()) {
-        cancel();
-        return;
-      }
-
-      event.preventDefault();
-    }
-  },
-  {
-    eventName: supportedPageVisibilityEventName,
-    fn: cancel
-  }];
+    {
+      eventName: supportedPageVisibilityEventName,
+      fn: cancel,
+    },
+  ];
 }
 function useMouseSensor(api) {
   const phaseRef = useRef(idle$1);
   const unbindEventsRef = useRef(noop$2);
-  const startCaptureBinding = useMemo(() => ({
-    eventName: 'mousedown',
-    fn: function onMouseDown(event) {
-      if (event.defaultPrevented) {
-        return;
-      }
-      if (event.button !== primaryButton) {
-        return;
-      }
-
-      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
-        return;
-      }
-      const draggableId = api.findClosestDraggableId(event);
-      if (!draggableId) {
-        return;
-      }
-      const actions = api.tryGetLock(draggableId,
-      stop, {
-        sourceEvent: event
-      });
-      if (!actions) {
-        return;
-      }
-
-      event.preventDefault();
-      const point = {
-        x: event.clientX,
-        y: event.clientY
+  const startCaptureBinding = useMemo(
+    () => ({
+      eventName: 'mousedown',
+      fn: function onMouseDown(event) {
+        if (event.defaultPrevented) {
+          return;
+        }
+        if (event.button !== primaryButton) {
+          return;
+        }
+        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
+          return;
+        }
+        const draggableId = api.findClosestDraggableId(event);
+        if (!draggableId) {
+          return;
+        }
+        const actions = api.tryGetLock(draggableId, stop, {
+          sourceEvent: event,
+        });
+        if (!actions) {
+          return;
+        }
+        event.preventDefault();
+        const point = {
+          x: event.clientX,
+          y: event.clientY,
+        };
+        unbindEventsRef.current();
+        startPendingDrag(actions, point);
+      },
+    }),
+    [api],
+  );
+  const preventForcePressBinding = useMemo(
+    () => ({
+      eventName: 'webkitmouseforcewillbegin',
+      fn: (event) => {
+        if (event.defaultPrevented) {
+          return;
+        }
+        const id = api.findClosestDraggableId(event);
+        if (!id) {
+          return;
+        }
+        const options = api.findOptionsForDraggable(id);
+        if (!options) {
+          return;
+        }
+        if (options.shouldRespectForcePress) {
+          return;
+        }
+        if (!api.canGetLock(id)) {
+          return;
+        }
+        event.preventDefault();
+      },
+    }),
+    [api],
+  );
+  const listenForCapture = useCallback(
+    function listenForCapture() {
+      const options = {
+        passive: false,
+        capture: true,
       };
-
-      unbindEventsRef.current();
-      startPendingDrag(actions, point);
-    }
-  }),
-  [api]);
-  const preventForcePressBinding = useMemo(() => ({
-    eventName: 'webkitmouseforcewillbegin',
-    fn: event => {
-      if (event.defaultPrevented) {
-        return;
-      }
-      const id = api.findClosestDraggableId(event);
-      if (!id) {
-        return;
-      }
-      const options = api.findOptionsForDraggable(id);
-      if (!options) {
-        return;
-      }
-      if (options.shouldRespectForcePress) {
-        return;
-      }
-      if (!api.canGetLock(id)) {
-        return;
-      }
-      event.preventDefault();
-    }
-  }), [api]);
-  const listenForCapture = useCallback(function listenForCapture() {
-    const options = {
-      passive: false,
-      capture: true
-    };
-    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
-  }, [preventForcePressBinding, startCaptureBinding]);
+      unbindEventsRef.current = bindEvents(
+        window,
+        [preventForcePressBinding, startCaptureBinding],
+        options,
+      );
+    },
+    [preventForcePressBinding, startCaptureBinding],
+  );
   const stop = useCallback(() => {
     const current = phaseRef.current;
     if (current.type === 'IDLE') {
@@ -5508,44 +5876,56 @@ function useMouseSensor(api) {
     stop();
     if (phase.type === 'DRAGGING') {
       phase.actions.cancel({
-        shouldBlockNextClick: true
+        shouldBlockNextClick: true,
       });
     }
     if (phase.type === 'PENDING') {
       phase.actions.abort();
     }
   }, [stop]);
-  const bindCapturingEvents = useCallback(function bindCapturingEvents() {
-    const options = {
-      capture: true,
-      passive: false
-    };
-    const bindings = getCaptureBindings({
-      cancel,
-      completed: stop,
-      getPhase: () => phaseRef.current,
-      setPhase: phase => {
-        phaseRef.current = phase;
-      }
-    });
-    unbindEventsRef.current = bindEvents(window, bindings, options);
-  }, [cancel, stop]);
-  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {
-    !(phaseRef.current.type === 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;
-    phaseRef.current = {
-      type: 'PENDING',
-      point,
-      actions
-    };
-    bindCapturingEvents();
-  }, [bindCapturingEvents]);
-  useLayoutEffect(function mount() {
-    listenForCapture();
-
-    return function unmount() {
-      unbindEventsRef.current();
-    };
-  }, [listenForCapture]);
+  const bindCapturingEvents = useCallback(
+    function bindCapturingEvents() {
+      const options = {
+        capture: true,
+        passive: false,
+      };
+      const bindings = getCaptureBindings({
+        cancel,
+        completed: stop,
+        getPhase: () => phaseRef.current,
+        setPhase: (phase) => {
+          phaseRef.current = phase;
+        },
+      });
+      unbindEventsRef.current = bindEvents(window, bindings, options);
+    },
+    [cancel, stop],
+  );
+  const startPendingDrag = useCallback(
+    function startPendingDrag(actions, point) {
+      !(phaseRef.current.type === 'IDLE')
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'Expected to move from IDLE to PENDING drag')
+          : invariant(false)
+        : void 0;
+      phaseRef.current = {
+        type: 'PENDING',
+        point,
+        actions,
+      };
+      bindCapturingEvents();
+    },
+    [bindCapturingEvents],
+  );
+  useLayoutEffect(
+    function mount() {
+      listenForCapture();
+      return function unmount() {
+        unbindEventsRef.current();
+      };
+    },
+    [listenForCapture],
+  );
 }
 
 function noop$1() {}
@@ -5553,7 +5933,7 @@ const scrollJumpKeys = {
   [pageDown]: true,
   [pageUp]: true,
   [home]: true,
-  [end]: true
+  [end]: true,
 };
 function getDraggingBindings(actions, stop) {
   function cancel() {
@@ -5564,286 +5944,288 @@ function getDraggingBindings(actions, stop) {
     stop();
     actions.drop();
   }
-  return [{
-    eventName: 'keydown',
-    fn: event => {
-      if (event.keyCode === escape) {
-        event.preventDefault();
-        cancel();
-        return;
-      }
-
-      if (event.keyCode === space) {
-        event.preventDefault();
-        drop();
-        return;
-      }
-
-      if (event.keyCode === arrowDown) {
-        event.preventDefault();
-        actions.moveDown();
-        return;
-      }
-      if (event.keyCode === arrowUp) {
-        event.preventDefault();
-        actions.moveUp();
-        return;
-      }
-      if (event.keyCode === arrowRight) {
-        event.preventDefault();
-        actions.moveRight();
-        return;
-      }
-      if (event.keyCode === arrowLeft) {
-        event.preventDefault();
-        actions.moveLeft();
-        return;
-      }
-
-      if (scrollJumpKeys[event.keyCode]) {
-        event.preventDefault();
-        return;
-      }
-      preventStandardKeyEvents(event);
-    }
-  },
-  {
-    eventName: 'mousedown',
-    fn: cancel
-  }, {
-    eventName: 'mouseup',
-    fn: cancel
-  }, {
-    eventName: 'click',
-    fn: cancel
-  }, {
-    eventName: 'touchstart',
-    fn: cancel
-  },
-  {
-    eventName: 'resize',
-    fn: cancel
-  },
-  {
-    eventName: 'wheel',
-    fn: cancel,
-    options: {
-      passive: true
-    }
-  },
-  {
-    eventName: supportedPageVisibilityEventName,
-    fn: cancel
-  }];
+  return [
+    {
+      eventName: 'keydown',
+      fn: (event) => {
+        if (event.keyCode === escape) {
+          event.preventDefault();
+          cancel();
+          return;
+        }
+        if (event.keyCode === space) {
+          event.preventDefault();
+          drop();
+          return;
+        }
+        if (event.keyCode === arrowDown) {
+          event.preventDefault();
+          actions.moveDown();
+          return;
+        }
+        if (event.keyCode === arrowUp) {
+          event.preventDefault();
+          actions.moveUp();
+          return;
+        }
+        if (event.keyCode === arrowRight) {
+          event.preventDefault();
+          actions.moveRight();
+          return;
+        }
+        if (event.keyCode === arrowLeft) {
+          event.preventDefault();
+          actions.moveLeft();
+          return;
+        }
+        if (scrollJumpKeys[event.keyCode]) {
+          event.preventDefault();
+          return;
+        }
+        preventStandardKeyEvents(event);
+      },
+    },
+    {
+      eventName: 'mousedown',
+      fn: cancel,
+    },
+    {
+      eventName: 'mouseup',
+      fn: cancel,
+    },
+    {
+      eventName: 'click',
+      fn: cancel,
+    },
+    {
+      eventName: 'touchstart',
+      fn: cancel,
+    },
+    {
+      eventName: 'resize',
+      fn: cancel,
+    },
+    {
+      eventName: 'wheel',
+      fn: cancel,
+      options: {
+        passive: true,
+      },
+    },
+    {
+      eventName: supportedPageVisibilityEventName,
+      fn: cancel,
+    },
+  ];
 }
 function useKeyboardSensor(api) {
   const unbindEventsRef = useRef(noop$1);
-  const startCaptureBinding = useMemo(() => ({
-    eventName: 'keydown',
-    fn: function onKeyDown(event) {
-      if (event.defaultPrevented) {
-        return;
-      }
-
-      if (event.keyCode !== space) {
-        return;
-      }
-      const draggableId = api.findClosestDraggableId(event);
-      if (!draggableId) {
-        return;
-      }
-      const preDrag = api.tryGetLock(draggableId,
-      stop, {
-        sourceEvent: event
-      });
-
-      if (!preDrag) {
-        return;
-      }
-
-      event.preventDefault();
-      let isCapturing = true;
-
-      const actions = preDrag.snapLift();
-
-      unbindEventsRef.current();
-
-      function stop() {
-        !isCapturing ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot stop capturing a keyboard drag when not capturing') : invariant(false) : void 0;
-        isCapturing = false;
-
+  const startCaptureBinding = useMemo(
+    () => ({
+      eventName: 'keydown',
+      fn: function onKeyDown(event) {
+        if (event.defaultPrevented) {
+          return;
+        }
+        if (event.keyCode !== space) {
+          return;
+        }
+        const draggableId = api.findClosestDraggableId(event);
+        if (!draggableId) {
+          return;
+        }
+        const preDrag = api.tryGetLock(draggableId, stop, {
+          sourceEvent: event,
+        });
+        if (!preDrag) {
+          return;
+        }
+        event.preventDefault();
+        let isCapturing = true;
+        const actions = preDrag.snapLift();
         unbindEventsRef.current();
-        listenForCapture();
-      }
-
-      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
+        function stop() {
+          !isCapturing
+            ? process.env.NODE_ENV !== 'production'
+              ? invariant(
+                  false,
+                  'Cannot stop capturing a keyboard drag when not capturing',
+                )
+              : invariant(false)
+            : void 0;
+          isCapturing = false;
+          unbindEventsRef.current();
+          listenForCapture();
+        }
+        unbindEventsRef.current = bindEvents(
+          window,
+          getDraggingBindings(actions, stop),
+          {
+            capture: true,
+            passive: false,
+          },
+        );
+      },
+    }),
+    [api],
+  );
+  const listenForCapture = useCallback(
+    function tryStartCapture() {
+      const options = {
+        passive: false,
         capture: true,
-        passive: false
-      });
-    }
-  }),
-  [api]);
-  const listenForCapture = useCallback(function tryStartCapture() {
-    const options = {
-      passive: false,
-      capture: true
-    };
-    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
-  }, [startCaptureBinding]);
-  useLayoutEffect(function mount() {
-    listenForCapture();
-
-    return function unmount() {
-      unbindEventsRef.current();
-    };
-  }, [listenForCapture]);
+      };
+      unbindEventsRef.current = bindEvents(
+        window,
+        [startCaptureBinding],
+        options,
+      );
+    },
+    [startCaptureBinding],
+  );
+  useLayoutEffect(
+    function mount() {
+      listenForCapture();
+      return function unmount() {
+        unbindEventsRef.current();
+      };
+    },
+    [listenForCapture],
+  );
 }
 
 const idle = {
-  type: 'IDLE'
+  type: 'IDLE',
 };
 const timeForLongPress = 120;
 const forcePressThreshold = 0.15;
 function getWindowBindings(_ref) {
-  let {
-    cancel,
-    getPhase
-  } = _ref;
+  let { cancel, getPhase } = _ref;
   return [
-  {
-    eventName: 'orientationchange',
-    fn: cancel
-  },
-  {
-    eventName: 'resize',
-    fn: cancel
-  },
-  {
-    eventName: 'contextmenu',
-    fn: event => {
-      event.preventDefault();
-    }
-  },
-  {
-    eventName: 'keydown',
-    fn: event => {
-      if (getPhase().type !== 'DRAGGING') {
-        cancel();
-        return;
-      }
-
-      if (event.keyCode === escape) {
+    {
+      eventName: 'orientationchange',
+      fn: cancel,
+    },
+    {
+      eventName: 'resize',
+      fn: cancel,
+    },
+    {
+      eventName: 'contextmenu',
+      fn: (event) => {
         event.preventDefault();
-      }
-      cancel();
-    }
-  },
-  {
-    eventName: supportedPageVisibilityEventName,
-    fn: cancel
-  }];
+      },
+    },
+    {
+      eventName: 'keydown',
+      fn: (event) => {
+        if (getPhase().type !== 'DRAGGING') {
+          cancel();
+          return;
+        }
+        if (event.keyCode === escape) {
+          event.preventDefault();
+        }
+        cancel();
+      },
+    },
+    {
+      eventName: supportedPageVisibilityEventName,
+      fn: cancel,
+    },
+  ];
 }
-
 function getHandleBindings(_ref2) {
-  let {
-    cancel,
-    completed,
-    getPhase
-  } = _ref2;
-  return [{
-    eventName: 'touchmove',
-    options: {
-      capture: false
+  let { cancel, completed, getPhase } = _ref2;
+  return [
+    {
+      eventName: 'touchmove',
+      options: {
+        capture: false,
+      },
+      fn: (event) => {
+        const phase = getPhase();
+        if (phase.type !== 'DRAGGING') {
+          cancel();
+          return;
+        }
+        phase.hasMoved = true;
+        const { clientX, clientY } = event.touches[0];
+        const point = {
+          x: clientX,
+          y: clientY,
+        };
+        event.preventDefault();
+        phase.actions.move(point);
+      },
     },
-    fn: event => {
-      const phase = getPhase();
-      if (phase.type !== 'DRAGGING') {
-        cancel();
-        return;
-      }
-
-      phase.hasMoved = true;
-      const {
-        clientX,
-        clientY
-      } = event.touches[0];
-      const point = {
-        x: clientX,
-        y: clientY
-      };
-
-      event.preventDefault();
-      phase.actions.move(point);
-    }
-  }, {
-    eventName: 'touchend',
-    fn: event => {
-      const phase = getPhase();
-      if (phase.type !== 'DRAGGING') {
-        cancel();
-        return;
-      }
-
-      event.preventDefault();
-      phase.actions.drop({
-        shouldBlockNextClick: true
-      });
-      completed();
-    }
-  }, {
-    eventName: 'touchcancel',
-    fn: event => {
-      if (getPhase().type !== 'DRAGGING') {
+    {
+      eventName: 'touchend',
+      fn: (event) => {
+        const phase = getPhase();
+        if (phase.type !== 'DRAGGING') {
+          cancel();
+          return;
+        }
+        event.preventDefault();
+        phase.actions.drop({
+          shouldBlockNextClick: true,
+        });
+        completed();
+      },
+    },
+    {
+      eventName: 'touchcancel',
+      fn: (event) => {
+        if (getPhase().type !== 'DRAGGING') {
+          cancel();
+          return;
+        }
+        event.preventDefault();
         cancel();
-        return;
-      }
-
-      event.preventDefault();
-      cancel();
-    }
-  },
-  {
-    eventName: 'touchforcechange',
-    fn: event => {
-      const phase = getPhase();
-
-      !(phase.type !== 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-
-      const touch = event.touches[0];
-      if (!touch) {
-        return;
-      }
-      const isForcePress = touch.force >= forcePressThreshold;
-      if (!isForcePress) {
-        return;
-      }
-      const shouldRespect = phase.actions.shouldRespectForcePress();
-      if (phase.type === 'PENDING') {
+      },
+    },
+    {
+      eventName: 'touchforcechange',
+      fn: (event) => {
+        const phase = getPhase();
+        !(phase.type !== 'IDLE')
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false)
+            : invariant(false)
+          : void 0;
+        const touch = event.touches[0];
+        if (!touch) {
+          return;
+        }
+        const isForcePress = touch.force >= forcePressThreshold;
+        if (!isForcePress) {
+          return;
+        }
+        const shouldRespect = phase.actions.shouldRespectForcePress();
+        if (phase.type === 'PENDING') {
+          if (shouldRespect) {
+            cancel();
+          }
+          return;
+        }
         if (shouldRespect) {
+          if (phase.hasMoved) {
+            event.preventDefault();
+            return;
+          }
           cancel();
-        }
-        return;
-      }
-
-      if (shouldRespect) {
-        if (phase.hasMoved) {
-          event.preventDefault();
           return;
         }
-        cancel();
-        return;
-      }
-
-      event.preventDefault();
-    }
-  },
-  {
-    eventName: supportedPageVisibilityEventName,
-    fn: cancel
-  }
+        event.preventDefault();
+      },
+    },
+    {
+      eventName: supportedPageVisibilityEventName,
+      fn: cancel,
+    },
   ];
 }
-
 function useTouchSensor(api) {
   const phaseRef = useRef(idle);
   const unbindEventsRef = useRef(noop$2);
@@ -5853,54 +6235,54 @@ function useTouchSensor(api) {
   const setPhase = useCallback(function setPhase(phase) {
     phaseRef.current = phase;
   }, []);
-  const startCaptureBinding = useMemo(() => ({
-    eventName: 'touchstart',
-    fn: function onTouchStart(event) {
-      if (event.defaultPrevented) {
-        return;
-      }
-
-      const draggableId = api.findClosestDraggableId(event);
-      if (!draggableId) {
-        return;
-      }
-      const actions = api.tryGetLock(draggableId,
-      stop, {
-        sourceEvent: event
-      });
-
-      if (!actions) {
-        return;
-      }
-      const touch = event.touches[0];
-      const {
-        clientX,
-        clientY
-      } = touch;
-      const point = {
-        x: clientX,
-        y: clientY
+  const startCaptureBinding = useMemo(
+    () => ({
+      eventName: 'touchstart',
+      fn: function onTouchStart(event) {
+        if (event.defaultPrevented) {
+          return;
+        }
+        const draggableId = api.findClosestDraggableId(event);
+        if (!draggableId) {
+          return;
+        }
+        const actions = api.tryGetLock(draggableId, stop, {
+          sourceEvent: event,
+        });
+        if (!actions) {
+          return;
+        }
+        const touch = event.touches[0];
+        const { clientX, clientY } = touch;
+        const point = {
+          x: clientX,
+          y: clientY,
+        };
+        unbindEventsRef.current();
+        startPendingDrag(actions, point);
+      },
+    }),
+    [api],
+  );
+  const listenForCapture = useCallback(
+    function listenForCapture() {
+      const options = {
+        capture: true,
+        passive: false,
       };
-
-      unbindEventsRef.current();
-
-      startPendingDrag(actions, point);
-    }
-  }),
-  [api]);
-  const listenForCapture = useCallback(function listenForCapture() {
-    const options = {
-      capture: true,
-      passive: false
-    };
-    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
-  }, [startCaptureBinding]);
+      unbindEventsRef.current = bindEvents(
+        window,
+        [startCaptureBinding],
+        options,
+      );
+    },
+    [startCaptureBinding],
+  );
   const stop = useCallback(() => {
     const current = phaseRef.current;
     if (current.type === 'IDLE') {
       return;
     }
-
     if (current.type === 'PENDING') {
       clearTimeout(current.longPressTimerId);
     }
@@ -5913,74 +6295,93 @@ function useTouchSensor(api) {
     stop();
     if (phase.type === 'DRAGGING') {
       phase.actions.cancel({
-        shouldBlockNextClick: true
+        shouldBlockNextClick: true,
       });
     }
     if (phase.type === 'PENDING') {
       phase.actions.abort();
     }
   }, [stop]);
-  const bindCapturingEvents = useCallback(function bindCapturingEvents() {
-    const options = {
-      capture: true,
-      passive: false
-    };
-    const args = {
-      cancel,
-      completed: stop,
-      getPhase
-    };
-
-    const unbindTarget = bindEvents(window, getHandleBindings(args), options);
-    const unbindWindow = bindEvents(window, getWindowBindings(args), options);
-    unbindEventsRef.current = function unbindAll() {
-      unbindTarget();
-      unbindWindow();
-    };
-  }, [cancel, getPhase, stop]);
-  const startDragging = useCallback(function startDragging() {
-    const phase = getPhase();
-    !(phase.type === 'PENDING') ? process.env.NODE_ENV !== "production" ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : invariant(false) : void 0;
-    const actions = phase.actions.fluidLift(phase.point);
-    setPhase({
-      type: 'DRAGGING',
-      actions,
-      hasMoved: false
-    });
-  }, [getPhase, setPhase]);
-  const startPendingDrag = useCallback(function startPendingDrag(actions, point) {
-    !(getPhase().type === 'IDLE') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected to move from IDLE to PENDING drag') : invariant(false) : void 0;
-    const longPressTimerId = setTimeout(startDragging, timeForLongPress);
-    setPhase({
-      type: 'PENDING',
-      point,
-      actions,
-      longPressTimerId
-    });
-    bindCapturingEvents();
-  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
-  useLayoutEffect(function mount() {
-    listenForCapture();
-    return function unmount() {
-      unbindEventsRef.current();
-
+  const bindCapturingEvents = useCallback(
+    function bindCapturingEvents() {
+      const options = {
+        capture: true,
+        passive: false,
+      };
+      const args = {
+        cancel,
+        completed: stop,
+        getPhase,
+      };
+      const unbindTarget = bindEvents(window, getHandleBindings(args), options);
+      const unbindWindow = bindEvents(window, getWindowBindings(args), options);
+      unbindEventsRef.current = function unbindAll() {
+        unbindTarget();
+        unbindWindow();
+      };
+    },
+    [cancel, getPhase, stop],
+  );
+  const startDragging = useCallback(
+    function startDragging() {
       const phase = getPhase();
-      if (phase.type === 'PENDING') {
-        clearTimeout(phase.longPressTimerId);
-        setPhase(idle);
-      }
-    };
-  }, [getPhase, listenForCapture, setPhase]);
-
+      !(phase.type === 'PENDING')
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, `Cannot start dragging from phase ${phase.type}`)
+          : invariant(false)
+        : void 0;
+      const actions = phase.actions.fluidLift(phase.point);
+      setPhase({
+        type: 'DRAGGING',
+        actions,
+        hasMoved: false,
+      });
+    },
+    [getPhase, setPhase],
+  );
+  const startPendingDrag = useCallback(
+    function startPendingDrag(actions, point) {
+      !(getPhase().type === 'IDLE')
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'Expected to move from IDLE to PENDING drag')
+          : invariant(false)
+        : void 0;
+      const longPressTimerId = setTimeout(startDragging, timeForLongPress);
+      setPhase({
+        type: 'PENDING',
+        point,
+        actions,
+        longPressTimerId,
+      });
+      bindCapturingEvents();
+    },
+    [bindCapturingEvents, getPhase, setPhase, startDragging],
+  );
+  useLayoutEffect(
+    function mount() {
+      listenForCapture();
+      return function unmount() {
+        unbindEventsRef.current();
+        const phase = getPhase();
+        if (phase.type === 'PENDING') {
+          clearTimeout(phase.longPressTimerId);
+          setPhase(idle);
+        }
+      };
+    },
+    [getPhase, listenForCapture, setPhase],
+  );
   useLayoutEffect(function webkitHack() {
-    const unbind = bindEvents(window, [{
-      eventName: 'touchmove',
-      fn: () => {},
-      options: {
-        capture: false,
-        passive: false
-      }
-    }]);
+    const unbind = bindEvents(window, [
+      {
+        eventName: 'touchmove',
+        fn: () => {},
+        options: {
+          capture: false,
+          passive: false,
+        },
+      },
+    ]);
     return unbind;
   }, []);
 }
@@ -5989,31 +6390,45 @@ function useValidateSensorHooks(sensorHooks) {
   useDev(() => {
     const previousRef = usePrevious(sensorHooks);
     useDevSetupWarning(() => {
-      !(previousRef.current.length === sensorHooks.length) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot change the amount of sensor hooks after mounting') : invariant(false) : void 0;
+      !(previousRef.current.length === sensorHooks.length)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(
+              false,
+              'Cannot change the amount of sensor hooks after mounting',
+            )
+          : invariant(false)
+        : void 0;
     });
   });
 }
 
-const interactiveTagNames = ['input', 'button', 'textarea', 'select', 'option', 'optgroup', 'video', 'audio'];
+const interactiveTagNames = [
+  'input',
+  'button',
+  'textarea',
+  'select',
+  'option',
+  'optgroup',
+  'video',
+  'audio',
+];
 function isAnInteractiveElement(parent, current) {
   if (current == null) {
     return false;
   }
-
-  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
+  const hasAnInteractiveTag = interactiveTagNames.includes(
+    current.tagName.toLowerCase(),
+  );
   if (hasAnInteractiveTag) {
     return true;
   }
-
   const attribute = current.getAttribute('contenteditable');
   if (attribute === 'true' || attribute === '') {
     return true;
   }
-
   if (current === parent) {
     return false;
   }
-
   return isAnInteractiveElement(parent, current.parentElement);
 }
 function isEventInInteractiveElement(draggable, event) {
@@ -6024,7 +6439,8 @@ function isEventInInteractiveElement(draggable, event) {
   return isAnInteractiveElement(draggable, target);
 }
 
-var getBorderBoxCenterPosition = (el => getRect(el.getBoundingClientRect()).center);
+var getBorderBoxCenterPosition = (el) =>
+  getRect(el.getBoundingClientRect()).center;
 
 function isElement(el) {
   return el instanceof getWindowFromEl(el).Element;
@@ -6032,24 +6448,20 @@ function isElement(el) {
 
 const supportedMatchesName = (() => {
   const base = 'matches';
-
   if (typeof document === 'undefined') {
     return base;
   }
-
   const candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];
-  const value = candidates.find(name => name in Element.prototype);
+  const value = candidates.find((name) => name in Element.prototype);
   return value || base;
 })();
 function closestPonyfill(el, selector) {
   if (el == null) {
     return null;
   }
-
   if (el[supportedMatchesName](selector)) {
     return el;
   }
-
   return closestPonyfill(el.parentElement, selector);
 }
 function closest(el, selector) {
@@ -6065,7 +6477,9 @@ function getSelector(contextId) {
 function findClosestDragHandleFromEvent(contextId, event) {
   const target = event.target;
   if (!isElement(target)) {
-    process.env.NODE_ENV !== "production" ? warning('event.target must be a Element') : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning('event.target must be a Element')
+      : void 0;
     return null;
   }
   const selector = getSelector(contextId);
@@ -6074,7 +6488,9 @@ function findClosestDragHandleFromEvent(contextId, event) {
     return null;
   }
   if (!isHtmlElement(handle)) {
-    process.env.NODE_ENV !== "production" ? warning('drag handle must be a HTMLElement') : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning('drag handle must be a HTMLElement')
+      : void 0;
     return null;
   }
   return handle;
@@ -6090,14 +6506,16 @@ function tryGetClosestDraggableIdFromEvent(contextId, event) {
 function findDraggable(contextId, draggableId) {
   const selector = `[${draggable.contextId}="${contextId}"]`;
   const possible = querySelectorAll(document, selector);
-  const draggable$1 = possible.find(el => {
+  const draggable$1 = possible.find((el) => {
     return el.getAttribute(draggable.id) === draggableId;
   });
   if (!draggable$1) {
     return null;
   }
   if (!isHtmlElement(draggable$1)) {
-    process.env.NODE_ENV !== "production" ? warning('Draggable element is not a HTMLElement') : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning('Draggable element is not a HTMLElement')
+      : void 0;
     return null;
   }
   return draggable$1;
@@ -6107,15 +6525,11 @@ function preventDefault(event) {
   event.preventDefault();
 }
 function isActive(_ref) {
-  let {
-    expected,
-    phase,
-    isLockActive,
-    shouldWarn
-  } = _ref;
+  let { expected, phase, isLockActive, shouldWarn } = _ref;
   if (!isLockActive()) {
     if (shouldWarn) {
-      process.env.NODE_ENV !== "production" ? warning(`
+      process.env.NODE_ENV !== 'production'
+        ? warning(`
         Cannot perform action.
         The sensor no longer has an action lock.
 
@@ -6123,13 +6537,15 @@ function isActive(_ref) {
 
         - Throw away your action handlers when forceStop() is called
         - Check actions.isActive() if you really need to
-      `) : void 0;
+      `)
+        : void 0;
     }
     return false;
   }
   if (expected !== phase) {
     if (shouldWarn) {
-      process.env.NODE_ENV !== "production" ? warning(`
+      process.env.NODE_ENV !== 'production'
+        ? warning(`
         Cannot perform action.
         The actions you used belong to an outdated phase
 
@@ -6139,32 +6555,28 @@ function isActive(_ref) {
         Tips:
 
         - Do not use preDragActions actions after calling preDragActions.lift()
-      `) : void 0;
+      `)
+        : void 0;
     }
     return false;
   }
   return true;
 }
 function canStart(_ref2) {
-  let {
-    lockAPI,
-    store,
-    registry,
-    draggableId
-  } = _ref2;
+  let { lockAPI, store, registry, draggableId } = _ref2;
   if (lockAPI.isClaimed()) {
     return false;
   }
   const entry = registry.draggable.findById(draggableId);
   if (!entry) {
-    process.env.NODE_ENV !== "production" ? warning(`Unable to find draggable with id: ${draggableId}`) : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning(`Unable to find draggable with id: ${draggableId}`)
+      : void 0;
     return false;
   }
-
   if (!entry.options.isEnabled) {
     return false;
   }
-
   if (!canStartDrag(store.getState(), draggableId)) {
     return false;
   }
@@ -6178,13 +6590,13 @@ function tryStart(_ref3) {
     registry,
     draggableId,
     forceSensorStop,
-    sourceEvent
+    sourceEvent,
   } = _ref3;
   const shouldStart = canStart({
     lockAPI,
     store,
     registry,
-    draggableId
+    draggableId,
   });
   if (!shouldStart) {
     return null;
@@ -6192,14 +6604,18 @@ function tryStart(_ref3) {
   const entry = registry.draggable.getById(draggableId);
   const el = findDraggable(contextId, entry.descriptor.id);
   if (!el) {
-    process.env.NODE_ENV !== "production" ? warning(`Unable to find draggable element with id: ${draggableId}`) : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning(`Unable to find draggable element with id: ${draggableId}`)
+      : void 0;
     return null;
   }
-
-  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
+  if (
+    sourceEvent &&
+    !entry.options.canDragInteractiveElements &&
+    isEventInInteractiveElement(el, sourceEvent)
+  ) {
     return null;
   }
-
   const lock = lockAPI.claim(forceSensorStop || noop$2);
   let phase = 'PRE_DRAG';
   function getShouldRespectForcePress() {
@@ -6209,12 +6625,14 @@ function tryStart(_ref3) {
     return lockAPI.isActive(lock);
   }
   function tryDispatch(expected, getAction) {
-    if (isActive({
-      expected,
-      phase,
-      isLockActive,
-      shouldWarn: true
-    })) {
+    if (
+      isActive({
+        expected,
+        phase,
+        isLockActive,
+        shouldWarn: true,
+      })
+    ) {
       store.dispatch(getAction());
     }
   }
@@ -6226,70 +6644,76 @@ function tryStart(_ref3) {
     }
     if (phase !== 'PRE_DRAG') {
       completed();
-      process.env.NODE_ENV !== "production" ? invariant(false, `Cannot lift in phase ${phase}`) : invariant(false) ;
+      process.env.NODE_ENV !== 'production'
+        ? invariant(false, `Cannot lift in phase ${phase}`)
+        : invariant(false);
     }
     store.dispatch(lift$1(args.liftActionArgs));
-
     phase = 'DRAGGING';
     function finish(reason, options) {
       if (options === void 0) {
         options = {
-          shouldBlockNextClick: false
+          shouldBlockNextClick: false,
         };
       }
       args.cleanup();
-
       if (options.shouldBlockNextClick) {
-        const unbind = bindEvents(window, [{
-          eventName: 'click',
-          fn: preventDefault,
-          options: {
-            once: true,
-            passive: false,
-            capture: true
-          }
-        }]);
+        const unbind = bindEvents(window, [
+          {
+            eventName: 'click',
+            fn: preventDefault,
+            options: {
+              once: true,
+              passive: false,
+              capture: true,
+            },
+          },
+        ]);
         setTimeout(unbind);
       }
-
       completed();
-      store.dispatch(drop$1({
-        reason
-      }));
+      store.dispatch(
+        drop$1({
+          reason,
+        }),
+      );
     }
     return {
-      isActive: () => isActive({
-        expected: 'DRAGGING',
-        phase,
-        isLockActive,
-        shouldWarn: false
-      }),
+      isActive: () =>
+        isActive({
+          expected: 'DRAGGING',
+          phase,
+          isLockActive,
+          shouldWarn: false,
+        }),
       shouldRespectForcePress: getShouldRespectForcePress,
-      drop: options => finish('DROP', options),
-      cancel: options => finish('CANCEL', options),
-      ...args.actions
+      drop: (options) => finish('DROP', options),
+      cancel: (options) => finish('CANCEL', options),
+      ...args.actions,
     };
   }
   function fluidLift(clientSelection) {
-    const move$1 = rafSchd(client => {
-      tryDispatchWhenDragging(() => move({
-        client
-      }));
+    const move$1 = rafSchd((client) => {
+      tryDispatchWhenDragging(() =>
+        move({
+          client,
+        }),
+      );
     });
     const api = lift({
       liftActionArgs: {
         id: draggableId,
         clientSelection,
-        movementMode: 'FLUID'
+        movementMode: 'FLUID',
       },
       cleanup: () => move$1.cancel(),
       actions: {
-        move: move$1
-      }
+        move: move$1,
+      },
     });
     return {
       ...api,
-      move: move$1
+      move: move$1,
     };
   }
   function snapLift() {
@@ -6297,16 +6721,16 @@ function tryStart(_ref3) {
       moveUp: () => tryDispatchWhenDragging(moveUp),
       moveRight: () => tryDispatchWhenDragging(moveRight),
       moveDown: () => tryDispatchWhenDragging(moveDown),
-      moveLeft: () => tryDispatchWhenDragging(moveLeft)
+      moveLeft: () => tryDispatchWhenDragging(moveLeft),
     };
     return lift({
       liftActionArgs: {
         id: draggableId,
         clientSelection: getBorderBoxCenterPosition(el),
-        movementMode: 'SNAP'
+        movementMode: 'SNAP',
       },
       cleanup: noop$2,
-      actions
+      actions,
     });
   }
   function abortPreDrag() {
@@ -6314,106 +6738,134 @@ function tryStart(_ref3) {
       expected: 'PRE_DRAG',
       phase,
       isLockActive,
-      shouldWarn: true
+      shouldWarn: true,
     });
     if (shouldRelease) {
       lockAPI.release();
     }
   }
   const preDrag = {
-    isActive: () => isActive({
-      expected: 'PRE_DRAG',
-      phase,
-      isLockActive,
-      shouldWarn: false
-    }),
+    isActive: () =>
+      isActive({
+        expected: 'PRE_DRAG',
+        phase,
+        isLockActive,
+        shouldWarn: false,
+      }),
     shouldRespectForcePress: getShouldRespectForcePress,
     fluidLift,
     snapLift,
-    abort: abortPreDrag
+    abort: abortPreDrag,
   };
   return preDrag;
 }
 const defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
 function useSensorMarshal(_ref4) {
-  let {
-    contextId,
-    store,
-    registry,
-    customSensors,
-    enableDefaultSensors
-  } = _ref4;
-  const useSensors = [...(enableDefaultSensors ? defaultSensors : []), ...(customSensors || [])];
+  let { contextId, store, registry, customSensors, enableDefaultSensors } =
+    _ref4;
+  const useSensors = [
+    ...(enableDefaultSensors ? defaultSensors : []),
+    ...(customSensors || []),
+  ];
   const lockAPI = useState(() => create())[0];
-  const tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {
-    if (isDragging(previous) && !isDragging(current)) {
-      lockAPI.tryAbandon();
-    }
-  }, [lockAPI]);
-
-  useLayoutEffect(function listenToStore() {
-    let previous = store.getState();
-    const unsubscribe = store.subscribe(() => {
-      const current = store.getState();
-      tryAbandonLock(previous, current);
-      previous = current;
-    });
-
-    return unsubscribe;
-  }, [lockAPI, store, tryAbandonLock]);
-
+  const tryAbandonLock = useCallback(
+    function tryAbandonLock(previous, current) {
+      if (isDragging(previous) && !isDragging(current)) {
+        lockAPI.tryAbandon();
+      }
+    },
+    [lockAPI],
+  );
+  useLayoutEffect(
+    function listenToStore() {
+      let previous = store.getState();
+      const unsubscribe = store.subscribe(() => {
+        const current = store.getState();
+        tryAbandonLock(previous, current);
+        previous = current;
+      });
+      return unsubscribe;
+    },
+    [lockAPI, store, tryAbandonLock],
+  );
   useLayoutEffect(() => {
     return lockAPI.tryAbandon;
   }, [lockAPI.tryAbandon]);
-  const canGetLock = useCallback(draggableId => {
-    return canStart({
-      lockAPI,
-      registry,
-      store,
-      draggableId
-    });
-  }, [lockAPI, registry, store]);
-  const tryGetLock = useCallback((draggableId, forceStop, options) => tryStart({
-    lockAPI,
-    registry,
-    contextId,
-    store,
-    draggableId,
-    forceSensorStop: forceStop || null,
-    sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
-  }), [contextId, lockAPI, registry, store]);
-  const findClosestDraggableId = useCallback(event => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);
-  const findOptionsForDraggable = useCallback(id => {
-    const entry = registry.draggable.findById(id);
-    return entry ? entry.options : null;
-  }, [registry.draggable]);
-  const tryReleaseLock = useCallback(function tryReleaseLock() {
-    if (!lockAPI.isClaimed()) {
-      return;
-    }
-    lockAPI.tryAbandon();
-    if (store.getState().phase !== 'IDLE') {
-      store.dispatch(flush());
-    }
-  }, [lockAPI, store]);
+  const canGetLock = useCallback(
+    (draggableId) => {
+      return canStart({
+        lockAPI,
+        registry,
+        store,
+        draggableId,
+      });
+    },
+    [lockAPI, registry, store],
+  );
+  const tryGetLock = useCallback(
+    (draggableId, forceStop, options) =>
+      tryStart({
+        lockAPI,
+        registry,
+        contextId,
+        store,
+        draggableId,
+        forceSensorStop: forceStop || null,
+        sourceEvent:
+          options && options.sourceEvent ? options.sourceEvent : null,
+      }),
+    [contextId, lockAPI, registry, store],
+  );
+  const findClosestDraggableId = useCallback(
+    (event) => tryGetClosestDraggableIdFromEvent(contextId, event),
+    [contextId],
+  );
+  const findOptionsForDraggable = useCallback(
+    (id) => {
+      const entry = registry.draggable.findById(id);
+      return entry ? entry.options : null;
+    },
+    [registry.draggable],
+  );
+  const tryReleaseLock = useCallback(
+    function tryReleaseLock() {
+      if (!lockAPI.isClaimed()) {
+        return;
+      }
+      lockAPI.tryAbandon();
+      if (store.getState().phase !== 'IDLE') {
+        store.dispatch(flush());
+      }
+    },
+    [lockAPI, store],
+  );
   const isLockClaimed = useCallback(() => lockAPI.isClaimed(), [lockAPI]);
-  const api = useMemo(() => ({
-    canGetLock,
-    tryGetLock,
-    findClosestDraggableId,
-    findOptionsForDraggable,
-    tryReleaseLock,
-    isLockClaimed
-  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
-
+  const api = useMemo(
+    () => ({
+      canGetLock,
+      tryGetLock,
+      findClosestDraggableId,
+      findOptionsForDraggable,
+      tryReleaseLock,
+      isLockClaimed,
+    }),
+    [
+      canGetLock,
+      tryGetLock,
+      findClosestDraggableId,
+      findOptionsForDraggable,
+      tryReleaseLock,
+      isLockClaimed,
+    ],
+  );
   useValidateSensorHooks(useSensors);
   for (let i = 0; i < useSensors.length; i++) {
     useSensors[i](api);
   }
 }
 
-const createResponders = props => ({
-  onBeforeCapture: t => {
+const createResponders = (props) => ({
+  onBeforeCapture: (t) => {
     const onBeforeCapureCallback = () => {
       if (props.onBeforeCapture) {
         props.onBeforeCapture(t);
@@ -6428,18 +6880,22 @@ const createResponders = props => ({
   onBeforeDragStart: props.onBeforeDragStart,
   onDragStart: props.onDragStart,
   onDragEnd: props.onDragEnd,
-  onDragUpdate: props.onDragUpdate
+  onDragUpdate: props.onDragUpdate,
 });
-const createAutoScrollerOptions = props => ({
+const createAutoScrollerOptions = (props) => ({
   ...defaultAutoScrollerOptions,
   ...props.autoScrollerOptions,
   durationDampening: {
     ...defaultAutoScrollerOptions.durationDampening,
-    ...props.autoScrollerOptions
-  }
+    ...props.autoScrollerOptions,
+  },
 });
 function getStore(lazyRef) {
-  !lazyRef.current ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find store from lazy ref') : invariant(false) : void 0;
+  !lazyRef.current
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Could not find store from lazy ref')
+      : invariant(false)
+    : void 0;
   return lazyRef.current;
 }
 function App(props) {
@@ -6448,11 +6904,10 @@ function App(props) {
     setCallbacks,
     sensors,
     nonce,
-    dragHandleUsageInstructions
+    dragHandleUsageInstructions,
   } = props;
   const lazyStoreRef = useRef(null);
   useStartupValidation();
-
   const lastPropsRef = usePrevious(props);
   const getResponders = useCallback(() => {
     return createResponders(lastPropsRef.current);
@@ -6463,47 +6918,72 @@ function App(props) {
   const announce = useAnnouncer(contextId);
   const dragHandleUsageInstructionsId = useHiddenTextElement({
     contextId,
-    text: dragHandleUsageInstructions
+    text: dragHandleUsageInstructions,
   });
   const styleMarshal = useStyleMarshal(contextId, nonce);
-  const lazyDispatch = useCallback(action => {
+  const lazyDispatch = useCallback((action) => {
     getStore(lazyStoreRef).dispatch(action);
   }, []);
-  const marshalCallbacks = useMemo(() => bindActionCreators({
-    publishWhileDragging,
-    updateDroppableScroll,
-    updateDroppableIsEnabled,
-    updateDroppableIsCombineEnabled,
-    collectionStarting
-  }, lazyDispatch), [lazyDispatch]);
+  const marshalCallbacks = useMemo(
+    () =>
+      bindActionCreators(
+        {
+          publishWhileDragging,
+          updateDroppableScroll,
+          updateDroppableIsEnabled,
+          updateDroppableIsCombineEnabled,
+          collectionStarting,
+        },
+        lazyDispatch,
+      ),
+    [lazyDispatch],
+  );
   const registry = useRegistry();
   const dimensionMarshal = useMemo(() => {
     return createDimensionMarshal(registry, marshalCallbacks);
   }, [registry, marshalCallbacks]);
-  const autoScroller = useMemo(() => createAutoScroller({
-    scrollWindow,
-    scrollDroppable: dimensionMarshal.scrollDroppable,
-    getAutoScrollerOptions,
-    ...bindActionCreators({
-      move
-    }, lazyDispatch)
-  }), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);
+  const autoScroller = useMemo(
+    () =>
+      createAutoScroller({
+        scrollWindow,
+        scrollDroppable: dimensionMarshal.scrollDroppable,
+        getAutoScrollerOptions,
+        ...bindActionCreators(
+          {
+            move,
+          },
+          lazyDispatch,
+        ),
+      }),
+    [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions],
+  );
   const focusMarshal = useFocusMarshal(contextId);
-  const store = useMemo(() => createStore({
-    announce,
-    autoScroller,
-    dimensionMarshal,
-    focusMarshal,
-    getResponders,
-    styleMarshal
-  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
-
+  const store = useMemo(
+    () =>
+      createStore({
+        announce,
+        autoScroller,
+        dimensionMarshal,
+        focusMarshal,
+        getResponders,
+        styleMarshal,
+      }),
+    [
+      announce,
+      autoScroller,
+      dimensionMarshal,
+      focusMarshal,
+      getResponders,
+      styleMarshal,
+    ],
+  );
   if (process.env.NODE_ENV !== 'production') {
     if (lazyStoreRef.current && lazyStoreRef.current !== store) {
-      process.env.NODE_ENV !== "production" ? warning('unexpected store change') : void 0;
+      process.env.NODE_ENV !== 'production'
+        ? warning('unexpected store change')
+        : void 0;
     }
   }
-
   lazyStoreRef.current = store;
   const tryResetStore = useCallback(() => {
     const current = getStore(lazyStoreRef);
@@ -6522,40 +7002,66 @@ function App(props) {
     }
     return state.isDragging;
   }, []);
-  const appCallbacks = useMemo(() => ({
-    isDragging,
-    tryAbort: tryResetStore
-  }), [isDragging, tryResetStore]);
-
+  const appCallbacks = useMemo(
+    () => ({
+      isDragging,
+      tryAbort: tryResetStore,
+    }),
+    [isDragging, tryResetStore],
+  );
   setCallbacks(appCallbacks);
-  const getCanLift = useCallback(id => canStartDrag(getStore(lazyStoreRef).getState(), id), []);
-  const getIsMovementAllowed = useCallback(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
-  const appContext = useMemo(() => ({
-    marshal: dimensionMarshal,
-    focus: focusMarshal,
-    contextId,
-    canLift: getCanLift,
-    isMovementAllowed: getIsMovementAllowed,
-    dragHandleUsageInstructionsId,
-    registry
-  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
+  const getCanLift = useCallback(
+    (id) => canStartDrag(getStore(lazyStoreRef).getState(), id),
+    [],
+  );
+  const getIsMovementAllowed = useCallback(
+    () => isMovementAllowed(getStore(lazyStoreRef).getState()),
+    [],
+  );
+  const appContext = useMemo(
+    () => ({
+      marshal: dimensionMarshal,
+      focus: focusMarshal,
+      contextId,
+      canLift: getCanLift,
+      isMovementAllowed: getIsMovementAllowed,
+      dragHandleUsageInstructionsId,
+      registry,
+    }),
+    [
+      contextId,
+      dimensionMarshal,
+      dragHandleUsageInstructionsId,
+      focusMarshal,
+      getCanLift,
+      getIsMovementAllowed,
+      registry,
+    ],
+  );
   useSensorMarshal({
     contextId,
     store,
     registry,
     customSensors: sensors || null,
-    enableDefaultSensors: props.enableDefaultSensors !== false
+    enableDefaultSensors: props.enableDefaultSensors !== false,
   });
-
   useEffect(() => {
     return tryResetStore;
   }, [tryResetStore]);
-  return React.createElement(AppContext.Provider, {
-    value: appContext
-  }, React.createElement(Provider, {
-    context: StoreContext,
-    store: store
-  }, props.children));
+  return React.createElement(
+    AppContext.Provider,
+    {
+      value: appContext,
+    },
+    React.createElement(
+      Provider,
+      {
+        context: StoreContext,
+        store: store,
+      },
+      props.children,
+    ),
+  );
 }
 
 let count = 0;
@@ -6568,12 +7074,16 @@ function useDeprecatedUniqueContextId() {
 function useUniqueContextId() {
   return React.useId();
 }
-
-var useUniqueContextId$1 = 'useId' in React ? useUniqueContextId : useDeprecatedUniqueContextId;
+var useUniqueContextId$1 =
+  'useId' in React ? useUniqueContextId : useDeprecatedUniqueContextId;
 
 function resetServerContext() {
   if ('useId' in React) {
-    process.env.NODE_ENV !== "production" ? warning(`It is not necessary to call resetServerContext when using React 18+`) : void 0;
+    process.env.NODE_ENV !== 'production'
+      ? warning(
+          `It is not necessary to call resetServerContext when using React 18+`,
+        )
+      : void 0;
     return;
   }
   resetDeprecatedUniqueContextId();
@@ -6581,27 +7091,33 @@ function resetServerContext() {
 }
 function DragDropContext(props) {
   const contextId = useUniqueContextId$1();
-  const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;
-
-  return React.createElement(ErrorBoundary, null, setCallbacks => React.createElement(App, {
-    nonce: props.nonce,
-    contextId: contextId,
-    setCallbacks: setCallbacks,
-    dragHandleUsageInstructions: dragHandleUsageInstructions,
-    enableDefaultSensors: props.enableDefaultSensors,
-    sensors: props.sensors,
-    onBeforeCapture: props.onBeforeCapture,
-    onBeforeDragStart: props.onBeforeDragStart,
-    onDragStart: props.onDragStart,
-    onDragUpdate: props.onDragUpdate,
-    onDragEnd: props.onDragEnd,
-    autoScrollerOptions: props.autoScrollerOptions
-  }, props.children));
+  const dragHandleUsageInstructions =
+    props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;
+  return React.createElement(ErrorBoundary, null, (setCallbacks) =>
+    React.createElement(
+      App,
+      {
+        nonce: props.nonce,
+        contextId: contextId,
+        setCallbacks: setCallbacks,
+        dragHandleUsageInstructions: dragHandleUsageInstructions,
+        enableDefaultSensors: props.enableDefaultSensors,
+        sensors: props.sensors,
+        onBeforeCapture: props.onBeforeCapture,
+        onBeforeDragStart: props.onBeforeDragStart,
+        onDragStart: props.onDragStart,
+        onDragUpdate: props.onDragUpdate,
+        onDragEnd: props.onDragEnd,
+        autoScrollerOptions: props.autoScrollerOptions,
+      },
+      props.children,
+    ),
+  );
 }
 
 const zIndexOptions = {
   dragging: 5000,
-  dropAnimating: 4500
+  dropAnimating: 4500,
 };
 const getDraggingTransition = (shouldAnimateDragMovement, dropping) => {
   if (dropping) {
@@ -6618,7 +7134,7 @@ const getDraggingOpacity = (isCombining, isDropAnimating) => {
   }
   return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
 };
-const getShouldDraggingAnimate = dragging => {
+const getShouldDraggingAnimate = (dragging) => {
   if (dragging.forceShouldAnimate != null) {
     return dragging.forceShouldAnimate;
   }
@@ -6627,15 +7143,13 @@ const getShouldDraggingAnimate = dragging => {
 function getDraggingStyle(dragging) {
   const dimension = dragging.dimension;
   const box = dimension.client;
-  const {
-    offset,
-    combineWith,
-    dropping
-  } = dragging;
+  const { offset, combineWith, dropping } = dragging;
   const isCombining = Boolean(combineWith);
   const shouldAnimate = getShouldDraggingAnimate(dragging);
   const isDropAnimating = Boolean(dropping);
-  const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);
+  const transform = isDropAnimating
+    ? transforms.drop(offset, isCombining)
+    : transforms.moveTo(offset);
   const style = {
     position: 'fixed',
     top: box.marginBox.top,
@@ -6646,19 +7160,23 @@ function getDraggingStyle(dragging) {
     transition: getDraggingTransition(shouldAnimate, dropping),
     transform,
     opacity: getDraggingOpacity(isCombining, isDropAnimating),
-    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
-    pointerEvents: 'none'
+    zIndex: isDropAnimating
+      ? zIndexOptions.dropAnimating
+      : zIndexOptions.dragging,
+    pointerEvents: 'none',
   };
   return style;
 }
 function getSecondaryStyle(secondary) {
   return {
     transform: transforms.moveTo(secondary.offset),
-    transition: secondary.shouldAnimateDisplacement ? undefined : 'none'
+    transition: secondary.shouldAnimateDisplacement ? undefined : 'none',
   };
 }
 function getStyle$1(mapped) {
-  return mapped.type === 'DRAGGING' ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
+  return mapped.type === 'DRAGGING'
+    ? getDraggingStyle(mapped)
+    : getSecondaryStyle(mapped);
 }
 
 function getDimension$1(descriptor, el, windowScroll) {
@@ -6672,18 +7190,18 @@ function getDimension$1(descriptor, el, windowScroll) {
   const placeholder = {
     client,
     tagName: el.tagName.toLowerCase(),
-    display: computedStyles.display
+    display: computedStyles.display,
   };
   const displaceBy = {
     x: client.marginBox.width,
-    y: client.marginBox.height
+    y: client.marginBox.height,
   };
   const dimension = {
     descriptor,
     placeholder,
     displaceBy,
     client,
-    page
+    page,
   };
   return dimension;
 }
@@ -6696,32 +7214,43 @@ function useDraggablePublisher(args) {
     getDraggableRef,
     canDragInteractiveElements,
     shouldRespectForcePress,
-    isEnabled
+    isEnabled,
   } = args;
-  const options = useMemo(() => ({
-    canDragInteractiveElements,
-    shouldRespectForcePress,
-    isEnabled
-  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
-  const getDimension = useCallback(windowScroll => {
-    const el = getDraggableRef();
-    !el ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot get dimension when no ref is set') : invariant(false) : void 0;
-    return getDimension$1(descriptor, el, windowScroll);
-  }, [descriptor, getDraggableRef]);
-  const entry = useMemo(() => ({
-    uniqueId,
-    descriptor,
-    options,
-    getDimension
-  }), [descriptor, getDimension, options, uniqueId]);
+  const options = useMemo(
+    () => ({
+      canDragInteractiveElements,
+      shouldRespectForcePress,
+      isEnabled,
+    }),
+    [canDragInteractiveElements, isEnabled, shouldRespectForcePress],
+  );
+  const getDimension = useCallback(
+    (windowScroll) => {
+      const el = getDraggableRef();
+      !el
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'Cannot get dimension when no ref is set')
+          : invariant(false)
+        : void 0;
+      return getDimension$1(descriptor, el, windowScroll);
+    },
+    [descriptor, getDraggableRef],
+  );
+  const entry = useMemo(
+    () => ({
+      uniqueId,
+      descriptor,
+      options,
+      getDimension,
+    }),
+    [descriptor, getDimension, options, uniqueId],
+  );
   const publishedRef = useRef(entry);
   const isFirstPublishRef = useRef(true);
-
   useLayoutEffect(() => {
     registry.draggable.register(publishedRef.current);
     return () => registry.draggable.unregister(publishedRef.current);
   }, [registry.draggable]);
-
   useLayoutEffect(() => {
     if (isFirstPublishRef.current) {
       isFirstPublishRef.current = false;
@@ -6736,12 +7265,19 @@ function useDraggablePublisher(args) {
 var DroppableContext = React.createContext(null);
 
 function checkIsValidInnerRef(el) {
-  !(el && isHtmlElement(el)) ? process.env.NODE_ENV !== "production" ? invariant(false, `
+  !(el && isHtmlElement(el))
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(
+          false,
+          `
     provided.innerRef has not been provided with a HTMLElement.
 
     You can find a guide on using the innerRef callback functions at:
     https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md
-  `) : invariant(false) : void 0;
+  `,
+        )
+      : invariant(false)
+    : void 0;
 }
 
 function useValidation$1(props, contextId, getRef) {
@@ -6749,44 +7285,69 @@ function useValidation$1(props, contextId, getRef) {
     function prefix(id) {
       return `Draggable[id: ${id}]: `;
     }
-
     const id = props.draggableId;
-    !id ? process.env.NODE_ENV !== "production" ? invariant(false, 'Draggable requires a draggableId') : invariant(false) : void 0;
-    !(typeof id === 'string') ? process.env.NODE_ENV !== "production" ? invariant(false, `Draggable requires a [string] draggableId.
-      Provided: [type: ${typeof id}] (value: ${id})`) : invariant(false) : void 0;
-    !Number.isInteger(props.index) ? process.env.NODE_ENV !== "production" ? invariant(false, `${prefix(id)} requires an integer index prop`) : invariant(false) : void 0;
+    !id
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Draggable requires a draggableId')
+        : invariant(false)
+      : void 0;
+    !(typeof id === 'string')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `Draggable requires a [string] draggableId.
+      Provided: [type: ${typeof id}] (value: ${id})`,
+          )
+        : invariant(false)
+      : void 0;
+    !Number.isInteger(props.index)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, `${prefix(id)} requires an integer index prop`)
+        : invariant(false)
+      : void 0;
     if (props.mapped.type === 'DRAGGING') {
       return;
     }
-
     checkIsValidInnerRef(getRef());
-
     if (props.isEnabled) {
-      !findDragHandle(contextId, id) ? process.env.NODE_ENV !== "production" ? invariant(false, `${prefix(id)} Unable to find drag handle`) : invariant(false) : void 0;
+      !findDragHandle(contextId, id)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, `${prefix(id)} Unable to find drag handle`)
+          : invariant(false)
+        : void 0;
     }
   });
 }
-
 function useClonePropValidation(isClone) {
   useDev(() => {
     const initialRef = useRef(isClone);
-
     useDevSetupWarning(() => {
-      !(isClone === initialRef.current) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Draggable isClone prop value changed during component life') : invariant(false) : void 0;
+      !(isClone === initialRef.current)
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(
+              false,
+              'Draggable isClone prop value changed during component life',
+            )
+          : invariant(false)
+        : void 0;
     }, [isClone]);
   });
 }
 
 function useRequiredContext(Context) {
   const result = useContext(Context);
-  !result ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find required context') : invariant(false) : void 0;
+  !result
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Could not find required context')
+      : invariant(false)
+    : void 0;
   return result;
 }
 
 function preventHtml5Dnd(event) {
   event.preventDefault();
 }
-const Draggable = props => {
+const Draggable = (props) => {
   const ref = useRef(null);
   const setRef = useCallback(function (el) {
     if (el === void 0) {
@@ -6795,23 +7356,18 @@ const Draggable = props => {
     ref.current = el;
   }, []);
   const getRef = useCallback(() => ref.current, []);
-
-  const {
-    contextId,
-    dragHandleUsageInstructionsId,
-    registry
-  } = useRequiredContext(AppContext);
-  const {
-    type,
-    droppableId
-  } = useRequiredContext(DroppableContext);
-  const descriptor = useMemo(() => ({
-    id: props.draggableId,
-    index: props.index,
-    type,
-    droppableId
-  }), [props.draggableId, props.index, type, droppableId]);
-
+  const { contextId, dragHandleUsageInstructionsId, registry } =
+    useRequiredContext(AppContext);
+  const { type, droppableId } = useRequiredContext(DroppableContext);
+  const descriptor = useMemo(
+    () => ({
+      id: props.draggableId,
+      index: props.index,
+      type,
+      droppableId,
+    }),
+    [props.draggableId, props.index, type, droppableId],
+  );
   const {
     children,
     draggableId,
@@ -6820,84 +7376,104 @@ const Draggable = props => {
     canDragInteractiveElements,
     isClone,
     mapped,
-    dropAnimationFinished: dropAnimationFinishedAction
+    dropAnimationFinished: dropAnimationFinishedAction,
   } = props;
-
   useValidation$1(props, contextId, getRef);
-
   useClonePropValidation(isClone);
   if (!isClone) {
-    const forPublisher = useMemo(() => ({
-      descriptor,
-      registry,
-      getDraggableRef: getRef,
-      canDragInteractiveElements,
-      shouldRespectForcePress,
-      isEnabled
-    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
+    const forPublisher = useMemo(
+      () => ({
+        descriptor,
+        registry,
+        getDraggableRef: getRef,
+        canDragInteractiveElements,
+        shouldRespectForcePress,
+        isEnabled,
+      }),
+      [
+        descriptor,
+        registry,
+        getRef,
+        canDragInteractiveElements,
+        shouldRespectForcePress,
+        isEnabled,
+      ],
+    );
     useDraggablePublisher(forPublisher);
   }
-
-  const dragHandleProps = useMemo(() => isEnabled ? {
-    tabIndex: 0,
-    role: 'button',
-    'aria-describedby': dragHandleUsageInstructionsId,
-    'data-rfd-drag-handle-draggable-id': draggableId,
-    'data-rfd-drag-handle-context-id': contextId,
-    draggable: false,
-    onDragStart: preventHtml5Dnd
-  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
-  const onMoveEnd = useCallback(event => {
-    if (mapped.type !== 'DRAGGING') {
-      return;
-    }
-    if (!mapped.dropping) {
-      return;
-    }
-
-    if (event.propertyName !== 'transform') {
-      return;
-    }
-    if (React.version.startsWith('16') || React.version.startsWith('17')) {
-      dropAnimationFinishedAction();
-    } else {
-      flushSync(dropAnimationFinishedAction);
-    }
-  }, [dropAnimationFinishedAction, mapped]);
+  const dragHandleProps = useMemo(
+    () =>
+      isEnabled
+        ? {
+            tabIndex: 0,
+            role: 'button',
+            'aria-describedby': dragHandleUsageInstructionsId,
+            'data-rfd-drag-handle-draggable-id': draggableId,
+            'data-rfd-drag-handle-context-id': contextId,
+            draggable: false,
+            onDragStart: preventHtml5Dnd,
+          }
+        : null,
+    [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled],
+  );
+  const onMoveEnd = useCallback(
+    (event) => {
+      if (mapped.type !== 'DRAGGING') {
+        return;
+      }
+      if (!mapped.dropping) {
+        return;
+      }
+      if (event.propertyName !== 'transform') {
+        return;
+      }
+      if (React.version.startsWith('16') || React.version.startsWith('17')) {
+        dropAnimationFinishedAction();
+      } else {
+        flushSync(dropAnimationFinishedAction);
+      }
+    },
+    [dropAnimationFinishedAction, mapped],
+  );
   const provided = useMemo(() => {
     const style = getStyle$1(mapped);
-    const onTransitionEnd = mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : undefined;
+    const onTransitionEnd =
+      mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : undefined;
     const result = {
       innerRef: setRef,
       draggableProps: {
         'data-rfd-draggable-context-id': contextId,
         'data-rfd-draggable-id': draggableId,
         style,
-        onTransitionEnd
+        onTransitionEnd,
       },
-      dragHandleProps
+      dragHandleProps,
     };
     return result;
   }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);
-  const rubric = useMemo(() => ({
-    draggableId: descriptor.id,
-    type: descriptor.type,
-    source: {
-      index: descriptor.index,
-      droppableId: descriptor.droppableId
-    }
-  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
-  return React.createElement(React.Fragment, null, children(provided, mapped.snapshot, rubric));
+  const rubric = useMemo(
+    () => ({
+      draggableId: descriptor.id,
+      type: descriptor.type,
+      source: {
+        index: descriptor.index,
+        droppableId: descriptor.droppableId,
+      },
+    }),
+    [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type],
+  );
+  return React.createElement(
+    React.Fragment,
+    null,
+    children(provided, mapped.snapshot, rubric),
+  );
 };
 var Draggable$1 = Draggable;
 
-var isStrictEqual = ((a, b) => a === b);
+var isStrictEqual = (a, b) => a === b;
 
-var whatIsDraggedOverFromResult = (result => {
-  const {
-    combine,
-    destination
-  } = result;
+var whatIsDraggedOverFromResult = (result) => {
+  const { combine, destination } = result;
   if (destination) {
     return destination.droppableId;
   }
@@ -6905,20 +7481,28 @@ var whatIsDraggedOverFromResult = (result => {
     return combine.droppableId;
   }
   return null;
-});
+};
 
-const getCombineWithFromResult = result => {
+const getCombineWithFromResult = (result) => {
   return result.combine ? result.combine.draggableId : null;
 };
-const getCombineWithFromImpact = impact => {
-  return impact.at && impact.at.type === 'COMBINE' ? impact.at.combine.draggableId : null;
+const getCombineWithFromImpact = (impact) => {
+  return impact.at && impact.at.type === 'COMBINE'
+    ? impact.at.combine.draggableId
+    : null;
 };
 function getDraggableSelector() {
   const memoizedOffset = memoizeOne((x, y) => ({
     x,
-    y
+    y,
   }));
-  const getMemoizedSnapshot = memoizeOne(function (mode, isClone, draggingOver, combineWith, dropping) {
+  const getMemoizedSnapshot = memoizeOne(function (
+    mode,
+    isClone,
+    draggingOver,
+    combineWith,
+    dropping,
+  ) {
     if (draggingOver === void 0) {
       draggingOver = null;
     }
@@ -6936,12 +7520,18 @@ function getDraggableSelector() {
       mode,
       draggingOver,
       combineWith,
-      combineTargetFor: null
+      combineTargetFor: null,
     };
   });
-  const getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone,
-  draggingOver,
-  combineWith, forceShouldAnimate) {
+  const getMemoizedProps = memoizeOne(function (
+    offset,
+    mode,
+    dimension,
+    isClone,
+    draggingOver,
+    combineWith,
+    forceShouldAnimate,
+  ) {
     if (draggingOver === void 0) {
       draggingOver = null;
     }
@@ -6961,8 +7551,14 @@ function getDraggableSelector() {
         offset,
         dimension,
         forceShouldAnimate,
-        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
-      }
+        snapshot: getMemoizedSnapshot(
+          mode,
+          isClone,
+          draggingOver,
+          combineWith,
+          null,
+        ),
+      },
     };
   });
   const selector = (state, ownProps) => {
@@ -6975,9 +7571,16 @@ function getDraggableSelector() {
       const draggingOver = whatIsDraggedOver(state.impact);
       const combineWith = getCombineWithFromImpact(state.impact);
       const forceShouldAnimate = state.forceShouldAnimate;
-      return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
+      return getMemoizedProps(
+        memoizedOffset(offset.x, offset.y),
+        state.movementMode,
+        dimension,
+        ownProps.isClone,
+        draggingOver,
+        combineWith,
+        forceShouldAnimate,
+      );
     }
-
     if (state.phase === 'DROP_ANIMATING') {
       const completed = state.completed;
       if (completed.result.draggableId !== ownProps.draggableId) {
@@ -6990,13 +7593,12 @@ function getDraggableSelector() {
       const draggingOver = whatIsDraggedOverFromResult(result);
       const combineWith = getCombineWithFromResult(result);
       const duration = state.dropDuration;
-
       const dropping = {
         duration,
         curve: curves.drop,
         moveTo: state.newHomeClientOffset,
         opacity: combineWith ? combine.opacity.drop : null,
-        scale: combineWith ? combine.scale.drop : null
+        scale: combineWith ? combine.scale.drop : null,
       };
       return {
         mapped: {
@@ -7008,8 +7610,14 @@ function getDraggableSelector() {
           combineWith,
           mode,
           forceShouldAnimate: null,
-          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)
-        }
+          snapshot: getMemoizedSnapshot(
+            mode,
+            isClone,
+            draggingOver,
+            combineWith,
+            dropping,
+          ),
+        },
       };
     }
     return null;
@@ -7028,7 +7636,7 @@ function getSecondarySnapshot(combineTargetFor) {
     mode: null,
     draggingOver: null,
     combineTargetFor,
-    combineWith: null
+    combineWith: null,
   };
 }
 const atRest = {
@@ -7037,17 +7645,20 @@ const atRest = {
     offset: origin,
     combineTargetFor: null,
     shouldAnimateDisplacement: true,
-    snapshot: getSecondarySnapshot(null)
-  }
+    snapshot: getSecondarySnapshot(null),
+  },
 };
 function getSecondarySelector() {
   const memoizedOffset = memoizeOne((x, y) => ({
     x,
-    y
+    y,
   }));
   const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
-  const getMemoizedProps = memoizeOne(function (offset,
-  combineTargetFor, shouldAnimateDisplacement) {
+  const getMemoizedProps = memoizeOne(function (
+    offset,
+    combineTargetFor,
+    shouldAnimateDisplacement,
+  ) {
     if (combineTargetFor === void 0) {
       combineTargetFor = null;
     }
@@ -7057,28 +7668,30 @@ function getSecondarySelector() {
         offset,
         combineTargetFor,
         shouldAnimateDisplacement,
-        snapshot: getMemoizedSnapshot(combineTargetFor)
-      }
+        snapshot: getMemoizedSnapshot(combineTargetFor),
+      },
     };
   });
-
-  const getFallback = combineTargetFor => {
-    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
+  const getFallback = (combineTargetFor) => {
+    return combineTargetFor
+      ? getMemoizedProps(origin, combineTargetFor, true)
+      : null;
   };
   const getProps = (ownId, draggingId, impact, afterCritical) => {
     const visualDisplacement = impact.displaced.visible[ownId];
-    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
+    const isAfterCriticalInVirtualList = Boolean(
+      afterCritical.inVirtualList && afterCritical.effected[ownId],
+    );
     const combine = tryGetCombine(impact);
-    const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;
+    const combineTargetFor =
+      combine && combine.draggableId === ownId ? draggingId : null;
     if (!visualDisplacement) {
       if (!isAfterCriticalInVirtualList) {
         return getFallback(combineTargetFor);
       }
-
       if (impact.displaced.invisible[ownId]) {
         return null;
       }
-
       const change = negate(afterCritical.displacedBy.point);
       const offset = memoizedOffset(change.x, change.y);
       return getMemoizedProps(offset, combineTargetFor, true);
@@ -7088,46 +7701,60 @@ function getSecondarySelector() {
     }
     const displaceBy = impact.displacedBy.point;
     const offset = memoizedOffset(displaceBy.x, displaceBy.y);
-    return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);
+    return getMemoizedProps(
+      offset,
+      combineTargetFor,
+      visualDisplacement.shouldAnimate,
+    );
   };
   const selector = (state, ownProps) => {
     if (isDragging(state)) {
       if (state.critical.draggable.id === ownProps.draggableId) {
         return null;
       }
-      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
+      return getProps(
+        ownProps.draggableId,
+        state.critical.draggable.id,
+        state.impact,
+        state.afterCritical,
+      );
     }
-
     if (state.phase === 'DROP_ANIMATING') {
       const completed = state.completed;
       if (completed.result.draggableId === ownProps.draggableId) {
         return null;
       }
-      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
+      return getProps(
+        ownProps.draggableId,
+        completed.result.draggableId,
+        completed.impact,
+        completed.afterCritical,
+      );
     }
-
     return null;
   };
   return selector;
 }
-
 const makeMapStateToProps$1 = () => {
   const draggingSelector = getDraggableSelector();
   const secondarySelector = getSecondarySelector();
-  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
+  const selector = (state, ownProps) =>
+    draggingSelector(state, ownProps) ||
+    secondarySelector(state, ownProps) ||
+    atRest;
   return selector;
 };
 const mapDispatchToProps$1 = {
-  dropAnimationFinished: dropAnimationFinished
+  dropAnimationFinished: dropAnimationFinished,
 };
-
 const ConnectedDraggable = connect(
-makeMapStateToProps$1, mapDispatchToProps$1,
-null,
-{
-  context: StoreContext,
-  areStatePropsEqual: isStrictEqual
-}
+  makeMapStateToProps$1,
+  mapDispatchToProps$1,
+  null,
+  {
+    context: StoreContext,
+    areStatePropsEqual: isStrictEqual,
+  },
 )(Draggable$1);
 var ConnectedDraggable$1 = ConnectedDraggable;
 
@@ -7139,54 +7766,64 @@ function PrivateDraggable(props) {
   }
   return React.createElement(ConnectedDraggable$1, props);
 }
-
 function PublicDraggable(props) {
-  const isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
-  const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
+  const isEnabled =
+    typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
+  const canDragInteractiveElements = Boolean(
+    props.disableInteractiveElementBlocking,
+  );
   const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
-  return React.createElement(PrivateDraggable, _extends({}, props, {
-    isClone: false,
-    isEnabled: isEnabled,
-    canDragInteractiveElements: canDragInteractiveElements,
-    shouldRespectForcePress: shouldRespectForcePress
-  }));
+  return React.createElement(
+    PrivateDraggable,
+    _extends({}, props, {
+      isClone: false,
+      isEnabled: isEnabled,
+      canDragInteractiveElements: canDragInteractiveElements,
+      shouldRespectForcePress: shouldRespectForcePress,
+    }),
+  );
 }
 
-const isEqual = base => value => base === value;
+const isEqual = (base) => (value) => base === value;
 const isScroll = isEqual('scroll');
 const isAuto = isEqual('auto');
 const isVisible = isEqual('visible');
-const isEither = (overflow, fn) => fn(overflow.overflowX) || fn(overflow.overflowY);
-const isBoth = (overflow, fn) => fn(overflow.overflowX) && fn(overflow.overflowY);
-const isElementScrollable = el => {
+const isEither = (overflow, fn) =>
+  fn(overflow.overflowX) || fn(overflow.overflowY);
+const isBoth = (overflow, fn) =>
+  fn(overflow.overflowX) && fn(overflow.overflowY);
+const isElementScrollable = (el) => {
   const style = window.getComputedStyle(el);
   const overflow = {
     overflowX: style.overflowX,
-    overflowY: style.overflowY
+    overflowY: style.overflowY,
   };
   return isEither(overflow, isScroll) || isEither(overflow, isAuto);
 };
-
 const isBodyScrollable = () => {
   if (process.env.NODE_ENV === 'production') {
     return false;
   }
   const body = getBodyElement();
   const html = document.documentElement;
-  !html ? process.env.NODE_ENV !== "production" ? invariant(false) : invariant(false) : void 0;
-
+  !html
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false)
+      : invariant(false)
+    : void 0;
   if (!isElementScrollable(body)) {
     return false;
   }
   const htmlStyle = window.getComputedStyle(html);
   const htmlOverflow = {
     overflowX: htmlStyle.overflowX,
-    overflowY: htmlStyle.overflowY
+    overflowY: htmlStyle.overflowY,
   };
   if (isBoth(htmlOverflow, isVisible)) {
     return false;
   }
-  process.env.NODE_ENV !== "production" ? warning(`
+  process.env.NODE_ENV !== 'production'
+    ? warning(`
     We have detected that your <body> element might be a scroll container.
     We have found no reliable way of detecting whether the <body> element is a scroll container.
     Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)
@@ -7195,30 +7832,28 @@ const isBodyScrollable = () => {
     we will be treating the <body> as *not* a scroll container
 
     More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md
-  `) : void 0;
+  `)
+    : void 0;
   return false;
 };
-const getClosestScrollable = el => {
+const getClosestScrollable = (el) => {
   if (el == null) {
     return null;
   }
-
   if (el === document.body) {
     return isBodyScrollable() ? el : null;
   }
-
   if (el === document.documentElement) {
     return null;
   }
   if (!isElementScrollable(el)) {
     return getClosestScrollable(el.parentElement);
   }
-
   return el;
 };
 var getClosestScrollable$1 = getClosestScrollable;
 
-var checkForNestedScrollContainers = (scrollable => {
+var checkForNestedScrollContainers = (scrollable) => {
   if (!scrollable) {
     return;
   }
@@ -7226,21 +7861,23 @@ var checkForNestedScrollContainers = (scrollable => {
   if (!anotherScrollParent) {
     return;
   }
-  process.env.NODE_ENV !== "production" ? warning(`
+  process.env.NODE_ENV !== 'production'
+    ? warning(`
     Droppable: unsupported nested scroll container detected.
     A Droppable can only have one scroll parent (which can be itself)
     Nested scroll containers are currently not supported.
 
     We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131
-  `) : void 0;
-});
+  `)
+    : void 0;
+};
 
-var getScroll = (el => ({
+var getScroll = (el) => ({
   x: el.scrollLeft,
-  y: el.scrollTop
-}));
+  y: el.scrollTop,
+});
 
-const getIsFixed = el => {
+const getIsFixed = (el) => {
   if (!el) {
     return false;
   }
@@ -7250,16 +7887,16 @@ const getIsFixed = el => {
   }
   return getIsFixed(el.parentElement);
 };
-var getEnv = (start => {
+var getEnv = (start) => {
   const closestScrollable = getClosestScrollable$1(start);
   const isFixedOnPage = getIsFixed(start);
   return {
     closestScrollable,
-    isFixedOnPage
+    isFixedOnPage,
   };
-});
+};
 
-var getDroppableDimension = (_ref => {
+var getDroppableDimension = (_ref) => {
   let {
     descriptor,
     isEnabled,
@@ -7268,22 +7905,18 @@ var getDroppableDimension = (_ref => {
     direction,
     client,
     page,
-    closest
+    closest,
   } = _ref;
   const frame = (() => {
     if (!closest) {
       return null;
     }
-    const {
-      scrollSize,
-      client: frameClient
-    } = closest;
-
+    const { scrollSize, client: frameClient } = closest;
     const maxScroll = getMaxScroll({
       scrollHeight: scrollSize.scrollHeight,
       scrollWidth: scrollSize.scrollWidth,
       height: frameClient.paddingBox.height,
-      width: frameClient.paddingBox.width
+      width: frameClient.paddingBox.width,
     });
     return {
       pageMarginBox: closest.page.marginBox,
@@ -7296,9 +7929,9 @@ var getDroppableDimension = (_ref => {
         max: maxScroll,
         diff: {
           value: origin,
-          displacement: origin
-        }
-      }
+          displacement: origin,
+        },
+      },
     };
   })();
   const axis = direction === 'vertical' ? vertical : horizontal;
@@ -7306,7 +7939,7 @@ var getDroppableDimension = (_ref => {
     page,
     withPlaceholder: null,
     axis,
-    frame
+    frame,
   });
   const dimension = {
     descriptor,
@@ -7317,45 +7950,39 @@ var getDroppableDimension = (_ref => {
     client,
     page,
     frame,
-    subject
+    subject,
   };
   return dimension;
-});
+};
 
 const getClient = (targetRef, closestScrollable) => {
   const base = getBox(targetRef);
-
   if (!closestScrollable) {
     return base;
   }
-
   if (targetRef !== closestScrollable) {
     return base;
   }
-
   const top = base.paddingBox.top - closestScrollable.scrollTop;
   const left = base.paddingBox.left - closestScrollable.scrollLeft;
   const bottom = top + closestScrollable.scrollHeight;
   const right = left + closestScrollable.scrollWidth;
-
   const paddingBox = {
     top,
     right,
     bottom,
-    left
+    left,
   };
-
   const borderBox = expand(paddingBox, base.border);
-
   const client = createBox({
     borderBox,
     margin: base.margin,
     border: base.border,
-    padding: base.padding
+    padding: base.padding,
   });
   return client;
 };
-var getDimension = (_ref => {
+var getDimension = (_ref) => {
   let {
     ref,
     descriptor,
@@ -7364,7 +7991,7 @@ var getDimension = (_ref => {
     direction,
     isDropDisabled,
     isCombineEnabled,
-    shouldClipSubject
+    shouldClipSubject,
   } = _ref;
   const closestScrollable = env.closestScrollable;
   const client = getClient(ref, closestScrollable);
@@ -7376,14 +8003,14 @@ var getDimension = (_ref => {
     const frameClient = getBox(closestScrollable);
     const scrollSize = {
       scrollHeight: closestScrollable.scrollHeight,
-      scrollWidth: closestScrollable.scrollWidth
+      scrollWidth: closestScrollable.scrollWidth,
     };
     return {
       client: frameClient,
       page: withScroll(frameClient, windowScroll),
       scroll: getScroll(closestScrollable),
       scrollSize,
-      shouldClipSubject
+      shouldClipSubject,
     };
   })();
   const dimension = getDroppableDimension({
@@ -7394,43 +8021,53 @@ var getDimension = (_ref => {
     direction,
     client,
     page,
-    closest
+    closest,
   });
   return dimension;
-});
+};
 
 const immediate = {
-  passive: false
+  passive: false,
 };
 const delayed = {
-  passive: true
+  passive: true,
 };
-var getListenerOptions = (options => options.shouldPublishImmediately ? immediate : delayed);
+var getListenerOptions = (options) =>
+  options.shouldPublishImmediately ? immediate : delayed;
 
-const getClosestScrollableFromDrag = dragging => dragging && dragging.env.closestScrollable || null;
+const getClosestScrollableFromDrag = (dragging) =>
+  (dragging && dragging.env.closestScrollable) || null;
 function useDroppablePublisher(args) {
   const whileDraggingRef = useRef(null);
   const appContext = useRequiredContext(AppContext);
   const uniqueId = useUniqueId$1('droppable');
-  const {
-    registry,
-    marshal
-  } = appContext;
+  const { registry, marshal } = appContext;
   const previousRef = usePrevious(args);
-  const descriptor = useMemo(() => ({
-    id: args.droppableId,
-    type: args.type,
-    mode: args.mode
-  }), [args.droppableId, args.mode, args.type]);
+  const descriptor = useMemo(
+    () => ({
+      id: args.droppableId,
+      type: args.type,
+      mode: args.mode,
+    }),
+    [args.droppableId, args.mode, args.type],
+  );
   const publishedDescriptorRef = useRef(descriptor);
-  const memoizedUpdateScroll = useMemo(() => memoizeOne((x, y) => {
-    !whileDraggingRef.current ? process.env.NODE_ENV !== "production" ? invariant(false, 'Can only update scroll when dragging') : invariant(false) : void 0;
-    const scroll = {
-      x,
-      y
-    };
-    marshal.updateDroppableScroll(descriptor.id, scroll);
-  }), [descriptor.id, marshal]);
+  const memoizedUpdateScroll = useMemo(
+    () =>
+      memoizeOne((x, y) => {
+        !whileDraggingRef.current
+          ? process.env.NODE_ENV !== 'production'
+            ? invariant(false, 'Can only update scroll when dragging')
+            : invariant(false)
+          : void 0;
+        const scroll = {
+          x,
+          y,
+        };
+        marshal.updateDroppableScroll(descriptor.id, scroll);
+      }),
+    [descriptor.id, marshal],
+  );
   const getClosestScroll = useCallback(() => {
     const dragging = whileDraggingRef.current;
     if (!dragging || !dragging.env.closestScrollable) {
@@ -7442,11 +8079,18 @@ function useDroppablePublisher(args) {
     const scroll = getClosestScroll();
     memoizedUpdateScroll(scroll.x, scroll.y);
   }, [getClosestScroll, memoizedUpdateScroll]);
-  const scheduleScrollUpdate = useMemo(() => rafSchd(updateScroll), [updateScroll]);
+  const scheduleScrollUpdate = useMemo(
+    () => rafSchd(updateScroll),
+    [updateScroll],
+  );
   const onClosestScroll = useCallback(() => {
     const dragging = whileDraggingRef.current;
     const closest = getClosestScrollableFromDrag(dragging);
-    !(dragging && closest) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find scroll options while scrolling') : invariant(false) : void 0;
+    !(dragging && closest)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Could not find scroll options while scrolling')
+        : invariant(false)
+      : void 0;
     const options = dragging.scrollOptions;
     if (options.shouldPublishImmediately) {
       updateScroll();
@@ -7454,67 +8098,109 @@ function useDroppablePublisher(args) {
     }
     scheduleScrollUpdate();
   }, [scheduleScrollUpdate, updateScroll]);
-  const getDimensionAndWatchScroll = useCallback((windowScroll, options) => {
-    !!whileDraggingRef.current ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot collect a droppable while a drag is occurring') : invariant(false) : void 0;
-    const previous = previousRef.current;
-    const ref = previous.getDroppableRef();
-    !ref ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot collect without a droppable ref') : invariant(false) : void 0;
-    const env = getEnv(ref);
-    const dragging = {
-      ref,
-      descriptor,
-      env,
-      scrollOptions: options
-    };
-    whileDraggingRef.current = dragging;
-    const dimension = getDimension({
-      ref,
-      descriptor,
-      env,
-      windowScroll,
-      direction: previous.direction,
-      isDropDisabled: previous.isDropDisabled,
-      isCombineEnabled: previous.isCombineEnabled,
-      shouldClipSubject: !previous.ignoreContainerClipping
-    });
-    const scrollable = env.closestScrollable;
-    if (scrollable) {
-      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
-
-      scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
-      if (process.env.NODE_ENV !== 'production') {
-        checkForNestedScrollContainers(scrollable);
+  const getDimensionAndWatchScroll = useCallback(
+    (windowScroll, options) => {
+      !!whileDraggingRef.current
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(
+              false,
+              'Cannot collect a droppable while a drag is occurring',
+            )
+          : invariant(false)
+        : void 0;
+      const previous = previousRef.current;
+      const ref = previous.getDroppableRef();
+      !ref
+        ? process.env.NODE_ENV !== 'production'
+          ? invariant(false, 'Cannot collect without a droppable ref')
+          : invariant(false)
+        : void 0;
+      const env = getEnv(ref);
+      const dragging = {
+        ref,
+        descriptor,
+        env,
+        scrollOptions: options,
+      };
+      whileDraggingRef.current = dragging;
+      const dimension = getDimension({
+        ref,
+        descriptor,
+        env,
+        windowScroll,
+        direction: previous.direction,
+        isDropDisabled: previous.isDropDisabled,
+        isCombineEnabled: previous.isCombineEnabled,
+        shouldClipSubject: !previous.ignoreContainerClipping,
+      });
+      const scrollable = env.closestScrollable;
+      if (scrollable) {
+        scrollable.setAttribute(
+          scrollContainer.contextId,
+          appContext.contextId,
+        );
+        scrollable.addEventListener(
+          'scroll',
+          onClosestScroll,
+          getListenerOptions(dragging.scrollOptions),
+        );
+        if (process.env.NODE_ENV !== 'production') {
+          checkForNestedScrollContainers(scrollable);
+        }
       }
-    }
-    return dimension;
-  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
+      return dimension;
+    },
+    [appContext.contextId, descriptor, onClosestScroll, previousRef],
+  );
   const getScrollWhileDragging = useCallback(() => {
     const dragging = whileDraggingRef.current;
     const closest = getClosestScrollableFromDrag(dragging);
-    !(dragging && closest) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Can only recollect Droppable client for Droppables that have a scroll container') : invariant(false) : void 0;
+    !(dragging && closest)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Can only recollect Droppable client for Droppables that have a scroll container',
+          )
+        : invariant(false)
+      : void 0;
     return getScroll(closest);
   }, []);
   const dragStopped = useCallback(() => {
     const dragging = whileDraggingRef.current;
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot stop drag when no active drag') : invariant(false) : void 0;
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot stop drag when no active drag')
+        : invariant(false)
+      : void 0;
     const closest = getClosestScrollableFromDrag(dragging);
-
     whileDraggingRef.current = null;
     if (!closest) {
       return;
     }
-
     scheduleScrollUpdate.cancel();
     closest.removeAttribute(scrollContainer.contextId);
-    closest.removeEventListener('scroll', onClosestScroll,
-    getListenerOptions(dragging.scrollOptions));
+    closest.removeEventListener(
+      'scroll',
+      onClosestScroll,
+      getListenerOptions(dragging.scrollOptions),
+    );
   }, [onClosestScroll, scheduleScrollUpdate]);
-  const scroll = useCallback(change => {
+  const scroll = useCallback((change) => {
     const dragging = whileDraggingRef.current;
-    !dragging ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot scroll when there is no drag') : invariant(false) : void 0;
+    !dragging
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Cannot scroll when there is no drag')
+        : invariant(false)
+      : void 0;
     const closest = getClosestScrollableFromDrag(dragging);
-    !closest ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot scroll a droppable with no closest scrollable') : invariant(false) : void 0;
-
+    !closest
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Cannot scroll a droppable with no closest scrollable',
+          )
+        : invariant(false)
+      : void 0;
     closest.scrollTop += change.y;
     closest.scrollLeft += change.x;
   }, []);
@@ -7523,39 +8209,49 @@ function useDroppablePublisher(args) {
       getDimensionAndWatchScroll,
       getScrollWhileDragging,
       dragStopped,
-      scroll
+      scroll,
     };
   }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll]);
-  const entry = useMemo(() => ({
-    uniqueId,
-    descriptor,
-    callbacks
-  }), [callbacks, descriptor, uniqueId]);
-
+  const entry = useMemo(
+    () => ({
+      uniqueId,
+      descriptor,
+      callbacks,
+    }),
+    [callbacks, descriptor, uniqueId],
+  );
   useLayoutEffect(() => {
     publishedDescriptorRef.current = entry.descriptor;
     registry.droppable.register(entry);
     return () => {
       if (whileDraggingRef.current) {
-        process.env.NODE_ENV !== "production" ? warning('Unsupported: changing the droppableId or type of a Droppable during a drag') : void 0;
+        process.env.NODE_ENV !== 'production'
+          ? warning(
+              'Unsupported: changing the droppableId or type of a Droppable during a drag',
+            )
+          : void 0;
         dragStopped();
       }
       registry.droppable.unregister(entry);
     };
   }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
-
   useLayoutEffect(() => {
     if (!whileDraggingRef.current) {
       return;
     }
-    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
+    marshal.updateDroppableIsEnabled(
+      publishedDescriptorRef.current.id,
+      !args.isDropDisabled,
+    );
   }, [args.isDropDisabled, marshal]);
-
   useLayoutEffect(() => {
     if (!whileDraggingRef.current) {
       return;
     }
-    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
+    marshal.updateDroppableIsCombineEnabled(
+      publishedDescriptorRef.current.id,
+      args.isCombineEnabled,
+    );
   }, [args.isCombineEnabled, marshal]);
 }
 
@@ -7563,14 +8259,10 @@ function noop() {}
 const empty = {
   width: 0,
   height: 0,
-  margin: noSpacing
+  margin: noSpacing,
 };
-const getSize = _ref => {
-  let {
-    isAnimatingOpenOnMount,
-    placeholder,
-    animate
-  } = _ref;
+const getSize = (_ref) => {
+  let { isAnimatingOpenOnMount, placeholder, animate } = _ref;
   if (isAnimatingOpenOnMount) {
     return empty;
   }
@@ -7580,23 +8272,18 @@ const getSize = _ref => {
   return {
     height: placeholder.client.borderBox.height,
     width: placeholder.client.borderBox.width,
-    margin: placeholder.client.margin
+    margin: placeholder.client.margin,
   };
 };
-const getStyle = _ref2 => {
-  let {
-    isAnimatingOpenOnMount,
-    placeholder,
-    animate
-  } = _ref2;
+const getStyle = (_ref2) => {
+  let { isAnimatingOpenOnMount, placeholder, animate } = _ref2;
   const size = getSize({
     isAnimatingOpenOnMount,
     placeholder,
-    animate
+    animate,
   });
   return {
     display: placeholder.display,
-
     boxSizing: 'border-box',
     width: size.width,
     height: size.height,
@@ -7607,10 +8294,10 @@ const getStyle = _ref2 => {
     flexShrink: '0',
     flexGrow: '0',
     pointerEvents: 'none',
-    transition: animate !== 'none' ? transitions.placeholder : null
+    transition: animate !== 'none' ? transitions.placeholder : null,
   };
 };
-const Placeholder = props => {
+const Placeholder = (props) => {
   const animateOpenTimerRef = useRef(null);
   const tryClearAnimateOpenTimer = useCallback(() => {
     if (!animateOpenTimerRef.current) {
@@ -7619,25 +8306,19 @@ const Placeholder = props => {
     clearTimeout(animateOpenTimerRef.current);
     animateOpenTimerRef.current = null;
   }, []);
-  const {
-    animate,
-    onTransitionEnd,
-    onClose,
-    contextId
-  } = props;
-  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = useState(props.animate === 'open');
-
+  const { animate, onTransitionEnd, onClose, contextId } = props;
+  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = useState(
+    props.animate === 'open',
+  );
   useEffect(() => {
     if (!isAnimatingOpenOnMount) {
       return noop;
     }
-
     if (animate !== 'open') {
       tryClearAnimateOpenTimer();
       setIsAnimatingOpenOnMount(false);
       return noop;
     }
-
     if (animateOpenTimerRef.current) {
       return noop;
     }
@@ -7645,28 +8326,30 @@ const Placeholder = props => {
       animateOpenTimerRef.current = null;
       setIsAnimatingOpenOnMount(false);
     });
-
     return tryClearAnimateOpenTimer;
   }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
-  const onSizeChangeEnd = useCallback(event => {
-    if (event.propertyName !== 'height') {
-      return;
-    }
-    onTransitionEnd();
-    if (animate === 'close') {
-      onClose();
-    }
-  }, [animate, onClose, onTransitionEnd]);
+  const onSizeChangeEnd = useCallback(
+    (event) => {
+      if (event.propertyName !== 'height') {
+        return;
+      }
+      onTransitionEnd();
+      if (animate === 'close') {
+        onClose();
+      }
+    },
+    [animate, onClose, onTransitionEnd],
+  );
   const style = getStyle({
     isAnimatingOpenOnMount,
     animate: props.animate,
-    placeholder: props.placeholder
+    placeholder: props.placeholder,
   });
   return React.createElement(props.placeholder.tagName, {
     style,
     'data-rfd-placeholder-context-id': contextId,
     onTransitionEnd: onSizeChangeEnd,
-    ref: props.innerRef
+    ref: props.innerRef,
   });
 };
 var Placeholder$1 = React.memo(Placeholder);
@@ -7675,58 +8358,90 @@ function isBoolean(value) {
   return typeof value === 'boolean';
 }
 function runChecks(args, checks) {
-  checks.forEach(check => check(args));
+  checks.forEach((check) => check(args));
 }
-const shared = [function required(_ref) {
-  let {
-    props
-  } = _ref;
-  !props.droppableId ? process.env.NODE_ENV !== "production" ? invariant(false, 'A Droppable requires a droppableId prop') : invariant(false) : void 0;
-  !(typeof props.droppableId === 'string') ? process.env.NODE_ENV !== "production" ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : invariant(false) : void 0;
-}, function boolean(_ref2) {
-  let {
-    props
-  } = _ref2;
-  !isBoolean(props.isDropDisabled) ? process.env.NODE_ENV !== "production" ? invariant(false, 'isDropDisabled must be a boolean') : invariant(false) : void 0;
-  !isBoolean(props.isCombineEnabled) ? process.env.NODE_ENV !== "production" ? invariant(false, 'isCombineEnabled must be a boolean') : invariant(false) : void 0;
-  !isBoolean(props.ignoreContainerClipping) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ignoreContainerClipping must be a boolean') : invariant(false) : void 0;
-}, function ref(_ref3) {
-  let {
-    getDroppableRef
-  } = _ref3;
-  checkIsValidInnerRef(getDroppableRef());
-}];
-const standard = [function placeholder(_ref4) {
-  let {
-    props,
-    getPlaceholderRef
-  } = _ref4;
-  if (!props.placeholder) {
-    return;
-  }
-  const ref = getPlaceholderRef();
-  if (ref) {
-    return;
-  }
-  process.env.NODE_ENV !== "production" ? warning(`
+const shared = [
+  function required(_ref) {
+    let { props } = _ref;
+    !props.droppableId
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'A Droppable requires a droppableId prop')
+        : invariant(false)
+      : void 0;
+    !(typeof props.droppableId === 'string')
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`,
+          )
+        : invariant(false)
+      : void 0;
+  },
+  function boolean(_ref2) {
+    let { props } = _ref2;
+    !isBoolean(props.isDropDisabled)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'isDropDisabled must be a boolean')
+        : invariant(false)
+      : void 0;
+    !isBoolean(props.isCombineEnabled)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'isCombineEnabled must be a boolean')
+        : invariant(false)
+      : void 0;
+    !isBoolean(props.ignoreContainerClipping)
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'ignoreContainerClipping must be a boolean')
+        : invariant(false)
+      : void 0;
+  },
+  function ref(_ref3) {
+    let { getDroppableRef } = _ref3;
+    checkIsValidInnerRef(getDroppableRef());
+  },
+];
+const standard = [
+  function placeholder(_ref4) {
+    let { props, getPlaceholderRef } = _ref4;
+    if (!props.placeholder) {
+      return;
+    }
+    const ref = getPlaceholderRef();
+    if (ref) {
+      return;
+    }
+    process.env.NODE_ENV !== 'production'
+      ? warning(`
       Droppable setup issue [droppableId: "${props.droppableId}"]:
       DroppableProvided > placeholder could not be found.
 
       Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.
       More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md
-    `) : void 0;
-}];
-const virtual = [function hasClone(_ref5) {
-  let {
-    props
-  } = _ref5;
-  !props.renderClone ? process.env.NODE_ENV !== "production" ? invariant(false, 'Must provide a clone render function (renderClone) for virtual lists') : invariant(false) : void 0;
-}, function hasNoPlaceholder(_ref6) {
-  let {
-    getPlaceholderRef
-  } = _ref6;
-  !!getPlaceholderRef() ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected virtual list to not have a placeholder') : invariant(false) : void 0;
-}];
+    `)
+      : void 0;
+  },
+];
+const virtual = [
+  function hasClone(_ref5) {
+    let { props } = _ref5;
+    !props.renderClone
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(
+            false,
+            'Must provide a clone render function (renderClone) for virtual lists',
+          )
+        : invariant(false)
+      : void 0;
+  },
+  function hasNoPlaceholder(_ref6) {
+    let { getPlaceholderRef } = _ref6;
+    !!getPlaceholderRef()
+      ? process.env.NODE_ENV !== 'production'
+        ? invariant(false, 'Expected virtual list to not have a placeholder')
+        : invariant(false)
+      : void 0;
+  },
+];
 function useValidation(args) {
   useDevSetupWarning(() => {
     runChecks(args, shared);
@@ -7745,14 +8460,14 @@ class AnimateInOut extends React.PureComponent {
     this.state = {
       isVisible: Boolean(this.props.on),
       data: this.props.on,
-      animate: this.props.shouldAnimate && this.props.on ? 'open' : 'none'
+      animate: this.props.shouldAnimate && this.props.on ? 'open' : 'none',
     };
     this.onClose = () => {
       if (this.state.animate !== 'close') {
         return;
       }
       this.setState({
-        isVisible: false
+        isVisible: false,
       });
     };
   }
@@ -7761,30 +8476,27 @@ class AnimateInOut extends React.PureComponent {
       return {
         isVisible: Boolean(props.on),
         data: props.on,
-        animate: 'none'
+        animate: 'none',
       };
     }
-
     if (props.on) {
       return {
         isVisible: true,
         data: props.on,
-        animate: 'open'
+        animate: 'open',
       };
     }
-
     if (state.isVisible) {
       return {
         isVisible: true,
         data: state.data,
-        animate: 'close'
+        animate: 'close',
       };
     }
-
     return {
       isVisible: false,
       animate: 'close',
-      data: null
+      data: null,
     };
   }
   render() {
@@ -7794,19 +8506,20 @@ class AnimateInOut extends React.PureComponent {
     const provided = {
       onClose: this.onClose,
       data: this.state.data,
-      animate: this.state.animate
+      animate: this.state.animate,
     };
     return this.props.children(provided);
   }
 }
 
-const Droppable = props => {
+const Droppable = (props) => {
   const appContext = useContext(AppContext);
-  !appContext ? process.env.NODE_ENV !== "production" ? invariant(false, 'Could not find app context') : invariant(false) : void 0;
-  const {
-    contextId,
-    isMovementAllowed
-  } = appContext;
+  !appContext
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'Could not find app context')
+      : invariant(false)
+    : void 0;
+  const { contextId, isMovementAllowed } = appContext;
   const droppableRef = useRef(null);
   const placeholderRef = useRef(null);
   const {
@@ -7821,7 +8534,7 @@ const Droppable = props => {
     snapshot,
     useClone,
     updateViewportMaxScroll,
-    getContainerForClone
+    getContainerForClone,
   } = props;
   const getDroppableRef = useCallback(() => droppableRef.current, []);
   const setDroppableRef = useCallback(function (value) {
@@ -7840,12 +8553,12 @@ const Droppable = props => {
   useValidation({
     props,
     getDroppableRef,
-    getPlaceholderRef
+    getPlaceholderRef,
   });
   const onPlaceholderTransitionEnd = useCallback(() => {
     if (isMovementAllowed()) {
       updateViewportMaxScroll({
-        maxScroll: getMaxWindowScroll()
+        maxScroll: getMaxWindowScroll(),
       });
     }
   }, [isMovementAllowed, updateViewportMaxScroll]);
@@ -7857,68 +8570,108 @@ const Droppable = props => {
     isDropDisabled,
     isCombineEnabled,
     ignoreContainerClipping,
-    getDroppableRef
+    getDroppableRef,
   });
-  const placeholder = useMemo(() => React.createElement(AnimateInOut, {
-    on: props.placeholder,
-    shouldAnimate: props.shouldAnimatePlaceholder
-  }, _ref => {
-    let {
-      onClose,
-      data,
-      animate
-    } = _ref;
-    return React.createElement(Placeholder$1, {
-      placeholder: data,
-      onClose: onClose,
-      innerRef: setPlaceholderRef,
-      animate: animate,
-      contextId: contextId,
-      onTransitionEnd: onPlaceholderTransitionEnd
-    });
-  }), [contextId, onPlaceholderTransitionEnd, props.placeholder, props.shouldAnimatePlaceholder, setPlaceholderRef]);
-  const provided = useMemo(() => ({
-    innerRef: setDroppableRef,
-    placeholder,
-    droppableProps: {
-      'data-rfd-droppable-id': droppableId,
-      'data-rfd-droppable-context-id': contextId
-    }
-  }), [contextId, droppableId, placeholder, setDroppableRef]);
+  const placeholder = useMemo(
+    () =>
+      React.createElement(
+        AnimateInOut,
+        {
+          on: props.placeholder,
+          shouldAnimate: props.shouldAnimatePlaceholder,
+        },
+        (_ref) => {
+          let { onClose, data, animate } = _ref;
+          return React.createElement(Placeholder$1, {
+            placeholder: data,
+            onClose: onClose,
+            innerRef: setPlaceholderRef,
+            animate: animate,
+            contextId: contextId,
+            onTransitionEnd: onPlaceholderTransitionEnd,
+          });
+        },
+      ),
+    [
+      contextId,
+      onPlaceholderTransitionEnd,
+      props.placeholder,
+      props.shouldAnimatePlaceholder,
+      setPlaceholderRef,
+    ],
+  );
+  const provided = useMemo(
+    () => ({
+      innerRef: setDroppableRef,
+      placeholder,
+      droppableProps: {
+        'data-rfd-droppable-id': droppableId,
+        'data-rfd-droppable-context-id': contextId,
+      },
+    }),
+    [contextId, droppableId, placeholder, setDroppableRef],
+  );
   const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
-  const droppableContext = useMemo(() => ({
-    droppableId,
-    type,
-    isUsingCloneFor
-  }), [droppableId, isUsingCloneFor, type]);
+  const droppableContext = useMemo(
+    () => ({
+      droppableId,
+      type,
+      isUsingCloneFor,
+    }),
+    [droppableId, isUsingCloneFor, type],
+  );
   function getClone() {
     if (!useClone) {
       return null;
     }
-    const {
-      dragging,
-      render
-    } = useClone;
-    const node = React.createElement(PrivateDraggable, {
-      draggableId: dragging.draggableId,
-      index: dragging.source.index,
-      isClone: true,
-      isEnabled: true
-      ,
-      shouldRespectForcePress: false,
-      canDragInteractiveElements: true
-    }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));
+    const { dragging, render } = useClone;
+    const node = React.createElement(
+      PrivateDraggable,
+      {
+        draggableId: dragging.draggableId,
+        index: dragging.source.index,
+        isClone: true,
+        isEnabled: true,
+        shouldRespectForcePress: false,
+        canDragInteractiveElements: true,
+      },
+      (draggableProvided, draggableSnapshot) =>
+        render(draggableProvided, draggableSnapshot, dragging),
+    );
     return ReactDOM.createPortal(node, getContainerForClone());
   }
-  return React.createElement(DroppableContext.Provider, {
-    value: droppableContext
-  }, children(provided, snapshot), getClone());
+  return React.createElement(
+    DroppableContext.Provider,
+    {
+      value: droppableContext,
+    },
+    children(provided, snapshot),
+    getClone(),
+  );
 };
 var Droppable$1 = Droppable;
 
 const isMatchingType = (type, critical) => type === critical.droppable.type;
-const getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
-
+const getDraggable = (critical, dimensions) =>
+  dimensions.draggables[critical.draggable.id];
+function getBody() {
+  !document.body
+    ? process.env.NODE_ENV !== 'production'
+      ? invariant(false, 'document.body is not ready')
+      : invariant(false)
+    : void 0;
+  return document.body;
+}
+const defaultProps = {
+  mode: 'standard',
+  type: 'DEFAULT',
+  direction: 'vertical',
+  isDropDisabled: false,
+  isCombineEnabled: false,
+  ignoreContainerClipping: false,
+  renderClone: null,
+  getContainerForClone: getBody,
+};
 const makeMapStateToProps = () => {
   const idleWithAnimation = {
     placeholder: null,
@@ -7927,69 +8680,82 @@ const makeMapStateToProps = () => {
       isDraggingOver: false,
       draggingOverWith: null,
       draggingFromThisWith: null,
-      isUsingPlaceholder: false
+      isUsingPlaceholder: false,
     },
-    useClone: null
+    useClone: null,
   };
   const idleWithoutAnimation = {
     ...idleWithAnimation,
-    shouldAnimatePlaceholder: false
+    shouldAnimatePlaceholder: false,
   };
-  const getDraggableRubric = memoizeOne(descriptor => ({
+  const getDraggableRubric = memoizeOne((descriptor) => ({
     draggableId: descriptor.id,
     type: descriptor.type,
     source: {
       index: descriptor.index,
-      droppableId: descriptor.droppableId
-    }
+      droppableId: descriptor.droppableId,
+    },
   }));
-  const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
-    const draggableId = dragging.descriptor.id;
-    const isHome = dragging.descriptor.droppableId === id;
-    if (isHome) {
-      const useClone = renderClone ? {
-        render: renderClone,
-        dragging: getDraggableRubric(dragging.descriptor)
-      } : null;
+  const getMapProps = memoizeOne(
+    (
+      id,
+      isEnabled,
+      isDraggingOverForConsumer,
+      isDraggingOverForImpact,
+      dragging,
+      renderClone,
+    ) => {
+      const draggableId = dragging.descriptor.id;
+      const isHome = dragging.descriptor.droppableId === id;
+      if (isHome) {
+        const useClone = renderClone
+          ? {
+              render: renderClone,
+              dragging: getDraggableRubric(dragging.descriptor),
+            }
+          : null;
+        const snapshot = {
+          isDraggingOver: isDraggingOverForConsumer,
+          draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
+          draggingFromThisWith: draggableId,
+          isUsingPlaceholder: true,
+        };
+        return {
+          placeholder: dragging.placeholder,
+          shouldAnimatePlaceholder: false,
+          snapshot,
+          useClone,
+        };
+      }
+      if (!isEnabled) {
+        return idleWithoutAnimation;
+      }
+      if (!isDraggingOverForImpact) {
+        return idleWithAnimation;
+      }
       const snapshot = {
         isDraggingOver: isDraggingOverForConsumer,
-        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
-        draggingFromThisWith: draggableId,
-        isUsingPlaceholder: true
+        draggingOverWith: draggableId,
+        draggingFromThisWith: null,
+        isUsingPlaceholder: true,
       };
       return {
         placeholder: dragging.placeholder,
-        shouldAnimatePlaceholder: false,
+        shouldAnimatePlaceholder: true,
         snapshot,
-        useClone
+        useClone: null,
       };
-    }
-    if (!isEnabled) {
-      return idleWithoutAnimation;
-    }
-
-    if (!isDraggingOverForImpact) {
-      return idleWithAnimation;
-    }
-    const snapshot = {
-      isDraggingOver: isDraggingOverForConsumer,
-      draggingOverWith: draggableId,
-      draggingFromThisWith: null,
-      isUsingPlaceholder: true
-    };
-    return {
-      placeholder: dragging.placeholder,
-      shouldAnimatePlaceholder: true,
-      snapshot,
-      useClone: null
-    };
-  });
-  const selector = (state, ownProps) => {
-
-    const id = ownProps.droppableId;
-    const type = ownProps.type;
-    const isEnabled = !ownProps.isDropDisabled;
-    const renderClone = ownProps.renderClone;
+    },
+  );
+  const selector = (state, _ref) => {
+    let {
+      droppableId,
+      type = defaultProps.type,
+      isDropDisabled = defaultProps.isDropDisabled,
+      renderClone = defaultProps.renderClone,
+    } = _ref;
+    const id = droppableId;
+    const isEnabled = !isDropDisabled;
     if (isDragging(state)) {
       const critical = state.critical;
       if (!isMatchingType(type, critical)) {
@@ -7997,7 +8763,14 @@ const makeMapStateToProps = () => {
       }
       const dragging = getDraggable(critical, state.dimensions);
       const isDraggingOver = whatIsDraggedOver(state.impact) === id;
-      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
+      return getMapProps(
+        id,
+        isEnabled,
+        isDraggingOver,
+        isDraggingOver,
+        dragging,
+        renderClone,
+      );
     }
     if (state.phase === 'DROP_ANIMATING') {
       const completed = state.completed;
@@ -8005,59 +8778,69 @@ const makeMapStateToProps = () => {
         return idleWithoutAnimation;
       }
       const dragging = getDraggable(completed.critical, state.dimensions);
-
-      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);
+      return getMapProps(
+        id,
+        isEnabled,
+        whatIsDraggedOverFromResult(completed.result) === id,
+        whatIsDraggedOver(completed.impact) === id,
+        dragging,
+        renderClone,
+      );
     }
     if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {
       const completed = state.completed;
       if (!isMatchingType(type, completed.critical)) {
         return idleWithoutAnimation;
       }
-
       const wasOver = whatIsDraggedOver(completed.impact) === id;
-      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === 'COMBINE');
+      const wasCombining = Boolean(
+        completed.impact.at && completed.impact.at.type === 'COMBINE',
+      );
       const isHome = completed.critical.droppable.id === id;
       if (wasOver) {
         return wasCombining ? idleWithAnimation : idleWithoutAnimation;
       }
-
       if (isHome) {
         return idleWithAnimation;
       }
       return idleWithoutAnimation;
     }
-
     return idleWithoutAnimation;
   };
   return selector;
 };
 const mapDispatchToProps = {
-  updateViewportMaxScroll: updateViewportMaxScroll
-};
-function getBody() {
-  !document.body ? process.env.NODE_ENV !== "production" ? invariant(false, 'document.body is not ready') : invariant(false) : void 0;
-  return document.body;
-}
-const defaultProps = {
-  mode: 'standard',
-  type: 'DEFAULT',
-  direction: 'vertical',
-  isDropDisabled: false,
-  isCombineEnabled: false,
-  ignoreContainerClipping: false,
-  renderClone: null,
-  getContainerForClone: getBody
+  updateViewportMaxScroll: updateViewportMaxScroll,
 };
-
 const ConnectedDroppable = connect(
-makeMapStateToProps,
-mapDispatchToProps,
-null, {
-  context: StoreContext,
-  areStatePropsEqual: isStrictEqual
-}
+  makeMapStateToProps,
+  mapDispatchToProps,
+  (stateProps, dispatchProps, ownProps) => {
+    const props = {
+      ...ownProps,
+      ...stateProps,
+      ...dispatchProps,
+    };
+    for (const propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
+  },
+  {
+    context: StoreContext,
+    areStatePropsEqual: isStrictEqual,
+  },
 )(Droppable$1);
-ConnectedDroppable.defaultProps = defaultProps;
 var ConnectedDroppable$1 = ConnectedDroppable;
 
-export { DragDropContext, PublicDraggable as Draggable, ConnectedDroppable$1 as Droppable, resetServerContext, useKeyboardSensor, useMouseSensor, useTouchSensor };
+export {
+  DragDropContext,
+  PublicDraggable as Draggable,
+  ConnectedDroppable$1 as Droppable,
+  resetServerContext,
+  useKeyboardSensor,
+  useMouseSensor,
+  useTouchSensor,
+};
diff --git a/dist/dnd.js b/dist/dnd.js
index e13825b15d9c1746a949e717027af63aabd8e223..0639481ef4948ab88aa0a9d0ece7794c92602ca3 100644
--- a/dist/dnd.js
+++ b/dist/dnd.js
@@ -4,14 +4,8 @@
   (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactBeautifulDnd = {}, global.React, global.ReactDOM, global.shim));
 })(this, (function (exports, React, ReactDOM, shim) { 'use strict';
 
-  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
-
-  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
-  var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
-
   const spacesAndTabs = /[ \t]{2,}/g;
   const lineStartWithSpaces = /^[ \t]*/gm;
-
   const clean$2 = value => value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
   const getDevMessage = message => clean$2(`
   %c@hello-pangea/dnd
@@ -20,17 +14,12 @@
 
   %c👷‍ This is a development only message. It will be removed in production builds.
 `);
-  const getFormattedMessage = message => [getDevMessage(message),
-  'color: #00C584; font-size: 1.2em; font-weight: bold;',
-  'line-height: 1.5',
-  'color: #723874;'];
+  const getFormattedMessage = message => [getDevMessage(message), 'color: #00C584; font-size: 1.2em; font-weight: bold;', 'line-height: 1.5', 'color: #723874;'];
   const isDisabledFlag = '__@hello-pangea/dnd-disable-dev-warnings';
   function log(type, message) {
-
     if (typeof window !== 'undefined' && window[isDisabledFlag]) {
       return;
     }
-
     console[type](...getFormattedMessage(message));
   }
   const warning$2 = log.bind(null, 'warn');
@@ -52,7 +41,6 @@
         el.removeEventListener(binding.eventName, binding.fn, options);
       };
     });
-
     return function unbindAll() {
       unbindings.forEach(unbind => {
         unbind();
@@ -60,25 +48,24 @@
     };
   }
 
-  const isProduction = "development" === 'production';
+  const isProduction$1 = "development" === 'production';
   const prefix$2 = 'Invariant failed';
   class RbdInvariant extends Error {}
   RbdInvariant.prototype.toString = function toString() {
     return this.message;
   };
-
   function invariant$1(condition, message) {
     if (condition) {
       return;
     }
-    if (isProduction) {
+    if (isProduction$1) {
       throw new RbdInvariant(prefix$2);
     } else {
       throw new RbdInvariant(`${prefix$2}: ${message || ''}`);
     }
   }
 
-  class ErrorBoundary extends React__default["default"].Component {
+  class ErrorBoundary extends React.Component {
     constructor() {
       super(...arguments);
       this.callbacks = null;
@@ -124,7 +111,6 @@
         this.setState({});
         return;
       }
-
       throw err;
     }
     componentWillUnmount() {
@@ -141,7 +127,6 @@
   Some screen readers may require you to be in focus mode or to use your pass through key
 `;
   const position = index => index + 1;
-
   const onDragStart = start => `
   You have lifted an item in position ${position(start.source.index)}
 `;
@@ -225,7 +210,34 @@
   };
   var preset$1 = preset;
 
+  function _typeof(obj) {
+    "@babel/helpers - typeof";
+
+    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
+      return typeof obj;
+    } : function (obj) {
+      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
+    }, _typeof(obj);
+  }
+
+  function _toPrimitive(input, hint) {
+    if (_typeof(input) !== "object" || input === null) return input;
+    var prim = input[Symbol.toPrimitive];
+    if (prim !== undefined) {
+      var res = prim.call(input, hint || "default");
+      if (_typeof(res) !== "object") return res;
+      throw new TypeError("@@toPrimitive must return a primitive value.");
+    }
+    return (hint === "string" ? String : Number)(input);
+  }
+
+  function _toPropertyKey(arg) {
+    var key = _toPrimitive(arg, "string");
+    return _typeof(key) === "symbol" ? key : String(key);
+  }
+
   function _defineProperty(obj, key, value) {
+    key = _toPropertyKey(key);
     if (key in obj) {
       Object.defineProperty(obj, key, {
         value: value,
@@ -844,7 +856,11 @@
     return target;
   }
 
-  var reactIs$2 = {exports: {}};
+  var reactIsExports$1 = {};
+  var reactIs$2 = {
+    get exports(){ return reactIsExports$1; },
+    set exports(v){ reactIsExports$1 = v; },
+  };
 
   var reactIs_development$1 = {};
 
@@ -1042,7 +1058,7 @@
   	}
   } (reactIs$2));
 
-  var reactIs$1 = reactIs$2.exports;
+  var reactIs$1 = reactIsExports$1;
 
   /**
    * Copyright 2015, Yahoo! Inc.
@@ -1144,7 +1160,11 @@
 
   var hoistNonReactStatics_cjs = hoistNonReactStatics;
 
-  var reactIs = {exports: {}};
+  var reactIsExports = {};
+  var reactIs = {
+    get exports(){ return reactIsExports; },
+    set exports(v){ reactIsExports = v; },
+  };
 
   var reactIs_development = {};
 
@@ -2001,7 +2021,7 @@
     const shouldHandleStateChanges = Boolean(mapStateToProps);
 
     const wrapWithConnect = WrappedComponent => {
-      if (!reactIs.exports.isValidElementType(WrappedComponent)) {
+      if (!reactIsExports.isValidElementType(WrappedComponent)) {
         throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);
       }
 
@@ -2039,7 +2059,7 @@
           // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
           // Memoize the check that determines which context instance we should use.
           return propsContext && propsContext.Consumer && // @ts-ignore
-          reactIs.exports.isContextConsumer( /*#__PURE__*/React__default["default"].createElement(propsContext.Consumer, null)) ? propsContext : Context;
+          reactIsExports.isContextConsumer( /*#__PURE__*/React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
         }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available
 
         const contextValue = React.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.
@@ -2166,7 +2186,7 @@
           return (
             /*#__PURE__*/
             // @ts-ignore
-            React__default["default"].createElement(WrappedComponent, _extends({}, actualChildProps, {
+            React.createElement(WrappedComponent, _extends({}, actualChildProps, {
               ref: reactReduxForwardedRef
             }))
           );
@@ -2178,7 +2198,7 @@
             // If this component is subscribed to store updates, we need to pass its own
             // subscription instance down to our descendants. That means rendering the same
             // Context instance, and putting a different value into the context.
-            return /*#__PURE__*/React__default["default"].createElement(ContextToUse.Provider, {
+            return /*#__PURE__*/React.createElement(ContextToUse.Provider, {
               value: overriddenContextValue
             }, renderedWrappedComponent);
           }
@@ -2188,7 +2208,7 @@
         return renderedChild;
       }
 
-      const _Connect = React__default["default"].memo(ConnectFunction);
+      const _Connect = React.memo(ConnectFunction);
 
       // Add a hacky cast to get the right output type
       const Connect = _Connect;
@@ -2196,9 +2216,9 @@
       Connect.displayName = ConnectFunction.displayName = displayName;
 
       if (forwardRef) {
-        const _forwarded = React__default["default"].forwardRef(function forwardConnectRef(props, ref) {
+        const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
           // @ts-ignore
-          return /*#__PURE__*/React__default["default"].createElement(Connect, _extends({}, props, {
+          return /*#__PURE__*/React.createElement(Connect, _extends({}, props, {
             reactReduxForwardedRef: ref
           }));
         });
@@ -2248,7 +2268,7 @@
     }, [contextValue, previousState]);
     const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype
 
-    return /*#__PURE__*/React__default["default"].createElement(Context.Provider, {
+    return /*#__PURE__*/React.createElement(Context.Provider, {
       value: contextValue
     }, children);
   }
@@ -2318,7 +2338,6 @@
     x: point.x !== 0 ? -point.x : 0,
     y: point.y !== 0 ? -point.y : 0
   });
-
   const patch = function (line, value, otherValue) {
     if (otherValue === void 0) {
       otherValue = 0;
@@ -2334,21 +2353,22 @@
       y: value
     };
   };
-
   const distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
-
   const closest$1 = (target, points) => Math.min(...points.map(point => distance(target, point)));
-
   const apply = fn => point => ({
     x: fn(point.x),
     y: fn(point.y)
   });
 
+  var isProduction = "development" === 'production';
   var prefix$1 = 'Invariant failed';
   function invariant(condition, message) {
       if (condition) {
           return;
       }
+      if (isProduction) {
+          throw new Error(prefix$1);
+      }
       var provided = typeof message === 'function' ? message() : message;
       var value = provided ? prefix$1 + ": " + provided : prefix$1;
       throw new Error(value);
@@ -2585,7 +2605,6 @@
     const scrollable = droppable.frame;
     const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
     const scrollDisplacement = negate(scrollDiff);
-
     const frame = {
       ...scrollable,
       scroll: {
@@ -2674,8 +2693,7 @@
   const toDraggableList = memoizeOne(draggables => Object.values(draggables));
 
   var getDraggablesInsideDroppable = memoizeOne((droppableId, draggables) => {
-    const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId)
-    .sort((a, b) => a.descriptor.index - b.descriptor.index);
+    const result = toDraggableList(draggables).filter(draggable => droppableId === draggable.descriptor.droppableId).sort((a, b) => a.descriptor.index - b.descriptor.index);
     return result;
   });
 
@@ -2728,7 +2746,6 @@
       return closestId ? getImpact(closestId) : null;
     }
     const withoutDraggable = removeDraggableFromList(draggable, insideDestination);
-
     if (!closestId) {
       if (!withoutDraggable.length) {
         return null;
@@ -2736,11 +2753,9 @@
       const last = withoutDraggable[withoutDraggable.length - 1];
       return getImpact(last.descriptor.id);
     }
-
     const indexOfClosest = withoutDraggable.findIndex(d => d.descriptor.id === closestId);
     !(indexOfClosest !== -1) ? invariant$1(false, 'Could not find displaced item in set')  : void 0;
     const proposedIndex = indexOfClosest - 1;
-
     if (proposedIndex < 0) {
       return null;
     }
@@ -2772,26 +2787,22 @@
     const isWithinVertical = isWithin(frame.top, frame.bottom);
     const isWithinHorizontal = isWithin(frame.left, frame.right);
     return subject => {
-
       const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
       if (isContained) {
         return true;
       }
       const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
       const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
-
       const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
       if (isPartiallyContained) {
         return true;
       }
       const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
       const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
-
       const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
       if (isTargetBiggerThanFrame) {
         return true;
       }
-
       const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
       return isTargetBiggerOnOneAxis;
     };
@@ -2848,7 +2859,6 @@
     if (!destination.subject.active) {
       return false;
     }
-
     return isVisibleThroughFrameFn(destination.subject.active)(target);
   };
   const isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport)(target);
@@ -2880,7 +2890,6 @@
     if (typeof forceShouldAnimate === 'boolean') {
       return forceShouldAnimate;
     }
-
     if (!last) {
       return true;
     }
@@ -2888,17 +2897,14 @@
       invisible,
       visible
     } = last;
-
     if (invisible[id]) {
       return false;
     }
     const previous = visible[id];
     return previous ? previous.shouldAnimate : true;
   };
-
   function getTarget(draggable, displacedBy) {
     const marginBox = draggable.page.marginBox;
-
     const expandBy = {
       top: displacedBy.point.y,
       right: 0,
@@ -2930,7 +2936,6 @@
         groups.invisible[draggable.descriptor.id] = true;
         return groups;
       }
-
       const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
       const displacement = {
         draggableId: id,
@@ -2950,7 +2955,6 @@
       return 0;
     }
     const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
-
     return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
   }
   function goAtEnd(_ref) {
@@ -2987,7 +2991,6 @@
       forceShouldAnimate
     } = _ref2;
     const inHomeList = isHomeOf(draggable, destination);
-
     if (index == null) {
       return goAtEnd({
         insideDestination,
@@ -2996,7 +2999,6 @@
         destination
       });
     }
-
     const match = insideDestination.find(item => item.descriptor.index === index);
     if (!match) {
       return goAtEnd({
@@ -3073,10 +3075,8 @@
     }
     const currentIndex = location.index;
     const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
-
     const firstIndex = insideDestination[0].descriptor.index;
     const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
-
     const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
     if (proposedIndex < firstIndex) {
       return null;
@@ -3121,7 +3121,6 @@
         index: newIndex
       });
     }
-
     const newIndex = fromCombine({
       isMovingForward,
       destination,
@@ -3179,7 +3178,6 @@
 
   const distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
   const distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
-
   const getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
   const goAfter = _ref => {
     let {
@@ -3187,8 +3185,7 @@
       moveRelativeTo,
       isMoving
     } = _ref;
-    return patch(axis.line,
-    moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+    return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
   };
   const goBefore = _ref2 => {
     let {
@@ -3196,8 +3193,7 @@
       moveRelativeTo,
       isMoving
     } = _ref2;
-    return patch(axis.line,
-    moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
+    return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
   };
   const goIntoStart = _ref3 => {
     let {
@@ -3219,7 +3215,6 @@
     const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
     const draggablePage = draggable.page;
     const axis = droppable.axis;
-
     if (!insideDestination.length) {
       return goIntoStart({
         axis,
@@ -3232,10 +3227,8 @@
       displacedBy
     } = impact;
     const closestAfter = displaced.all[0];
-
     if (closestAfter) {
       const closest = draggables[closestAfter];
-
       if (didStartAfterCritical(closestAfter, afterCritical)) {
         return goBefore({
           axis,
@@ -3243,7 +3236,6 @@
           isMoving: draggablePage
         });
       }
-
       const withDisplacement = offset(closest.page, displacedBy.point);
       return goBefore({
         axis,
@@ -3251,14 +3243,11 @@
         isMoving: draggablePage
       });
     }
-
     const last = insideDestination[insideDestination.length - 1];
-
     if (last.descriptor.id === draggable.descriptor.id) {
       return draggablePage.borderBox.center;
     }
     if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
-
       const page = offset(last.page, negate(afterCritical.displacedBy.point));
       return goAfter({
         axis,
@@ -3266,7 +3255,6 @@
         isMoving: draggablePage
       });
     }
-
     return goAfter({
       axis,
       moveRelativeTo: last.page,
@@ -3323,7 +3311,6 @@
   var scrollViewport = ((viewport, newScroll) => {
     const diff = subtract(newScroll, viewport.scroll.initial);
     const displacement = negate(diff);
-
     const frame = getRect({
       top: newScroll.y,
       bottom: newScroll.y + viewport.frame.height,
@@ -3386,8 +3373,7 @@
     });
     const invisible = {};
     const visible = {};
-    const groups = [
-    last, withViewportScroll, withDroppableScroll];
+    const groups = [last, withViewportScroll, withDroppableScroll];
     last.all.forEach(id => {
       const displacement = tryGetVisible(id, groups);
       if (displacement) {
@@ -3431,7 +3417,6 @@
     } = _ref;
     const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);
     const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);
-
     const args = {
       target: shifted,
       destination,
@@ -3539,41 +3524,30 @@
     }
     const axis = source.axis;
     const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
-    const candidates = toDroppableList(droppables)
-    .filter(droppable => droppable !== source)
-    .filter(droppable => droppable.isEnabled)
-    .filter(droppable => Boolean(droppable.subject.active))
-    .filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {
+    const candidates = toDroppableList(droppables).filter(droppable => droppable !== source).filter(droppable => droppable.isEnabled).filter(droppable => Boolean(droppable.subject.active)).filter(droppable => isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter(droppable => {
       const activeOfTarget = getKnownActive(droppable);
-
       if (isMovingForward) {
         return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
       }
       return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
-    })
-    .filter(droppable => {
+    }).filter(droppable => {
       const activeOfTarget = getKnownActive(droppable);
       const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
       return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
-    })
-    .sort((a, b) => {
+    }).sort((a, b) => {
       const first = getKnownActive(a)[axis.crossAxisStart];
       const second = getKnownActive(b)[axis.crossAxisStart];
       if (isMovingForward) {
         return first - second;
       }
       return second - first;
-    })
-    .filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
-
+    }).filter((droppable, index, array) => getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);
     if (!candidates.length) {
       return null;
     }
-
     if (candidates.length === 1) {
       return candidates[0];
     }
-
     const contains = candidates.filter(droppable => {
       const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);
       return isWithinDroppable(pageBorderBoxCenter[axis.line]);
@@ -3581,19 +3555,15 @@
     if (contains.length === 1) {
       return contains[0];
     }
-
     if (contains.length > 1) {
       return contains.sort((a, b) => getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];
     }
-
     return candidates.sort((a, b) => {
       const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));
       const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));
-
       if (first !== second) {
         return first - second;
       }
-
       return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
     })[0];
   });
@@ -3615,8 +3585,7 @@
       insideDestination,
       afterCritical
     } = _ref;
-    const sorted = insideDestination.filter(draggable =>
-    isTotallyVisible({
+    const sorted = insideDestination.filter(draggable => isTotallyVisible({
       target: getCurrentPageBorderBox(draggable, afterCritical),
       destination,
       viewport: viewport.frame,
@@ -3624,15 +3593,12 @@
     })).sort((a, b) => {
       const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
       const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
-
       if (distanceToA < distanceToB) {
         return -1;
       }
-
       if (distanceToB < distanceToA) {
         return 1;
       }
-
       return a.descriptor.index - b.descriptor.index;
     });
     return sorted[0] || null;
@@ -3648,17 +3614,14 @@
 
   const getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables) => {
     const axis = droppable.axis;
-
     if (droppable.descriptor.mode === 'virtual') {
       return patch(axis.line, placeholderSize[axis.line]);
     }
-
     const availableSpace = droppable.subject.page.contentBox[axis.size];
     const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);
     const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
     const requiredSpace = spaceUsed + placeholderSize[axis.line];
     const needsToGrowBy = requiredSpace - availableSpace;
-
     if (needsToGrowBy <= 0) {
       return null;
     }
@@ -3755,7 +3718,6 @@
       if (insideDestination.length) {
         return null;
       }
-
       const proposed = {
         displaced: emptyGroups,
         displacedBy: noDisplacedBy,
@@ -3774,7 +3736,6 @@
         draggables,
         afterCritical
       });
-
       const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);
       const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
         draggable,
@@ -3786,8 +3747,7 @@
       });
       return isVisibleInNewLocation ? proposed : null;
     }
-    const isGoingBeforeTarget = Boolean(
-    previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
+    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
     const proposedIndex = (() => {
       const relativeTo = moveRelativeTo.descriptor.index;
       if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {
@@ -3821,7 +3781,6 @@
       viewport,
       afterCritical
     } = _ref;
-
     const destination = getBestCrossAxisDroppable({
       isMovingForward,
       pageBorderBoxCenter: previousPageBorderBoxCenter,
@@ -3829,7 +3788,6 @@
       droppables,
       viewport
     });
-
     if (!destination) {
       return null;
     }
@@ -3899,7 +3857,6 @@
     const isOver = isActuallyOver || home;
     const direction = isOver.axis.direction;
     const isMovingOnMainAxis = direction === 'vertical' && (type === 'MOVE_UP' || type === 'MOVE_DOWN') || direction === 'horizontal' && (type === 'MOVE_LEFT' || type === 'MOVE_RIGHT');
-
     if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
       return null;
     }
@@ -3953,20 +3910,15 @@
       draggable,
       candidates
     } = _ref;
-
     const startCenter = draggable.page.borderBox.center;
     const sorted = candidates.map(candidate => {
       const axis = candidate.axis;
-      const target = patch(candidate.axis.line,
-      pageBorderBox.center[axis.line],
-      candidate.page.borderBox.center[axis.crossAxisLine]);
+      const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
       return {
         id: candidate.descriptor.id,
         distance: distance(startCenter, target)
       };
-    })
-    .sort((a, b) => b.distance - a.distance);
-
+    }).sort((a, b) => b.distance - a.distance);
     return sorted[0] ? sorted[0].id : null;
   }
   function getDroppableOver(_ref2) {
@@ -3979,20 +3931,16 @@
       if (!item.isEnabled) {
         return false;
       }
-
       const active = item.subject.active;
       if (!active) {
         return false;
       }
-
       if (!getHasOverlap(pageBorderBox, active)) {
         return false;
       }
-
       if (isPositionInFrame(active)(pageBorderBox.center)) {
         return true;
       }
-
       const axis = item.axis;
       const childCenter = active.center[axis.crossAxisLine];
       const crossAxisStart = pageBorderBox[axis.crossAxisStart];
@@ -4000,11 +3948,9 @@
       const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
       const isStartContained = isContained(crossAxisStart);
       const isEndContained = isContained(crossAxisEnd);
-
       if (!isStartContained && !isEndContained) {
         return true;
       }
-
       if (isStartContained) {
         return crossAxisStart < childCenter;
       }
@@ -4013,11 +3959,9 @@
     if (!candidates.length) {
       return null;
     }
-
     if (candidates.length === 1) {
       return candidates[0].descriptor.id;
     }
-
     return getFurthestAway({
       pageBorderBox,
       draggable,
@@ -4084,19 +4028,15 @@
         displaced: last,
         id
       });
-
       if (didStartAfterCritical$1) {
         if (isDisplaced) {
           return targetEnd <= childCenter;
         }
-
         return targetStart < childCenter - displacement;
       }
-
       if (isDisplaced) {
         return targetEnd <= childCenter + displacement;
       }
-
       return targetStart < childCenter;
     }) || null;
     const newIndex = atIndex({
@@ -4104,7 +4044,6 @@
       closest,
       inHomeList: isHomeOf(draggable, destination)
     });
-
     return calculateReorderImpact({
       draggable,
       insideDestination,
@@ -4145,19 +4084,15 @@
         displaced: previousImpact.displaced,
         id
       });
-
       if (didStartAfterCritical$1) {
         if (isDisplaced) {
           return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
         }
-
         return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
       }
-
       if (isDisplaced) {
         return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
       }
-
       return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
     });
     if (!combineWith) {
@@ -4193,15 +4128,12 @@
       draggable,
       droppables
     });
-
     if (!destinationId) {
       return noImpact$1;
     }
     const destination = droppables[destinationId];
     const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
-
     const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
-
     return getCombineImpact({
       pageBorderBoxWithDroppableScroll,
       draggable,
@@ -4236,12 +4168,10 @@
     if (!last) {
       return droppables;
     }
-
     if (last === now) {
       return droppables;
     }
     const lastDroppable = droppables[last];
-
     if (!lastDroppable.subject.withPlaceholder) {
       return droppables;
     }
@@ -4266,15 +4196,12 @@
       return cleaned;
     }
     const droppable = droppables[isOver];
-
     if (isHomeOf(draggable, droppable)) {
       return cleaned;
     }
-
     if (droppable.subject.withPlaceholder) {
       return cleaned;
     }
-
     const patched = addPlaceholder(droppable, draggable, draggables);
     return patchDroppableMap(cleaned, patched);
   });
@@ -4288,7 +4215,6 @@
       impact: forcedImpact,
       scrollJumpRequest
     } = _ref;
-
     const viewport = forcedViewport || state.viewport;
     const dimensions = forcedDimensions || state.dimensions;
     const clientSelection = forcedClientSelection || state.current.client.selection;
@@ -4307,7 +4233,6 @@
       client,
       page
     };
-
     if (state.phase === 'COLLECTING') {
       return {
         ...state,
@@ -4453,7 +4378,6 @@
     } = _ref;
     const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);
     const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);
-
     const rawIndex = insideHome.indexOf(draggable);
     !(rawIndex !== -1) ? invariant$1(false, 'Expected draggable to be inside home list')  : void 0;
     const afterDragging = insideHome.slice(rawIndex + 1);
@@ -4496,7 +4420,6 @@
   const records = {};
   let isEnabled = false;
   const isTimingsEnabled = () => isEnabled;
-
   const start = key => {
     {
       if (!isTimingsEnabled()) {
@@ -4537,12 +4460,7 @@
           symbol: '❌'
         };
       })();
-
-      console.log(`${style.symbol} %cTiming %c${rounded} %cms %c${key}`,
-      'color: blue; font-weight: bold;',
-      `color: ${style.textColor}; font-size: 1.1em;`,
-      'color: grey;',
-      'color: purple; font-weight: bold;');
+      console.log(`${style.symbol} %cTiming %c${rounded} %cms %c${key}`, 'color: blue; font-weight: bold;', `color: ${style.textColor}; font-size: 1.1em;`, 'color: grey;', 'color: purple; font-weight: bold;');
     }
   };
 
@@ -4578,9 +4496,7 @@
       updatedDroppables,
       viewport
     } = _ref;
-
     const windowScrollChange = viewport.scroll.diff.value;
-
     return additions.map(draggable => {
       const droppableId = draggable.descriptor.droppableId;
       const modified = updatedDroppables[droppableId];
@@ -4603,7 +4519,6 @@
       published
     } = _ref;
     start(timingsKey);
-
     const withScrollChange = published.modified.map(update => {
       const existing = state.dimensions.droppables[update.droppableId];
       const scrolled = scrollDroppable(existing, update.scroll);
@@ -4622,7 +4537,6 @@
       ...state.dimensions.draggables,
       ...updatedAdditions
     };
-
     published.removals.forEach(id => {
       delete draggables[id];
     });
@@ -4643,8 +4557,7 @@
       draggables,
       viewport: state.viewport
     });
-    const previousImpact = wasOver && wasOver.isCombineEnabled ?
-    state.impact : onLiftImpact;
+    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
     const impact = getDragImpact({
       pageOffset: state.current.page.offset,
       draggable: dimensions.draggables[state.critical.draggable.id],
@@ -4667,7 +4580,6 @@
     if (state.phase === 'COLLECTING') {
       return draggingState;
     }
-
     const dropPending = {
       ...draggingState,
       phase: 'DROP_PENDING',
@@ -4680,7 +4592,6 @@
   const isSnapping = state => state.movementMode === 'SNAP';
   const postDroppableChange = (state, updated, isEnabledChanging) => {
     const dimensions = patchDimensionMap(state.dimensions, updated);
-
     if (!isSnapping(state) || isEnabledChanging) {
       return update({
         state,
@@ -4706,7 +4617,6 @@
     completed: null,
     shouldFlush: false
   };
-
   var reducer = (function (state, action) {
     if (state === void 0) {
       state = idle$2;
@@ -4741,7 +4651,6 @@
           offset: add(client.selection, viewport.scroll.diff.value)
         }
       };
-
       const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(item => !item.isFixedOnPage);
       const {
         impact,
@@ -4796,7 +4705,6 @@
       const {
         client: clientSelection
       } = action.payload;
-
       if (isEqual$2(clientSelection, state.current.client.selection)) {
         return state;
       }
@@ -4810,7 +4718,6 @@
       if (state.phase === 'DROP_PENDING') {
         return removeScrollJumpRequest(state);
       }
-
       if (state.phase === 'COLLECTING') {
         return removeScrollJumpRequest(state);
       }
@@ -4820,7 +4727,6 @@
         newScroll
       } = action.payload;
       const target = state.dimensions.droppables[id];
-
       if (!target) {
         return state;
       }
@@ -4872,7 +4778,6 @@
       !isMovementAllowed(state) ? invariant$1(false, `Cannot move by window in phase ${state.phase}`)  : void 0;
       !state.isWindowScrollAllowed ? invariant$1(false, 'Window scrolling is currently not supported for fixed lists')  : void 0;
       const newScroll = action.payload.newScroll;
-
       if (isEqual$2(state.viewport.scroll.current, newScroll)) {
         return removeScrollJumpRequest(state);
       }
@@ -4903,7 +4808,6 @@
           max: maxScroll
         }
       };
-
       return {
         ...state,
         viewport: withMaxScroll
@@ -4918,7 +4822,6 @@
         state,
         type: action.type
       });
-
       if (!result) {
         return state;
       }
@@ -4947,7 +4850,6 @@
         newHomeClientOffset
       } = action.payload;
       !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? invariant$1(false, `Cannot animate drop from phase ${state.phase}`)  : void 0;
-
       const result = {
         phase: 'DROP_ANIMATING',
         completed,
@@ -4957,7 +4859,6 @@
       };
       return result;
     }
-
     if (action.type === 'DROP_COMPLETE') {
       const {
         completed
@@ -5065,7 +4966,6 @@
     for (let i = 1; i < indexes.length; i++) {
       const current = indexes[i];
       const previous = indexes[i - 1];
-
       if (current !== previous + 1) {
         errors[current] = true;
       }
@@ -5108,21 +5008,17 @@
         movementMode
       } = action.payload;
       const initial = getState();
-
       if (initial.phase === 'DROP_ANIMATING') {
         dispatch(completeDrop({
           completed: initial.completed
         }));
       }
       !(getState().phase === 'IDLE') ? invariant$1(false, 'Unexpected phase to start a drag')  : void 0;
-
       dispatch(flush());
-
       dispatch(beforeInitialCapture({
         draggableId: id,
         movementMode
       }));
-
       const scrollOptions = {
         shouldPublishImmediately: movementMode === 'SNAP'
       };
@@ -5136,7 +5032,6 @@
         viewport
       } = marshal.startPublishing(request);
       validateDimensions(critical, dimensions);
-
       dispatch(initialPublish({
         critical,
         dimensions,
@@ -5154,7 +5049,6 @@
     if (action.type === 'DROP_ANIMATE') {
       marshal.dropping(action.payload.completed.result.reason);
     }
-
     if (action.type === 'FLUSH' || action.type === 'DROP_COMPLETE') {
       marshal.resting();
     }
@@ -5179,7 +5073,6 @@
     minDropTime: 0.33,
     maxDropTime: 0.55
   };
-
   const outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
   const transitions = {
     fluid: `opacity ${outOfTheWayTiming}`,
@@ -5199,11 +5092,9 @@
       if (!translate) {
         return undefined;
       }
-
       if (!isCombining) {
         return translate;
       }
-
       return `${translate} scale(${combine.scale.drop})`;
     }
   };
@@ -5228,7 +5119,6 @@
     if (distance$1 >= maxDropTimeAtDistance) {
       return maxDropTime;
     }
-
     const percentage = distance$1 / maxDropTimeAtDistance;
     const duration = minDropTime + dropTimeRange * percentage;
     const withDuration = reason === 'CANCEL' ? duration * cancelDropModifier : duration;
@@ -5272,7 +5162,6 @@
       onLiftImpact
     } = _ref;
     if (!lastImpact.at || reason !== 'DROP') {
-
       const recomputedHomeImpact = recompute({
         draggables,
         impact: onLiftImpact,
@@ -5285,14 +5174,12 @@
         didDropInsideDroppable: false
       };
     }
-
     if (lastImpact.at.type === 'REORDER') {
       return {
         impact: lastImpact,
         didDropInsideDroppable: true
       };
     }
-
     const withoutMovement = {
       ...lastImpact,
       displaced: emptyGroups
@@ -5315,26 +5202,21 @@
       }
       const state = getState();
       const reason = action.payload.reason;
-
       if (state.phase === 'COLLECTING') {
         dispatch(dropPending({
           reason
         }));
         return;
       }
-
       if (state.phase === 'IDLE') {
         return;
       }
-
       const isWaitingForDrop = state.phase === 'DROP_PENDING' && state.isWaiting;
       !!isWaitingForDrop ? invariant$1(false, 'A DROP action occurred while DROP_PENDING and still waiting')  : void 0;
       !(state.phase === 'DRAGGING' || state.phase === 'DROP_PENDING') ? invariant$1(false, `Cannot drop in phase: ${state.phase}`)  : void 0;
-
       const critical = state.critical;
       const dimensions = state.dimensions;
       const draggable = dimensions.draggables[state.critical.draggable.id];
-
       const {
         impact,
         didDropInsideDroppable
@@ -5347,7 +5229,6 @@
         viewport: state.viewport,
         draggables: state.dimensions.draggables
       });
-
       const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
       const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;
       const source = {
@@ -5376,9 +5257,7 @@
         result,
         impact
       };
-      const isAnimationRequired =
-      !isEqual$2(state.current.client.offset, newHomeClientOffset) ||
-      Boolean(result.combine);
+      const isAnimationRequired = !isEqual$2(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
       if (!isAnimationRequired) {
         dispatch(completeDrop({
           completed
@@ -5509,7 +5388,6 @@
   var getExpiringAnnounce = (announce => {
     let wasCalled = false;
     let isExpired = false;
-
     const timeoutId = setTimeout(() => {
       isExpired = true;
     });
@@ -5529,7 +5407,6 @@
       announce(message);
       clearTimeout(timeoutId);
     };
-
     result.wasCalled = () => wasCalled;
     return result;
   });
@@ -5571,18 +5448,15 @@
     if (first == null && second == null) {
       return true;
     }
-
     if (first == null || second == null) {
       return false;
     }
-
     return first.droppableId === second.droppableId && first.index === second.index;
   };
   const isCombineEqual = (first, second) => {
     if (first == null && second == null) {
       return true;
     }
-
     if (first == null || second == null) {
       return false;
     }
@@ -5611,8 +5485,7 @@
     },
     mode
   });
-  function execute(responder, data, announce,
-  getDefaultMessage) {
+  function execute(responder, data, announce, getDefaultMessage) {
     if (!responder) {
       announce(getDefaultMessage(data));
       return;
@@ -5621,7 +5494,6 @@
     const provided = {
       announce: willExpire
     };
-
     responder(data, provided);
     if (!willExpire.wasCalled()) {
       announce(getDefaultMessage(data));
@@ -5661,22 +5533,18 @@
         lastLocation: data.source,
         lastCombine: null
       };
-
       asyncMarshal.add(() => {
         withTimings('onDragStart', () => execute(getResponders().onDragStart, data, announce, preset$1.onDragStart));
       });
     };
-
     const update = (critical, impact) => {
       const location = tryGetDestination(impact);
       const combine = tryGetCombine(impact);
       !dragging ? invariant$1(false, 'Cannot fire onDragMove when onDragStart has not been called')  : void 0;
-
       const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
       if (hasCriticalChanged) {
         dragging.lastCritical = critical;
       }
-
       const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
       if (hasLocationChanged) {
         dragging.lastLocation = location;
@@ -5685,7 +5553,6 @@
       if (hasGroupingChanged) {
         dragging.lastCombine = combine;
       }
-
       if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
         return;
       }
@@ -5707,7 +5574,6 @@
       dragging = null;
       withTimings('onDragEnd', () => execute(getResponders().onDragEnd, result, announce, preset$1.onDragEnd));
     };
-
     const abort = () => {
       if (!dragging) {
         return;
@@ -5745,7 +5611,6 @@
         publisher.start(critical, action.payload.movementMode);
         return;
       }
-
       if (action.type === 'DROP_COMPLETE') {
         const result = action.payload.completed.result;
         publisher.flush();
@@ -5753,14 +5618,11 @@
         publisher.drop(result);
         return;
       }
-
       next(action);
-
       if (action.type === 'FLUSH') {
         publisher.abort();
         return;
       }
-
       const state = store.getState();
       if (state.phase === 'DRAGGING') {
         publisher.update(state.critical, state.impact);
@@ -5816,7 +5678,6 @@
           }
         }
       };
-
       frameId = requestAnimationFrame(() => {
         frameId = null;
         unbind = bindEvents(window, [binding]);
@@ -5826,9 +5687,7 @@
   var dropAnimationFlushOnScroll = dropAnimationFlushOnScrollMiddleware;
 
   var dimensionMarshalStopper = (marshal => () => next => action => {
-    if (
-    action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' ||
-    action.type === 'DROP_ANIMATE') {
+    if (action.type === 'DROP_COMPLETE' || action.type === 'FLUSH' || action.type === 'DROP_ANIMATE') {
       marshal.stopPublishing();
     }
     next(action);
@@ -5856,7 +5715,6 @@
       if (action.type === 'DROP_COMPLETE') {
         isWatching = false;
         const result = action.payload.completed.result;
-
         if (result.combine) {
           marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
         }
@@ -5879,7 +5737,6 @@
       autoScroller.start(state);
       return;
     }
-
     next(action);
     autoScroller.scroll(store.getState());
   });
@@ -5889,13 +5746,10 @@
     if (action.type !== 'PUBLISH_WHILE_DRAGGING') {
       return;
     }
-
     const postActionState = store.getState();
-
     if (postActionState.phase !== 'DROP_PENDING') {
       return;
     }
-
     if (postActionState.isWaiting) {
       return;
     }
@@ -5917,13 +5771,7 @@
       announce,
       autoScroller
     } = _ref;
-    return createStore$1(reducer, composeEnhancers(applyMiddleware(
-
-    style(styleMarshal),
-    dimensionMarshalStopper(dimensionMarshal),
-    lift(dimensionMarshal), drop,
-    dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal),
-    responders(getResponders, announce))));
+    return createStore$1(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), drop, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop$1, autoScroll(autoScroller), scrollListener$1, focus(focusMarshal), responders(getResponders, announce))));
   });
 
   const clean$1 = () => ({
@@ -5952,9 +5800,7 @@
           removals,
           modified
         } = staging;
-        const added = Object.keys(additions).map(
-        id => registry.draggable.getById(id).getDimension(origin))
-        .sort((a, b) => a.descriptor.index - b.descriptor.index);
+        const added = Object.keys(additions).map(id => registry.draggable.getById(id).getDimension(origin)).sort((a, b) => a.descriptor.index - b.descriptor.index);
         const updated = Object.keys(modified).map(id => {
           const entry = registry.droppable.getById(id);
           const scroll = entry.callbacks.getScrollWhileDragging();
@@ -6013,12 +5859,10 @@
       height,
       width
     } = _ref;
-    const maxScroll = subtract(
-    {
+    const maxScroll = subtract({
       x: scrollWidth,
       y: scrollHeight
-    },
-    {
+    }, {
       x: width,
       y: height
     });
@@ -6051,11 +5895,9 @@
     const maxScroll = getMaxWindowScroll();
     const top = scroll.y;
     const left = scroll.x;
-
     const doc = getDocumentElement();
     const width = doc.clientWidth;
     const height = doc.clientHeight;
-
     const right = left + width;
     const bottom = top + height;
     const frame = getRect({
@@ -6135,11 +5977,9 @@
     });
     const updateDroppableIsEnabled = (id, isEnabled) => {
       !registry.droppable.exists(id) ? invariant$1(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`)  : void 0;
-
       if (!collection) {
         return;
       }
-
       callbacks.updateDroppableIsEnabled({
         id,
         isEnabled
@@ -6176,10 +6016,8 @@
         return;
       }
       publisher.stop();
-
       const home = collection.critical.droppable;
       registry.droppable.getAllByType(home.type).forEach(entry => entry.callbacks.dragStopped());
-
       collection.unsubscribe();
       collection = null;
     };
@@ -6231,15 +6069,12 @@
     if (state.phase === 'IDLE') {
       return true;
     }
-
     if (state.phase !== 'DROP_ANIMATING') {
       return false;
     }
-
     if (state.completed.result.draggableId === id) {
       return false;
     }
-
     return state.completed.result.reason === 'DROP';
   });
 
@@ -6251,7 +6086,6 @@
     if (!droppable.isEnabled) {
       return false;
     }
-
     if (!droppable.frame) {
       return false;
     }
@@ -6270,7 +6104,6 @@
       destination,
       droppables
     } = _ref;
-
     if (destination) {
       const dimension = droppables[destination];
       if (!dimension.frame) {
@@ -6278,7 +6111,6 @@
       }
       return dimension;
     }
-
     const dimension = getScrollableDroppableOver(center, droppables);
     return dimension;
   });
@@ -6336,19 +6168,15 @@
       getAutoScrollerOptions = () => defaultAutoScrollerOptions;
     }
     const autoScrollerOptions = getAutoScrollerOptions();
-
     if (distanceToEdge > thresholds.startScrollingFrom) {
       return 0;
     }
-
     if (distanceToEdge <= thresholds.maxScrollValueAt) {
       return autoScrollerOptions.maxPixelScroll;
     }
-
     if (distanceToEdge === thresholds.startScrollingFrom) {
       return minScroll;
     }
-
     const percentageFromMaxScrollValueAt = getPercentage({
       startOfRange: thresholds.maxScrollValueAt,
       endOfRange: thresholds.startScrollingFrom,
@@ -6356,7 +6184,6 @@
     });
     const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
     const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
-
     return Math.ceil(scroll);
   });
 
@@ -6368,11 +6195,9 @@
     const endOfRange = stopAt;
     const now = Date.now();
     const runTime = now - startOfRange;
-
     if (runTime >= stopAt) {
       return proposedScroll;
     }
-
     if (runTime < accelerateAt) {
       return minScroll;
     }
@@ -6394,15 +6219,12 @@
       getAutoScrollerOptions
     } = _ref;
     const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
-
     if (scroll === 0) {
       return 0;
     }
-
     if (!shouldUseTimeDampening) {
       return scroll;
     }
-
     return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);
   });
 
@@ -6443,15 +6265,12 @@
     } = _ref;
     const isTooBigVertically = subject.height > container.height;
     const isTooBigHorizontally = subject.width > container.width;
-
     if (!isTooBigHorizontally && !isTooBigVertically) {
       return proposedScroll;
     }
-
     if (isTooBigHorizontally && isTooBigVertically) {
       return null;
     }
-
     return {
       x: isTooBigHorizontally ? 0 : proposedScroll.x,
       y: isTooBigVertically ? 0 : proposedScroll.y
@@ -6474,7 +6293,6 @@
       bottom: container.bottom - center.y,
       left: center.x - container.left
     };
-
     const y = getScrollOnAxis({
       container,
       distanceToEdges,
@@ -6495,11 +6313,9 @@
       x,
       y
     });
-
     if (isEqual$2(required, origin)) {
       return null;
     }
-
     const limited = adjustForSizeLimits({
       container,
       subject,
@@ -6554,22 +6370,18 @@
       x: Math.max(current.x, rawMax.x),
       y: Math.max(current.y, rawMax.y)
     };
-
     const smallestChange = smallestSigned(change);
     const overlap = getOverlap({
       max,
       current,
       change: smallestChange
     });
-
     if (!overlap) {
       return true;
     }
-
     if (smallestChange.x !== 0 && overlap.x === 0) {
       return true;
     }
-
     if (smallestChange.y !== 0 && overlap.y === 0) {
       return true;
     }
@@ -6594,7 +6406,6 @@
   };
   const canScrollDroppable = (droppable, change) => {
     const frame = droppable.frame;
-
     if (!frame) {
       return false;
     }
@@ -6649,7 +6460,6 @@
       getAutoScrollerOptions
     } = _ref;
     const frame = droppable.frame;
-
     if (!frame) {
       return null;
     }
@@ -6757,7 +6567,6 @@
         shouldUseTimeDampening: wasScrollNeeded
       };
       finish('starting fluid scroller');
-
       if (wasScrollNeeded) {
         tryScroll(state);
       }
@@ -6794,12 +6603,10 @@
         return change;
       }
       const overlap = getDroppableOverlap(droppable, change);
-
       if (!overlap) {
         scrollDroppable(droppable.descriptor.id, change);
         return null;
       }
-
       const whatTheDroppableCanScroll = subtract(change, overlap);
       scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);
       const remainder = subtract(change, whatTheDroppableCanScroll);
@@ -6813,12 +6620,10 @@
         return change;
       }
       const overlap = getWindowOverlap(viewport, change);
-
       if (!overlap) {
         scrollWindow(change);
         return null;
       }
-
       const whatTheWindowCanScroll = subtract(change, overlap);
       scrollWindow(whatTheWindowCanScroll);
       const remainder = subtract(change, whatTheWindowCanScroll);
@@ -6831,19 +6636,15 @@
       }
       const destination = whatIsDraggedOver(state.impact);
       !destination ? invariant$1(false, 'Cannot perform a jump scroll when there is no destination')  : void 0;
-
       const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
-
       if (!droppableRemainder) {
         return;
       }
       const viewport = state.viewport;
       const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
-
       if (!windowRemainder) {
         return;
       }
-
       moveByOffset(state, windowRemainder);
     };
     return jumpScroller;
@@ -6868,7 +6669,6 @@
     });
     const scroll = state => {
       const autoScrollerOptions = getAutoScrollerOptions();
-
       if (autoScrollerOptions.disabled || state.phase !== 'DRAGGING') {
         return;
       }
@@ -6929,7 +6729,6 @@
   const noPointerEvents = 'pointer-events: none;';
   var getStyles$1 = (contextId => {
     const getSelector = makeGetSelector(contextId);
-
     const dragHandle$1 = (() => {
       const grabCursor = `
       cursor: -webkit-grab;
@@ -6949,7 +6748,6 @@
         }
       };
     })();
-
     const draggable$1 = (() => {
       const transition = `
       transition: ${transitions.outOfTheWay};
@@ -6963,14 +6761,12 @@
         }
       };
     })();
-
     const droppable$1 = {
       selector: getSelector(droppable.contextId),
       styles: {
         always: `overflow-anchor: none;`
       }
     };
-
     const body = {
       selector: 'body',
       styles: {
@@ -7015,9 +6811,7 @@
     const styles = useMemo(() => getStyles$1(contextId), [contextId]);
     const alwaysRef = React.useRef(null);
     const dynamicRef = React.useRef(null);
-
-    const setDynamicStyle = useCallback(
-    memoizeOne(proposed => {
+    const setDynamicStyle = useCallback(memoizeOne(proposed => {
       const el = dynamicRef.current;
       !el ? invariant$1(false, 'Cannot set dynamic style element if it is not set')  : void 0;
       el.textContent = proposed;
@@ -7027,21 +6821,16 @@
       !el ? invariant$1(false, 'Cannot set dynamic style element if it is not set')  : void 0;
       el.textContent = proposed;
     }, []);
-
     useLayoutEffect(() => {
       !(!alwaysRef.current && !dynamicRef.current) ? invariant$1(false, 'style elements already mounted')  : void 0;
       const always = createStyleEl(nonce);
       const dynamic = createStyleEl(nonce);
-
       alwaysRef.current = always;
       dynamicRef.current = dynamic;
-
       always.setAttribute(`${prefix}-always`, contextId);
       dynamic.setAttribute(`${prefix}-dynamic`, contextId);
-
       getHead().appendChild(always);
       getHead().appendChild(dynamic);
-
       setAlwaysStyle(styles.always);
       setDynamicStyle(styles.resting);
       return () => {
@@ -7081,10 +6870,7 @@
     return Array.from(parentNode.querySelectorAll(selector));
   }
 
-  var getWindowFromEl = (el => {
-    var _el$ownerDocument;
-    return (el == null ? void 0 : (_el$ownerDocument = el.ownerDocument) == null ? void 0 : _el$ownerDocument.defaultView) || window;
-  });
+  var getWindowFromEl = (el => el?.ownerDocument?.defaultView || window);
 
   function isHtmlElement(el) {
     return el instanceof getWindowFromEl(el).HTMLElement;
@@ -7145,7 +6931,6 @@
       if (restoreFocusFrameRef.current) {
         return;
       }
-
       if (!isMountedRef.current) {
         return;
       }
@@ -7160,11 +6945,9 @@
     const tryRecordFocus = useCallback(function tryRecordFocus(id) {
       recordRef.current = null;
       const focused = document.activeElement;
-
       if (!focused) {
         return;
       }
-
       if (focused.getAttribute(dragHandle.draggableId) !== id) {
         return;
       }
@@ -7199,7 +6982,6 @@
       subscribers.push(cb);
       return function unsubscribe() {
         const index = subscribers.indexOf(cb);
-
         if (index === -1) {
           return;
         }
@@ -7229,31 +7011,25 @@
       },
       update: (entry, last) => {
         const current = entries.draggables[last.descriptor.id];
-
         if (!current) {
           return;
         }
-
         if (current.uniqueId !== entry.uniqueId) {
           return;
         }
-
         delete entries.draggables[last.descriptor.id];
         entries.draggables[entry.descriptor.id] = entry;
       },
       unregister: entry => {
         const draggableId = entry.descriptor.id;
         const current = findDraggableById(draggableId);
-
         if (!current) {
           return;
         }
-
         if (entry.uniqueId !== current.uniqueId) {
           return;
         }
         delete entries.draggables[draggableId];
-
         if (entries.droppables[entry.descriptor.droppableId]) {
           notify({
             type: 'REMOVAL',
@@ -7280,11 +7056,9 @@
       },
       unregister: entry => {
         const current = findDroppableById(entry.descriptor.id);
-
         if (!current) {
           return;
         }
-
         if (entry.uniqueId !== current.uniqueId) {
           return;
         }
@@ -7312,7 +7086,7 @@
     const registry = useMemo(createRegistry, []);
     React.useEffect(() => {
       return function unmount() {
-        if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+        if (React.version.startsWith('16') || React.version.startsWith('17')) {
           requestAnimationFrame(registry.clean);
         } else {
           registry.clean();
@@ -7322,7 +7096,7 @@
     return registry;
   }
 
-  var StoreContext = React__default["default"].createContext(null);
+  var StoreContext = React.createContext(null);
 
   var getBodyElement = (() => {
     const body = document.body;
@@ -7350,17 +7124,12 @@
     React.useEffect(function setup() {
       const el = document.createElement('div');
       ref.current = el;
-
       el.id = id;
-
       el.setAttribute('aria-live', 'assertive');
       el.setAttribute('aria-atomic', 'true');
-
       _extends(el.style, visuallyHidden$1);
-
       getBodyElement().appendChild(el);
       return function cleanup() {
-
         setTimeout(function remove() {
           const body = getBodyElement();
           if (body.contains(el)) {
@@ -7409,11 +7178,10 @@
     if (options === void 0) {
       options = defaults;
     }
-    const id = React__default["default"].useId();
+    const id = React.useId();
     return useMemo(() => `${prefix}${options.separator}${id}`, [options.separator, prefix, id]);
   }
-
-  var useUniqueId$1 = 'useId' in React__default["default"] ? useUniqueId : useDeprecatedUniqueId;
+  var useUniqueId$1 = 'useId' in React ? useUniqueId : useDeprecatedUniqueId;
 
   function getElementId(_ref) {
     let {
@@ -7436,13 +7204,9 @@
     }), [uniqueId, contextId]);
     React.useEffect(function mount() {
       const el = document.createElement('div');
-
       el.id = id;
-
       el.textContent = text;
-
       el.style.display = 'none';
-
       getBodyElement().appendChild(el);
       return function unmount() {
         const body = getBodyElement();
@@ -7454,7 +7218,7 @@
     return id;
   }
 
-  var AppContext = React__default["default"].createContext(null);
+  var AppContext = React.createContext(null);
 
   var peerDependencies = {
   	react: "^16.8.5 || ^17.0.0 || ^18.0.0",
@@ -7482,14 +7246,12 @@
     if (actual.major < expected.major) {
       return false;
     }
-
     if (actual.minor > expected.minor) {
       return true;
     }
     if (actual.minor < expected.minor) {
       return false;
     }
-
     return actual.patch >= expected.patch;
   };
   var checkReactVersion = ((peerDepValue, actualValue) => {
@@ -7563,18 +7325,16 @@
 
   function useStartupValidation() {
     useDevSetupWarning(() => {
-      checkReactVersion(peerDependencies.react, React__default["default"].version);
+      checkReactVersion(peerDependencies.react, React.version);
       checkDoctype(document);
     }, []);
   }
 
   function usePrevious(current) {
     const ref = React.useRef(current);
-
     React.useEffect(() => {
       ref.current = current;
     });
-
     return ref;
   }
 
@@ -7645,11 +7405,9 @@
 
   const supportedEventName = (() => {
     const base = 'visibilitychange';
-
     if (typeof document === 'undefined') {
       return base;
     }
-
     const candidates = [base, `ms${base}`, `webkit${base}`, `moz${base}`, `o${base}`];
     const supported = candidates.find(eventName => `on${eventName}` in document);
     return supported || base;
@@ -7687,22 +7445,17 @@
           y: clientY
         };
         const phase = getPhase();
-
         if (phase.type === 'DRAGGING') {
           event.preventDefault();
           phase.actions.move(point);
           return;
         }
-
         !(phase.type === 'PENDING') ? invariant$1(false, 'Cannot be IDLE')  : void 0;
         const pending = phase.point;
-
         if (!isSloppyClickThresholdExceeded(pending, point)) {
           return;
         }
-
         event.preventDefault();
-
         const actions = phase.actions.fluidLift(point);
         setPhase({
           type: 'DRAGGING',
@@ -7717,7 +7470,6 @@
           cancel();
           return;
         }
-
         event.preventDefault();
         phase.actions.drop({
           shouldBlockNextClick: true
@@ -7740,7 +7492,6 @@
           cancel();
           return;
         }
-
         if (event.keyCode === escape) {
           event.preventDefault();
           cancel();
@@ -7762,8 +7513,7 @@
           cancel();
         }
       }
-    },
-    {
+    }, {
       eventName: 'webkitmouseforcedown',
       fn: event => {
         const phase = getPhase();
@@ -7772,11 +7522,9 @@
           cancel();
           return;
         }
-
         event.preventDefault();
       }
-    },
-    {
+    }, {
       eventName: supportedPageVisibilityEventName,
       fn: cancel
     }];
@@ -7793,7 +7541,6 @@
         if (event.button !== primaryButton) {
           return;
         }
-
         if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
           return;
         }
@@ -7801,25 +7548,21 @@
         if (!draggableId) {
           return;
         }
-        const actions = api.tryGetLock(draggableId,
-        stop, {
+        const actions = api.tryGetLock(draggableId, stop, {
           sourceEvent: event
         });
         if (!actions) {
           return;
         }
-
         event.preventDefault();
         const point = {
           x: event.clientX,
           y: event.clientY
         };
-
         unbindEventsRef.current();
         startPendingDrag(actions, point);
       }
-    }),
-    [api]);
+    }), [api]);
     const preventForcePressBinding = useMemo(() => ({
       eventName: 'webkitmouseforcewillbegin',
       fn: event => {
@@ -7897,7 +7640,6 @@
     }, [bindCapturingEvents]);
     useLayoutEffect(function mount() {
       listenForCapture();
-
       return function unmount() {
         unbindEventsRef.current();
       };
@@ -7928,13 +7670,11 @@
           cancel();
           return;
         }
-
         if (event.keyCode === space) {
           event.preventDefault();
           drop();
           return;
         }
-
         if (event.keyCode === arrowDown) {
           event.preventDefault();
           actions.moveDown();
@@ -7955,15 +7695,13 @@
           actions.moveLeft();
           return;
         }
-
         if (scrollJumpKeys[event.keyCode]) {
           event.preventDefault();
           return;
         }
         preventStandardKeyEvents(event);
       }
-    },
-    {
+    }, {
       eventName: 'mousedown',
       fn: cancel
     }, {
@@ -7975,19 +7713,16 @@
     }, {
       eventName: 'touchstart',
       fn: cancel
-    },
-    {
+    }, {
       eventName: 'resize',
       fn: cancel
-    },
-    {
+    }, {
       eventName: 'wheel',
       fn: cancel,
       options: {
         passive: true
       }
-    },
-    {
+    }, {
       eventName: supportedPageVisibilityEventName,
       fn: cancel
     }];
@@ -8000,7 +7735,6 @@
         if (event.defaultPrevented) {
           return;
         }
-
         if (event.keyCode !== space) {
           return;
         }
@@ -8008,37 +7742,28 @@
         if (!draggableId) {
           return;
         }
-        const preDrag = api.tryGetLock(draggableId,
-        stop, {
+        const preDrag = api.tryGetLock(draggableId, stop, {
           sourceEvent: event
         });
-
         if (!preDrag) {
           return;
         }
-
         event.preventDefault();
         let isCapturing = true;
-
         const actions = preDrag.snapLift();
-
         unbindEventsRef.current();
-
         function stop() {
           !isCapturing ? invariant$1(false, 'Cannot stop capturing a keyboard drag when not capturing')  : void 0;
           isCapturing = false;
-
           unbindEventsRef.current();
           listenForCapture();
         }
-
         unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
           capture: true,
           passive: false
         });
       }
-    }),
-    [api]);
+    }), [api]);
     const listenForCapture = useCallback(function tryStartCapture() {
       const options = {
         passive: false,
@@ -8048,7 +7773,6 @@
     }, [startCaptureBinding]);
     useLayoutEffect(function mount() {
       listenForCapture();
-
       return function unmount() {
         unbindEventsRef.current();
       };
@@ -8065,41 +7789,34 @@
       cancel,
       getPhase
     } = _ref;
-    return [
-    {
+    return [{
       eventName: 'orientationchange',
       fn: cancel
-    },
-    {
+    }, {
       eventName: 'resize',
       fn: cancel
-    },
-    {
+    }, {
       eventName: 'contextmenu',
       fn: event => {
         event.preventDefault();
       }
-    },
-    {
+    }, {
       eventName: 'keydown',
       fn: event => {
         if (getPhase().type !== 'DRAGGING') {
           cancel();
           return;
         }
-
         if (event.keyCode === escape) {
           event.preventDefault();
         }
         cancel();
       }
-    },
-    {
+    }, {
       eventName: supportedPageVisibilityEventName,
       fn: cancel
     }];
   }
-
   function getHandleBindings(_ref2) {
     let {
       cancel,
@@ -8117,7 +7834,6 @@
           cancel();
           return;
         }
-
         phase.hasMoved = true;
         const {
           clientX,
@@ -8127,7 +7843,6 @@
           x: clientX,
           y: clientY
         };
-
         event.preventDefault();
         phase.actions.move(point);
       }
@@ -8139,7 +7854,6 @@
           cancel();
           return;
         }
-
         event.preventDefault();
         phase.actions.drop({
           shouldBlockNextClick: true
@@ -8153,18 +7867,14 @@
           cancel();
           return;
         }
-
         event.preventDefault();
         cancel();
       }
-    },
-    {
+    }, {
       eventName: 'touchforcechange',
       fn: event => {
         const phase = getPhase();
-
         !(phase.type !== 'IDLE') ? invariant$1(false)  : void 0;
-
         const touch = event.touches[0];
         if (!touch) {
           return;
@@ -8180,7 +7890,6 @@
           }
           return;
         }
-
         if (shouldRespect) {
           if (phase.hasMoved) {
             event.preventDefault();
@@ -8189,17 +7898,13 @@
           cancel();
           return;
         }
-
         event.preventDefault();
       }
-    },
-    {
+    }, {
       eventName: supportedPageVisibilityEventName,
       fn: cancel
-    }
-    ];
+    }];
   }
-
   function useTouchSensor(api) {
     const phaseRef = React.useRef(idle);
     const unbindEventsRef = React.useRef(noop$2);
@@ -8215,16 +7920,13 @@
         if (event.defaultPrevented) {
           return;
         }
-
         const draggableId = api.findClosestDraggableId(event);
         if (!draggableId) {
           return;
         }
-        const actions = api.tryGetLock(draggableId,
-        stop, {
+        const actions = api.tryGetLock(draggableId, stop, {
           sourceEvent: event
         });
-
         if (!actions) {
           return;
         }
@@ -8237,13 +7939,10 @@
           x: clientX,
           y: clientY
         };
-
         unbindEventsRef.current();
-
         startPendingDrag(actions, point);
       }
-    }),
-    [api]);
+    }), [api]);
     const listenForCapture = useCallback(function listenForCapture() {
       const options = {
         capture: true,
@@ -8256,7 +7955,6 @@
       if (current.type === 'IDLE') {
         return;
       }
-
       if (current.type === 'PENDING') {
         clearTimeout(current.longPressTimerId);
       }
@@ -8286,7 +7984,6 @@
         completed: stop,
         getPhase
       };
-
       const unbindTarget = bindEvents(window, getHandleBindings(args), options);
       const unbindWindow = bindEvents(window, getWindowBindings(args), options);
       unbindEventsRef.current = function unbindAll() {
@@ -8319,7 +8016,6 @@
       listenForCapture();
       return function unmount() {
         unbindEventsRef.current();
-
         const phase = getPhase();
         if (phase.type === 'PENDING') {
           clearTimeout(phase.longPressTimerId);
@@ -8327,7 +8023,6 @@
         }
       };
     }, [getPhase, listenForCapture, setPhase]);
-
     useLayoutEffect(function webkitHack() {
       const unbind = bindEvents(window, [{
         eventName: 'touchmove',
@@ -8355,21 +8050,17 @@
     if (current == null) {
       return false;
     }
-
     const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
     if (hasAnInteractiveTag) {
       return true;
     }
-
     const attribute = current.getAttribute('contenteditable');
     if (attribute === 'true' || attribute === '') {
       return true;
     }
-
     if (current === parent) {
       return false;
     }
-
     return isAnInteractiveElement(parent, current.parentElement);
   }
   function isEventInInteractiveElement(draggable, event) {
@@ -8388,11 +8079,9 @@
 
   const supportedMatchesName = (() => {
     const base = 'matches';
-
     if (typeof document === 'undefined') {
       return base;
     }
-
     const candidates = [base, 'msMatchesSelector', 'webkitMatchesSelector'];
     const value = candidates.find(name => name in Element.prototype);
     return value || base;
@@ -8401,11 +8090,9 @@
     if (el == null) {
       return null;
     }
-
     if (el[supportedMatchesName](selector)) {
       return el;
     }
-
     return closestPonyfill(el.parentElement, selector);
   }
   function closest(el, selector) {
@@ -8516,11 +8203,9 @@
       warning$2(`Unable to find draggable with id: ${draggableId}`) ;
       return false;
     }
-
     if (!entry.options.isEnabled) {
       return false;
     }
-
     if (!canStartDrag(store.getState(), draggableId)) {
       return false;
     }
@@ -8551,11 +8236,9 @@
       warning$2(`Unable to find draggable element with id: ${draggableId}`) ;
       return null;
     }
-
     if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
       return null;
     }
-
     const lock = lockAPI.claim(forceSensorStop || noop$2);
     let phase = 'PRE_DRAG';
     function getShouldRespectForcePress() {
@@ -8585,7 +8268,6 @@
         invariant$1(false, `Cannot lift in phase ${phase}`)  ;
       }
       store.dispatch(lift$1(args.liftActionArgs));
-
       phase = 'DRAGGING';
       function finish(reason, options) {
         if (options === void 0) {
@@ -8594,7 +8276,6 @@
           };
         }
         args.cleanup();
-
         if (options.shouldBlockNextClick) {
           const unbind = bindEvents(window, [{
             eventName: 'click',
@@ -8607,7 +8288,6 @@
           }]);
           setTimeout(unbind);
         }
-
         completed();
         store.dispatch(drop$1({
           reason
@@ -8706,7 +8386,6 @@
         lockAPI.tryAbandon();
       }
     }, [lockAPI]);
-
     useLayoutEffect(function listenToStore() {
       let previous = store.getState();
       const unsubscribe = store.subscribe(() => {
@@ -8714,10 +8393,8 @@
         tryAbandonLock(previous, current);
         previous = current;
       });
-
       return unsubscribe;
     }, [lockAPI, store, tryAbandonLock]);
-
     useLayoutEffect(() => {
       return lockAPI.tryAbandon;
     }, [lockAPI.tryAbandon]);
@@ -8761,7 +8438,6 @@
       tryReleaseLock,
       isLockClaimed
     }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
-
     useValidateSensorHooks(useSensors);
     for (let i = 0; i < useSensors.length; i++) {
       useSensors[i](api);
@@ -8775,7 +8451,7 @@
           props.onBeforeCapture(t);
         }
       };
-      if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+      if (React.version.startsWith('16') || React.version.startsWith('17')) {
         onBeforeCapureCallback();
       } else {
         ReactDOM.flushSync(onBeforeCapureCallback);
@@ -8808,7 +8484,6 @@
     } = props;
     const lazyStoreRef = React.useRef(null);
     useStartupValidation();
-
     const lastPropsRef = usePrevious(props);
     const getResponders = useCallback(() => {
       return createResponders(lastPropsRef.current);
@@ -8853,13 +8528,11 @@
       getResponders,
       styleMarshal
     }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
-
     {
       if (lazyStoreRef.current && lazyStoreRef.current !== store) {
         warning$2('unexpected store change') ;
       }
     }
-
     lazyStoreRef.current = store;
     const tryResetStore = useCallback(() => {
       const current = getStore(lazyStoreRef);
@@ -8882,7 +8555,6 @@
       isDragging,
       tryAbort: tryResetStore
     }), [isDragging, tryResetStore]);
-
     setCallbacks(appCallbacks);
     const getCanLift = useCallback(id => canStartDrag(getStore(lazyStoreRef).getState(), id), []);
     const getIsMovementAllowed = useCallback(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
@@ -8902,13 +8574,12 @@
       customSensors: sensors || null,
       enableDefaultSensors: props.enableDefaultSensors !== false
     });
-
     React.useEffect(() => {
       return tryResetStore;
     }, [tryResetStore]);
-    return React__default["default"].createElement(AppContext.Provider, {
+    return React.createElement(AppContext.Provider, {
       value: appContext
-    }, React__default["default"].createElement(Provider, {
+    }, React.createElement(Provider, {
       context: StoreContext,
       store: store
     }, props.children));
@@ -8922,13 +8593,12 @@
     return useMemo(() => `${count++}`, []);
   }
   function useUniqueContextId() {
-    return React__default["default"].useId();
+    return React.useId();
   }
-
-  var useUniqueContextId$1 = 'useId' in React__default["default"] ? useUniqueContextId : useDeprecatedUniqueContextId;
+  var useUniqueContextId$1 = 'useId' in React ? useUniqueContextId : useDeprecatedUniqueContextId;
 
   function resetServerContext() {
-    if ('useId' in React__default["default"]) {
+    if ('useId' in React) {
       warning$2(`It is not necessary to call resetServerContext when using React 18+`) ;
       return;
     }
@@ -8938,8 +8608,7 @@
   function DragDropContext(props) {
     const contextId = useUniqueContextId$1();
     const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset$1.dragHandleUsageInstructions;
-
-    return React__default["default"].createElement(ErrorBoundary, null, setCallbacks => React__default["default"].createElement(App, {
+    return React.createElement(ErrorBoundary, null, setCallbacks => React.createElement(App, {
       nonce: props.nonce,
       contextId: contextId,
       setCallbacks: setCallbacks,
@@ -9072,12 +8741,10 @@
     }), [descriptor, getDimension, options, uniqueId]);
     const publishedRef = React.useRef(entry);
     const isFirstPublishRef = React.useRef(true);
-
     useLayoutEffect(() => {
       registry.draggable.register(publishedRef.current);
       return () => registry.draggable.unregister(publishedRef.current);
     }, [registry.draggable]);
-
     useLayoutEffect(() => {
       if (isFirstPublishRef.current) {
         isFirstPublishRef.current = false;
@@ -9089,7 +8756,7 @@
     }, [entry, registry.draggable]);
   }
 
-  var DroppableContext = React__default["default"].createContext(null);
+  var DroppableContext = React.createContext(null);
 
   function checkIsValidInnerRef(el) {
     !(el && isHtmlElement(el)) ? invariant$1(false, `
@@ -9105,7 +8772,6 @@
       function prefix(id) {
         return `Draggable[id: ${id}]: `;
       }
-
       const id = props.draggableId;
       !id ? "development" !== "production" ? invariant$1(false, 'Draggable requires a draggableId') : invariant$1(false) : void 0;
       !(typeof id === 'string') ? "development" !== "production" ? invariant$1(false, `Draggable requires a [string] draggableId.
@@ -9114,19 +8780,15 @@
       if (props.mapped.type === 'DRAGGING') {
         return;
       }
-
       checkIsValidInnerRef(getRef());
-
       if (props.isEnabled) {
         !findDragHandle(contextId, id) ? "development" !== "production" ? invariant$1(false, `${prefix(id)} Unable to find drag handle`) : invariant$1(false) : void 0;
       }
     });
   }
-
   function useClonePropValidation(isClone) {
     useDev(() => {
       const initialRef = React.useRef(isClone);
-
       useDevSetupWarning(() => {
         !(isClone === initialRef.current) ? "development" !== "production" ? invariant$1(false, 'Draggable isClone prop value changed during component life') : invariant$1(false) : void 0;
       }, [isClone]);
@@ -9151,7 +8813,6 @@
       ref.current = el;
     }, []);
     const getRef = useCallback(() => ref.current, []);
-
     const {
       contextId,
       dragHandleUsageInstructionsId,
@@ -9167,7 +8828,6 @@
       type,
       droppableId
     }), [props.draggableId, props.index, type, droppableId]);
-
     const {
       children,
       draggableId,
@@ -9178,9 +8838,7 @@
       mapped,
       dropAnimationFinished: dropAnimationFinishedAction
     } = props;
-
     useValidation$1(props, contextId, getRef);
-
     useClonePropValidation(isClone);
     if (!isClone) {
       const forPublisher = useMemo(() => ({
@@ -9193,7 +8851,6 @@
       }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
       useDraggablePublisher(forPublisher);
     }
-
     const dragHandleProps = useMemo(() => isEnabled ? {
       tabIndex: 0,
       role: 'button',
@@ -9210,11 +8867,10 @@
       if (!mapped.dropping) {
         return;
       }
-
       if (event.propertyName !== 'transform') {
         return;
       }
-      if (React__default["default"].version.startsWith('16') || React__default["default"].version.startsWith('17')) {
+      if (React.version.startsWith('16') || React.version.startsWith('17')) {
         dropAnimationFinishedAction();
       } else {
         ReactDOM.flushSync(dropAnimationFinishedAction);
@@ -9243,7 +8899,7 @@
         droppableId: descriptor.droppableId
       }
     }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
-    return React__default["default"].createElement(React__default["default"].Fragment, null, children(provided, mapped.snapshot, rubric));
+    return React.createElement(React.Fragment, null, children(provided, mapped.snapshot, rubric));
   };
   var Draggable$1 = Draggable;
 
@@ -9295,9 +8951,7 @@
         combineTargetFor: null
       };
     });
-    const getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone,
-    draggingOver,
-    combineWith, forceShouldAnimate) {
+    const getMemoizedProps = memoizeOne(function (offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
       if (draggingOver === void 0) {
         draggingOver = null;
       }
@@ -9333,7 +8987,6 @@
         const forceShouldAnimate = state.forceShouldAnimate;
         return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
       }
-
       if (state.phase === 'DROP_ANIMATING') {
         const completed = state.completed;
         if (completed.result.draggableId !== ownProps.draggableId) {
@@ -9346,7 +8999,6 @@
         const draggingOver = whatIsDraggedOverFromResult(result);
         const combineWith = getCombineWithFromResult(result);
         const duration = state.dropDuration;
-
         const dropping = {
           duration,
           curve: curves.drop,
@@ -9402,8 +9054,7 @@
       y
     }));
     const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
-    const getMemoizedProps = memoizeOne(function (offset,
-    combineTargetFor, shouldAnimateDisplacement) {
+    const getMemoizedProps = memoizeOne(function (offset, combineTargetFor, shouldAnimateDisplacement) {
       if (combineTargetFor === void 0) {
         combineTargetFor = null;
       }
@@ -9417,7 +9068,6 @@
         }
       };
     });
-
     const getFallback = combineTargetFor => {
       return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
     };
@@ -9430,11 +9080,9 @@
         if (!isAfterCriticalInVirtualList) {
           return getFallback(combineTargetFor);
         }
-
         if (impact.displaced.invisible[ownId]) {
           return null;
         }
-
         const change = negate(afterCritical.displacedBy.point);
         const offset = memoizedOffset(change.x, change.y);
         return getMemoizedProps(offset, combineTargetFor, true);
@@ -9453,7 +9101,6 @@
         }
         return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
       }
-
       if (state.phase === 'DROP_ANIMATING') {
         const completed = state.completed;
         if (completed.result.draggableId === ownProps.draggableId) {
@@ -9461,12 +9108,10 @@
         }
         return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
       }
-
       return null;
     };
     return selector;
   }
-
   const makeMapStateToProps$1 = () => {
     const draggingSelector = getDraggableSelector();
     const secondarySelector = getSecondarySelector();
@@ -9476,15 +9121,10 @@
   const mapDispatchToProps$1 = {
     dropAnimationFinished: dropAnimationFinished
   };
-
-  const ConnectedDraggable = connect(
-  makeMapStateToProps$1, mapDispatchToProps$1,
-  null,
-  {
+  const ConnectedDraggable = connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
     context: StoreContext,
     areStatePropsEqual: isStrictEqual
-  }
-  )(Draggable$1);
+  })(Draggable$1);
   var ConnectedDraggable$1 = ConnectedDraggable;
 
   function PrivateDraggable(props) {
@@ -9493,14 +9133,13 @@
     if (isUsingCloneFor === props.draggableId && !props.isClone) {
       return null;
     }
-    return React__default["default"].createElement(ConnectedDraggable$1, props);
+    return React.createElement(ConnectedDraggable$1, props);
   }
-
   function PublicDraggable(props) {
     const isEnabled = typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
     const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
     const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
-    return React__default["default"].createElement(PrivateDraggable, _extends({}, props, {
+    return React.createElement(PrivateDraggable, _extends({}, props, {
       isClone: false,
       isEnabled: isEnabled,
       canDragInteractiveElements: canDragInteractiveElements,
@@ -9522,12 +9161,10 @@
     };
     return isEither(overflow, isScroll) || isEither(overflow, isAuto);
   };
-
   const isBodyScrollable = () => {
     const body = getBodyElement();
     const html = document.documentElement;
     !html ? invariant$1(false)  : void 0;
-
     if (!isElementScrollable(body)) {
       return false;
     }
@@ -9555,18 +9192,15 @@
     if (el == null) {
       return null;
     }
-
     if (el === document.body) {
       return isBodyScrollable() ? el : null;
     }
-
     if (el === document.documentElement) {
       return null;
     }
     if (!isElementScrollable(el)) {
       return getClosestScrollable(el.parentElement);
     }
-
     return el;
   };
   var getClosestScrollable$1 = getClosestScrollable;
@@ -9631,7 +9265,6 @@
         scrollSize,
         client: frameClient
       } = closest;
-
       const maxScroll = getMaxScroll({
         scrollHeight: scrollSize.scrollHeight,
         scrollWidth: scrollSize.scrollWidth,
@@ -9677,29 +9310,23 @@
 
   const getClient = (targetRef, closestScrollable) => {
     const base = getBox(targetRef);
-
     if (!closestScrollable) {
       return base;
     }
-
     if (targetRef !== closestScrollable) {
       return base;
     }
-
     const top = base.paddingBox.top - closestScrollable.scrollTop;
     const left = base.paddingBox.left - closestScrollable.scrollLeft;
     const bottom = top + closestScrollable.scrollHeight;
     const right = left + closestScrollable.scrollWidth;
-
     const paddingBox = {
       top,
       right,
       bottom,
       left
     };
-
     const borderBox = expand(paddingBox, base.border);
-
     const client = createBox({
       borderBox,
       margin: base.margin,
@@ -9833,7 +9460,6 @@
       const scrollable = env.closestScrollable;
       if (scrollable) {
         scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
-
         scrollable.addEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
         {
           checkForNestedScrollContainers(scrollable);
@@ -9851,23 +9477,19 @@
       const dragging = whileDraggingRef.current;
       !dragging ? invariant$1(false, 'Cannot stop drag when no active drag')  : void 0;
       const closest = getClosestScrollableFromDrag(dragging);
-
       whileDraggingRef.current = null;
       if (!closest) {
         return;
       }
-
       scheduleScrollUpdate.cancel();
       closest.removeAttribute(scrollContainer.contextId);
-      closest.removeEventListener('scroll', onClosestScroll,
-      getListenerOptions(dragging.scrollOptions));
+      closest.removeEventListener('scroll', onClosestScroll, getListenerOptions(dragging.scrollOptions));
     }, [onClosestScroll, scheduleScrollUpdate]);
     const scroll = useCallback(change => {
       const dragging = whileDraggingRef.current;
       !dragging ? invariant$1(false, 'Cannot scroll when there is no drag')  : void 0;
       const closest = getClosestScrollableFromDrag(dragging);
       !closest ? invariant$1(false, 'Cannot scroll a droppable with no closest scrollable')  : void 0;
-
       closest.scrollTop += change.y;
       closest.scrollLeft += change.x;
     }, []);
@@ -9884,7 +9506,6 @@
       descriptor,
       callbacks
     }), [callbacks, descriptor, uniqueId]);
-
     useLayoutEffect(() => {
       publishedDescriptorRef.current = entry.descriptor;
       registry.droppable.register(entry);
@@ -9896,14 +9517,12 @@
         registry.droppable.unregister(entry);
       };
     }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
-
     useLayoutEffect(() => {
       if (!whileDraggingRef.current) {
         return;
       }
       marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
     }, [args.isDropDisabled, marshal]);
-
     useLayoutEffect(() => {
       if (!whileDraggingRef.current) {
         return;
@@ -9949,7 +9568,6 @@
     });
     return {
       display: placeholder.display,
-
       boxSizing: 'border-box',
       width: size.width,
       height: size.height,
@@ -9979,18 +9597,15 @@
       contextId
     } = props;
     const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = React.useState(props.animate === 'open');
-
     React.useEffect(() => {
       if (!isAnimatingOpenOnMount) {
         return noop;
       }
-
       if (animate !== 'open') {
         tryClearAnimateOpenTimer();
         setIsAnimatingOpenOnMount(false);
         return noop;
       }
-
       if (animateOpenTimerRef.current) {
         return noop;
       }
@@ -9998,7 +9613,6 @@
         animateOpenTimerRef.current = null;
         setIsAnimatingOpenOnMount(false);
       });
-
       return tryClearAnimateOpenTimer;
     }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
     const onSizeChangeEnd = useCallback(event => {
@@ -10015,14 +9629,14 @@
       animate: props.animate,
       placeholder: props.placeholder
     });
-    return React__default["default"].createElement(props.placeholder.tagName, {
+    return React.createElement(props.placeholder.tagName, {
       style,
       'data-rfd-placeholder-context-id': contextId,
       onTransitionEnd: onSizeChangeEnd,
       ref: props.innerRef
     });
   };
-  var Placeholder$1 = React__default["default"].memo(Placeholder);
+  var Placeholder$1 = React.memo(Placeholder);
 
   function isBoolean(value) {
     return typeof value === 'boolean';
@@ -10092,7 +9706,7 @@
     });
   }
 
-  class AnimateInOut extends React__default["default"].PureComponent {
+  class AnimateInOut extends React.PureComponent {
     constructor() {
       super(...arguments);
       this.state = {
@@ -10117,7 +9731,6 @@
           animate: 'none'
         };
       }
-
       if (props.on) {
         return {
           isVisible: true,
@@ -10125,7 +9738,6 @@
           animate: 'open'
         };
       }
-
       if (state.isVisible) {
         return {
           isVisible: true,
@@ -10133,7 +9745,6 @@
           animate: 'close'
         };
       }
-
       return {
         isVisible: false,
         animate: 'close',
@@ -10212,7 +9823,7 @@
       ignoreContainerClipping,
       getDroppableRef
     });
-    const placeholder = useMemo(() => React__default["default"].createElement(AnimateInOut, {
+    const placeholder = useMemo(() => React.createElement(AnimateInOut, {
       on: props.placeholder,
       shouldAnimate: props.shouldAnimatePlaceholder
     }, _ref => {
@@ -10221,7 +9832,7 @@
         data,
         animate
       } = _ref;
-      return React__default["default"].createElement(Placeholder$1, {
+      return React.createElement(Placeholder$1, {
         placeholder: data,
         onClose: onClose,
         innerRef: setPlaceholderRef,
@@ -10252,18 +9863,17 @@
         dragging,
         render
       } = useClone;
-      const node = React__default["default"].createElement(PrivateDraggable, {
+      const node = React.createElement(PrivateDraggable, {
         draggableId: dragging.draggableId,
         index: dragging.source.index,
         isClone: true,
-        isEnabled: true
-        ,
+        isEnabled: true,
         shouldRespectForcePress: false,
         canDragInteractiveElements: true
       }, (draggableProvided, draggableSnapshot) => render(draggableProvided, draggableSnapshot, dragging));
-      return ReactDOM__default["default"].createPortal(node, getContainerForClone());
+      return ReactDOM.createPortal(node, getContainerForClone());
     }
-    return React__default["default"].createElement(DroppableContext.Provider, {
+    return React.createElement(DroppableContext.Provider, {
       value: droppableContext
     }, children(provided, snapshot), getClone());
   };
@@ -10271,7 +9881,20 @@
 
   const isMatchingType = (type, critical) => type === critical.droppable.type;
   const getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
-
+  function getBody() {
+    !document.body ? invariant$1(false, 'document.body is not ready')  : void 0;
+    return document.body;
+  }
+  const defaultProps = {
+    mode: 'standard',
+    type: 'DEFAULT',
+    direction: 'vertical',
+    isDropDisabled: false,
+    isCombineEnabled: false,
+    ignoreContainerClipping: false,
+    renderClone: null,
+    getContainerForClone: getBody
+  };
   const makeMapStateToProps = () => {
     const idleWithAnimation = {
       placeholder: null,
@@ -10320,7 +9943,6 @@
       if (!isEnabled) {
         return idleWithoutAnimation;
       }
-
       if (!isDraggingOverForImpact) {
         return idleWithAnimation;
       }
@@ -10337,12 +9959,15 @@
         useClone: null
       };
     });
-    const selector = (state, ownProps) => {
-
-      const id = ownProps.droppableId;
-      const type = ownProps.type;
-      const isEnabled = !ownProps.isDropDisabled;
-      const renderClone = ownProps.renderClone;
+    const selector = (state, _ref) => {
+      let {
+        droppableId,
+        type = defaultProps.type,
+        isDropDisabled = defaultProps.isDropDisabled,
+        renderClone = defaultProps.renderClone
+      } = _ref;
+      const id = droppableId;
+      const isEnabled = !isDropDisabled;
       if (isDragging(state)) {
         const critical = state.critical;
         if (!isMatchingType(type, critical)) {
@@ -10358,7 +9983,6 @@
           return idleWithoutAnimation;
         }
         const dragging = getDraggable(completed.critical, state.dimensions);
-
         return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);
       }
       if (state.phase === 'IDLE' && state.completed && !state.shouldFlush) {
@@ -10366,20 +9990,17 @@
         if (!isMatchingType(type, completed.critical)) {
           return idleWithoutAnimation;
         }
-
         const wasOver = whatIsDraggedOver(completed.impact) === id;
         const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === 'COMBINE');
         const isHome = completed.critical.droppable.id === id;
         if (wasOver) {
           return wasCombining ? idleWithAnimation : idleWithoutAnimation;
         }
-
         if (isHome) {
           return idleWithAnimation;
         }
         return idleWithoutAnimation;
       }
-
       return idleWithoutAnimation;
     };
     return selector;
@@ -10387,30 +10008,23 @@
   const mapDispatchToProps = {
     updateViewportMaxScroll: updateViewportMaxScroll
   };
-  function getBody() {
-    !document.body ? invariant$1(false, 'document.body is not ready')  : void 0;
-    return document.body;
-  }
-  const defaultProps = {
-    mode: 'standard',
-    type: 'DEFAULT',
-    direction: 'vertical',
-    isDropDisabled: false,
-    isCombineEnabled: false,
-    ignoreContainerClipping: false,
-    renderClone: null,
-    getContainerForClone: getBody
-  };
-
-  const ConnectedDroppable = connect(
-  makeMapStateToProps,
-  mapDispatchToProps,
-  null, {
+  const ConnectedDroppable = connect(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {
+    const props = {
+      ...ownProps,
+      ...stateProps,
+      ...dispatchProps
+    };
+    console.log('CHUJ');
+    for (const propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
+  }, {
     context: StoreContext,
     areStatePropsEqual: isStrictEqual
-  }
-  )(Droppable$1);
-  ConnectedDroppable.defaultProps = defaultProps;
+  })(Droppable$1);
   var ConnectedDroppable$1 = ConnectedDroppable;
 
   exports.DragDropContext = DragDropContext;
@@ -10421,6 +10035,4 @@
   exports.useMouseSensor = useMouseSensor;
   exports.useTouchSensor = useTouchSensor;
 
-  Object.defineProperty(exports, '__esModule', { value: true });
-
 }));
diff --git a/dist/dnd.min.js b/dist/dnd.min.js
index 7fad3320231c372dcecc392ed4a0ff2d21348195..6df000d44e1cf588f3bf95039a10b93b4a4fb17b 100644
--- a/dist/dnd.min.js
+++ b/dist/dnd.min.js
@@ -1 +1 @@
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("react-dom"),require("use-sync-external-store/shim"),require("use-sync-external-store/shim/with-selector")):"function"==typeof define&&define.amd?define(["exports","react","react-dom","use-sync-external-store/shim","use-sync-external-store/shim/with-selector"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ReactBeautifulDnd={},e.React,e.ReactDOM,e.shim)}(this,(function(e,t,r,n){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var i=o(t),a=o(r);function s(){}function l(e,t,r){const n=t.map((t=>{const n=(o=r,i=t.options,{...o,...i});var o,i;return e.addEventListener(t.eventName,t.fn,n),function(){e.removeEventListener(t.eventName,t.fn,n)}}));return function(){n.forEach((e=>{e()}))}}const c="Invariant failed";class d extends Error{}function u(e,t){if(!e)throw new d(c)}d.prototype.toString=function(){return this.message};class p extends i.default.Component{constructor(){super(...arguments),this.callbacks=null,this.unbind=s,this.onWindowError=e=>{const t=this.getCallbacks();t.isDragging()&&t.tryAbort();e.error instanceof d&&e.preventDefault()},this.getCallbacks=()=>{if(!this.callbacks)throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");return this.callbacks},this.setCallbacks=e=>{this.callbacks=e}}componentDidMount(){this.unbind=l(window,[{eventName:"error",fn:this.onWindowError}])}componentDidCatch(e){if(!(e instanceof d))throw e;this.setState({})}componentWillUnmount(){this.unbind()}render(){return this.props.children(this.setCallbacks)}}const f=e=>e+1,g=(e,t)=>{const r=e.droppableId===t.droppableId,n=f(e.index),o=f(t.index);return r?`\n      You have moved the item from position ${n}\n      to position ${o}\n    `:`\n    You have moved the item from position ${n}\n    in list ${e.droppableId}\n    to list ${t.droppableId}\n    in position ${o}\n  `},m=(e,t,r)=>t.droppableId===r.droppableId?`\n      The item ${e}\n      has been combined with ${r.draggableId}`:`\n      The item ${e}\n      in list ${t.droppableId}\n      has been combined with ${r.draggableId}\n      in list ${r.droppableId}\n    `,b=e=>`\n  The item has returned to its starting position\n  of ${f(e.index)}\n`,h={dragHandleUsageInstructions:"\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n",onDragStart:e=>`\n  You have lifted an item in position ${f(e.source.index)}\n`,onDragUpdate:e=>{const t=e.destination;if(t)return g(e.source,t);const r=e.combine;return r?m(e.draggableId,e.source,r):"You are over an area that cannot be dropped on"},onDragEnd:e=>{if("CANCEL"===e.reason)return`\n      Movement cancelled.\n      ${b(e.source)}\n    `;const t=e.destination,r=e.combine;return t?`\n      You have dropped the item.\n      ${g(e.source,t)}\n    `:r?`\n      You have dropped the item.\n      ${m(e.draggableId,e.source,r)}\n    `:`\n    The item has been dropped while not over a drop area.\n    ${b(e.source)}\n  `}};var y=h;function v(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function x(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function I(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?x(Object(r),!0).forEach((function(t){v(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):x(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function D(e){return"Minified Redux error #"+e+"; visit https://redux.js.org/Errors?code="+e+" for the full message or use the non-minified dev environment for full errors. "}var w="function"==typeof Symbol&&Symbol.observable||"@@observable",E=function(){return Math.random().toString(36).substring(7).split("").join(".")},S={INIT:"@@redux/INIT"+E(),REPLACE:"@@redux/REPLACE"+E(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+E()}};function C(e){if("object"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function O(e,t,r){var n;if("function"==typeof t&&"function"==typeof r||"function"==typeof r&&"function"==typeof arguments[3])throw new Error(D(0));if("function"==typeof t&&void 0===r&&(r=t,t=void 0),void 0!==r){if("function"!=typeof r)throw new Error(D(1));return r(O)(e,t)}if("function"!=typeof e)throw new Error(D(2));var o=e,i=t,a=[],s=a,l=!1;function c(){s===a&&(s=a.slice())}function d(){if(l)throw new Error(D(3));return i}function u(e){if("function"!=typeof e)throw new Error(D(4));if(l)throw new Error(D(5));var t=!0;return c(),s.push(e),function(){if(t){if(l)throw new Error(D(6));t=!1,c();var r=s.indexOf(e);s.splice(r,1),a=null}}}function p(e){if(!C(e))throw new Error(D(7));if(void 0===e.type)throw new Error(D(8));if(l)throw new Error(D(9));try{l=!0,i=o(i,e)}finally{l=!1}for(var t=a=s,r=0;r<t.length;r++){(0,t[r])()}return e}function f(e){if("function"!=typeof e)throw new Error(D(10));o=e,p({type:S.REPLACE})}function g(){var e,t=u;return(e={subscribe:function(e){if("object"!=typeof e||null===e)throw new Error(D(11));function r(){e.next&&e.next(d())}return r(),{unsubscribe:t(r)}}})[w]=function(){return this},e}return p({type:S.INIT}),(n={dispatch:p,subscribe:u,getState:d,replaceReducer:f})[w]=g,n}function A(e,t){return function(){return t(e.apply(this,arguments))}}function P(e,t){if("function"==typeof e)return A(e,t);if("object"!=typeof e||null===e)throw new Error(D(16));var r={};for(var n in e){var o=e[n];"function"==typeof o&&(r[n]=A(o,t))}return r}function R(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce((function(e,t){return function(){return e(t.apply(void 0,arguments))}}))}let N=function(e){e()};const B=()=>N,T=t.createContext(null);function L(){return L=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},L.apply(this,arguments)}function M(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}var G,_={exports:{}},F={};!function(e){e.exports=function(){if(G)return F;G=1;var e="function"==typeof Symbol&&Symbol.for,t=e?Symbol.for("react.element"):60103,r=e?Symbol.for("react.portal"):60106,n=e?Symbol.for("react.fragment"):60107,o=e?Symbol.for("react.strict_mode"):60108,i=e?Symbol.for("react.profiler"):60114,a=e?Symbol.for("react.provider"):60109,s=e?Symbol.for("react.context"):60110,l=e?Symbol.for("react.async_mode"):60111,c=e?Symbol.for("react.concurrent_mode"):60111,d=e?Symbol.for("react.forward_ref"):60112,u=e?Symbol.for("react.suspense"):60113,p=e?Symbol.for("react.suspense_list"):60120,f=e?Symbol.for("react.memo"):60115,g=e?Symbol.for("react.lazy"):60116,m=e?Symbol.for("react.block"):60121,b=e?Symbol.for("react.fundamental"):60117,h=e?Symbol.for("react.responder"):60118,y=e?Symbol.for("react.scope"):60119;function v(e){if("object"==typeof e&&null!==e){var p=e.$$typeof;switch(p){case t:switch(e=e.type){case l:case c:case n:case i:case o:case u:return e;default:switch(e=e&&e.$$typeof){case s:case d:case g:case f:case a:return e;default:return p}}case r:return p}}}function x(e){return v(e)===c}return F.AsyncMode=l,F.ConcurrentMode=c,F.ContextConsumer=s,F.ContextProvider=a,F.Element=t,F.ForwardRef=d,F.Fragment=n,F.Lazy=g,F.Memo=f,F.Portal=r,F.Profiler=i,F.StrictMode=o,F.Suspense=u,F.isAsyncMode=function(e){return x(e)||v(e)===l},F.isConcurrentMode=x,F.isContextConsumer=function(e){return v(e)===s},F.isContextProvider=function(e){return v(e)===a},F.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===t},F.isForwardRef=function(e){return v(e)===d},F.isFragment=function(e){return v(e)===n},F.isLazy=function(e){return v(e)===g},F.isMemo=function(e){return v(e)===f},F.isPortal=function(e){return v(e)===r},F.isProfiler=function(e){return v(e)===i},F.isStrictMode=function(e){return v(e)===o},F.isSuspense=function(e){return v(e)===u},F.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===n||e===c||e===i||e===o||e===u||e===p||"object"==typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===f||e.$$typeof===a||e.$$typeof===s||e.$$typeof===d||e.$$typeof===b||e.$$typeof===h||e.$$typeof===y||e.$$typeof===m)},F.typeOf=v,F}()}(_);var $=_.exports,W={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},k={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},j={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},U={};function H(e){return $.isMemo(e)?j:U[e.$$typeof]||W}U[$.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},U[$.Memo]=j;var q=Object.defineProperty,V=Object.getOwnPropertyNames,z=Object.getOwnPropertySymbols,Y=Object.getOwnPropertyDescriptor,J=Object.getPrototypeOf,X=Object.prototype;var K,Q=function e(t,r,n){if("string"!=typeof r){if(X){var o=J(r);o&&o!==X&&e(t,o,n)}var i=V(r);z&&(i=i.concat(z(r)));for(var a=H(t),s=H(r),l=0;l<i.length;++l){var c=i[l];if(!(k[c]||n&&n[c]||s&&s[c]||a&&a[c])){var d=Y(r,c);try{q(t,c,d)}catch(e){}}}}return t},Z={exports:{}},ee={};!function(e){e.exports=function(){if(K)return ee;K=1;var e,t=Symbol.for("react.element"),r=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),s=Symbol.for("react.context"),l=Symbol.for("react.server_context"),c=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),u=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function m(e){if("object"==typeof e&&null!==e){var g=e.$$typeof;switch(g){case t:switch(e=e.type){case n:case i:case o:case d:case u:return e;default:switch(e=e&&e.$$typeof){case l:case s:case c:case f:case p:case a:return e;default:return g}}case r:return g}}}return e=Symbol.for("react.module.reference"),ee.ContextConsumer=s,ee.ContextProvider=a,ee.Element=t,ee.ForwardRef=c,ee.Fragment=n,ee.Lazy=f,ee.Memo=p,ee.Portal=r,ee.Profiler=i,ee.StrictMode=o,ee.Suspense=d,ee.SuspenseList=u,ee.isAsyncMode=function(){return!1},ee.isConcurrentMode=function(){return!1},ee.isContextConsumer=function(e){return m(e)===s},ee.isContextProvider=function(e){return m(e)===a},ee.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===t},ee.isForwardRef=function(e){return m(e)===c},ee.isFragment=function(e){return m(e)===n},ee.isLazy=function(e){return m(e)===f},ee.isMemo=function(e){return m(e)===p},ee.isPortal=function(e){return m(e)===r},ee.isProfiler=function(e){return m(e)===i},ee.isStrictMode=function(e){return m(e)===o},ee.isSuspense=function(e){return m(e)===d},ee.isSuspenseList=function(e){return m(e)===u},ee.isValidElementType=function(t){return"string"==typeof t||"function"==typeof t||t===n||t===i||t===o||t===d||t===u||t===g||"object"==typeof t&&null!==t&&(t.$$typeof===f||t.$$typeof===p||t.$$typeof===a||t.$$typeof===s||t.$$typeof===c||t.$$typeof===e||void 0!==t.getModuleId)},ee.typeOf=m,ee}()}(Z);const te=["initMapStateToProps","initMapDispatchToProps","initMergeProps"];function re(e,t,r,n,{areStatesEqual:o,areOwnPropsEqual:i,areStatePropsEqual:a}){let s,l,c,d,u,p=!1;function f(p,f){const g=!i(f,l),m=!o(p,s,f,l);return s=p,l=f,g&&m?(c=e(s,l),t.dependsOnOwnProps&&(d=t(n,l)),u=r(c,d,l),u):g?(e.dependsOnOwnProps&&(c=e(s,l)),t.dependsOnOwnProps&&(d=t(n,l)),u=r(c,d,l),u):m?function(){const t=e(s,l),n=!a(t,c);return c=t,n&&(u=r(c,d,l)),u}():u}return function(o,i){return p?f(o,i):(s=o,l=i,c=e(s,l),d=t(n,l),u=r(c,d,l),p=!0,u)}}function ne(e){return function(t){const r=e(t);function n(){return r}return n.dependsOnOwnProps=!1,n}}function oe(e){return e.dependsOnOwnProps?Boolean(e.dependsOnOwnProps):1!==e.length}function ie(e,t){return function(t,{displayName:r}){const n=function(e,t){return n.dependsOnOwnProps?n.mapToProps(e,t):n.mapToProps(e,void 0)};return n.dependsOnOwnProps=!0,n.mapToProps=function(t,r){n.mapToProps=e,n.dependsOnOwnProps=oe(e);let o=n(t,r);return"function"==typeof o&&(n.mapToProps=o,n.dependsOnOwnProps=oe(o),o=n(t,r)),o},n}}function ae(e,t){return(r,n)=>{throw new Error(`Invalid value of type ${typeof e} for ${t} argument when connecting component ${n.wrappedComponentName}.`)}}function se(e,t,r){return L({},r,e,t)}const le={notify(){},get:()=>[]};function ce(e,t){let r,n=le;function o(){a.onStateChange&&a.onStateChange()}function i(){r||(r=t?t.addNestedSub(o):e.subscribe(o),n=function(){const e=B();let t=null,r=null;return{clear(){t=null,r=null},notify(){e((()=>{let e=t;for(;e;)e.callback(),e=e.next}))},get(){let e=[],r=t;for(;r;)e.push(r),r=r.next;return e},subscribe(e){let n=!0,o=r={callback:e,next:null,prev:r};return o.prev?o.prev.next=o:t=o,function(){n&&null!==t&&(n=!1,o.next?o.next.prev=o.prev:r=o.prev,o.prev?o.prev.next=o.next:t=o.next)}}}}())}const a={addNestedSub:function(e){return i(),n.subscribe(e)},notifyNestedSubs:function(){n.notify()},handleChangeWrapper:o,isSubscribed:function(){return Boolean(r)},trySubscribe:i,tryUnsubscribe:function(){r&&(r(),r=void 0,n.clear(),n=le)},getListeners:()=>n};return a}const de=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement)?t.useLayoutEffect:t.useEffect;function ue(e,t){return e===t?0!==e||0!==t||1/e==1/t:e!=e&&t!=t}function pe(e,t){if(ue(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let n=0;n<r.length;n++)if(!Object.prototype.hasOwnProperty.call(t,r[n])||!ue(e[r[n]],t[r[n]]))return!1;return!0}const fe=["reactReduxForwardedRef"];let ge=()=>{throw new Error("uSES not initialized!")};const me=[null,null];function be(e,t,r,n,o,i){e.current=n,r.current=!1,o.current&&(o.current=null,i())}function he(e,t){return e===t}function ye(e,r,n,{pure:o,areStatesEqual:a=he,areOwnPropsEqual:s=pe,areStatePropsEqual:l=pe,areMergedPropsEqual:c=pe,forwardRef:d=!1,context:u=T}={}){const p=u,f=function(e){return e?"function"==typeof e?ie(e):ae(e,"mapStateToProps"):ne((()=>({})))}(e),g=function(e){return e&&"object"==typeof e?ne((t=>function(e,t){const r={};for(const n in e){const o=e[n];"function"==typeof o&&(r[n]=(...e)=>t(o(...e)))}return r}(e,t))):e?"function"==typeof e?ie(e):ae(e,"mapDispatchToProps"):ne((e=>({dispatch:e})))}(r),m=function(e){return e?"function"==typeof e?function(e){return function(t,{displayName:r,areMergedPropsEqual:n}){let o,i=!1;return function(t,r,a){const s=e(t,r,a);return i?n(s,o)||(o=s):(i=!0,o=s),o}}}(e):ae(e,"mergeProps"):()=>se}(n),b=Boolean(e);return e=>{const r=e.displayName||e.name||"Component",n=`Connect(${r})`,o={shouldHandleStateChanges:b,displayName:n,wrappedComponentName:r,WrappedComponent:e,initMapStateToProps:f,initMapDispatchToProps:g,initMergeProps:m,areStatesEqual:a,areStatePropsEqual:l,areOwnPropsEqual:s,areMergedPropsEqual:c};function u(r){const[n,a,s]=t.useMemo((()=>{const{reactReduxForwardedRef:e}=r,t=M(r,fe);return[r.context,e,t]}),[r]),l=t.useMemo((()=>n&&n.Consumer&&Z.exports.isContextConsumer(i.default.createElement(n.Consumer,null))?n:p),[n,p]),c=t.useContext(l),d=Boolean(r.store)&&Boolean(r.store.getState)&&Boolean(r.store.dispatch),u=Boolean(c)&&Boolean(c.store),f=d?r.store:c.store,g=u?c.getServerState:f.getState,m=t.useMemo((()=>function(e,t){let{initMapStateToProps:r,initMapDispatchToProps:n,initMergeProps:o}=t,i=M(t,te);return re(r(e,i),n(e,i),o(e,i),e,i)}(f.dispatch,o)),[f]),[h,y]=t.useMemo((()=>{if(!b)return me;const e=ce(f,d?void 0:c.subscription),t=e.notifyNestedSubs.bind(e);return[e,t]}),[f,d,c]),v=t.useMemo((()=>d?c:L({},c,{subscription:h})),[d,c,h]),x=t.useRef(),I=t.useRef(s),D=t.useRef(),w=t.useRef(!1);t.useRef(!1);const E=t.useRef(!1),S=t.useRef();de((()=>(E.current=!0,()=>{E.current=!1})),[]);const C=t.useMemo((()=>()=>D.current&&s===I.current?D.current:m(f.getState(),s)),[f,s]),O=t.useMemo((()=>e=>h?function(e,t,r,n,o,i,a,s,l,c,d){if(!e)return()=>{};let u=!1,p=null;const f=()=>{if(u||!s.current)return;const e=t.getState();let r,f;try{r=n(e,o.current)}catch(e){f=e,p=e}f||(p=null),r===i.current?a.current||c():(i.current=r,l.current=r,a.current=!0,d())};return r.onStateChange=f,r.trySubscribe(),f(),()=>{if(u=!0,r.tryUnsubscribe(),r.onStateChange=null,p)throw p}}(b,f,h,m,I,x,w,E,D,y,e):()=>{}),[h]);var A,P,R;let N;A=be,P=[I,x,w,s,D,y],de((()=>A(...P)),R);try{N=ge(O,C,g?()=>m(g(),s):C)}catch(e){throw S.current&&(e.message+=`\nThe error may be correlated with this previous error:\n${S.current.stack}\n\n`),e}de((()=>{S.current=void 0,D.current=void 0,x.current=N}));const B=t.useMemo((()=>i.default.createElement(e,L({},N,{ref:a}))),[a,e,N]);return t.useMemo((()=>b?i.default.createElement(l.Provider,{value:v},B):B),[l,B,v])}const h=i.default.memo(u);if(h.WrappedComponent=e,h.displayName=u.displayName=n,d){const t=i.default.forwardRef((function(e,t){return i.default.createElement(h,L({},e,{reactReduxForwardedRef:t}))}));return t.displayName=n,t.WrappedComponent=e,Q(t,e)}return Q(h,e)}}function ve({store:e,context:r,children:n,serverState:o}){const a=t.useMemo((()=>{const t=ce(e);return{store:e,subscription:t,getServerState:o?()=>o:void 0}}),[e,o]),s=t.useMemo((()=>e.getState()),[e]);de((()=>{const{subscription:t}=a;return t.onStateChange=t.notifyNestedSubs,t.trySubscribe(),s!==e.getState()&&t.notifyNestedSubs(),()=>{t.tryUnsubscribe(),t.onStateChange=void 0}}),[a,s]);const l=r||T;return i.default.createElement(l.Provider,{value:a},n)}var xe,Ie;function De(e,r){var n=t.useState((function(){return{inputs:r,result:e()}}))[0],o=t.useRef(!0),i=t.useRef(n),a=o.current||Boolean(r&&i.current.inputs&&function(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}(r,i.current.inputs))?i.current:{inputs:r,result:e()};return t.useEffect((function(){o.current=!1,i.current=a}),[a]),a.result}xe=n.useSyncExternalStore,ge=xe,Ie=r.unstable_batchedUpdates,N=Ie;var we=De,Ee=function(e,t){return De((function(){return e}),t)};const Se={x:0,y:0},Ce=(e,t)=>({x:e.x+t.x,y:e.y+t.y}),Oe=(e,t)=>({x:e.x-t.x,y:e.y-t.y}),Ae=(e,t)=>e.x===t.x&&e.y===t.y,Pe=e=>({x:0!==e.x?-e.x:0,y:0!==e.y?-e.y:0}),Re=function(e,t,r){return void 0===r&&(r=0),"x"===e?{x:t,y:r}:{x:r,y:t}},Ne=(e,t)=>Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2),Be=(e,t)=>Math.min(...t.map((t=>Ne(e,t)))),Te=e=>t=>({x:e(t.x),y:e(t.y)});var Le=function(e){var t=e.top,r=e.right,n=e.bottom,o=e.left;return{top:t,right:r,bottom:n,left:o,width:r-o,height:n-t,x:o,y:t,center:{x:(r+o)/2,y:(n+t)/2}}},Me=function(e,t){return{top:e.top-t.top,left:e.left-t.left,bottom:e.bottom+t.bottom,right:e.right+t.right}},Ge=function(e,t){return{top:e.top+t.top,left:e.left+t.left,bottom:e.bottom-t.bottom,right:e.right-t.right}},_e={top:0,right:0,bottom:0,left:0},Fe=function(e){var t=e.borderBox,r=e.margin,n=void 0===r?_e:r,o=e.border,i=void 0===o?_e:o,a=e.padding,s=void 0===a?_e:a,l=Le(Me(t,n)),c=Le(Ge(t,i)),d=Le(Ge(c,s));return{marginBox:l,borderBox:Le(t),paddingBox:c,contentBox:d,margin:n,border:i,padding:s}},$e=function(e){var t=e.slice(0,-2);if("px"!==e.slice(-2))return 0;var r=Number(t);return isNaN(r)&&function(e,t){if(!e)throw new Error("Invariant failed")}(!1),r},We=function(e,t){var r,n,o=e.borderBox,i=e.border,a=e.margin,s=e.padding,l=(n=t,{top:(r=o).top+n.y,left:r.left+n.x,bottom:r.bottom+n.y,right:r.right+n.x});return Fe({borderBox:l,border:i,margin:a,padding:s})},ke=function(e,t){return void 0===t&&(t={x:window.pageXOffset,y:window.pageYOffset}),We(e,t)},je=function(e,t){var r={top:$e(t.marginTop),right:$e(t.marginRight),bottom:$e(t.marginBottom),left:$e(t.marginLeft)},n={top:$e(t.paddingTop),right:$e(t.paddingRight),bottom:$e(t.paddingBottom),left:$e(t.paddingLeft)},o={top:$e(t.borderTopWidth),right:$e(t.borderRightWidth),bottom:$e(t.borderBottomWidth),left:$e(t.borderLeftWidth)};return Fe({borderBox:e,margin:r,padding:n,border:o})},Ue=function(e){var t=e.getBoundingClientRect(),r=window.getComputedStyle(e);return je(t,r)};const He=(e,t)=>({top:e.top+t.y,left:e.left+t.x,bottom:e.bottom+t.y,right:e.right+t.x}),qe=e=>[{x:e.left,y:e.top},{x:e.right,y:e.top},{x:e.left,y:e.bottom},{x:e.right,y:e.bottom}],Ve=(e,t)=>t&&t.shouldClipSubject?((e,t)=>{const r=Le({top:Math.max(t.top,e.top),right:Math.min(t.right,e.right),bottom:Math.min(t.bottom,e.bottom),left:Math.max(t.left,e.left)});return r.width<=0||r.height<=0?null:r})(t.pageMarginBox,e):Le(e);var ze=e=>{let{page:t,withPlaceholder:r,axis:n,frame:o}=e;const i=((e,t)=>t?He(e,t.scroll.diff.displacement):e)(t.marginBox,o),a=((e,t,r)=>r&&r.increasedBy?{...e,[t.end]:e[t.end]+r.increasedBy[t.line]}:e)(i,n,r);return{page:t,withPlaceholder:r,active:Ve(a,o)}},Ye=(e,t)=>{e.frame||u(!1);const r=e.frame,n=Oe(t,r.scroll.initial),o=Pe(n),i={...r,scroll:{initial:r.scroll.initial,current:t,diff:{value:n,displacement:o},max:r.scroll.max}},a=ze({page:e.subject.page,withPlaceholder:e.subject.withPlaceholder,axis:e.axis,frame:i});return{...e,frame:i,subject:a}},Je=Number.isNaN||function(e){return"number"==typeof e&&e!=e};function Xe(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(n=e[r],o=t[r],!(n===o||Je(n)&&Je(o)))return!1;var n,o;return!0}function Ke(e,t){void 0===t&&(t=Xe);var r=null;function n(){for(var n=[],o=0;o<arguments.length;o++)n[o]=arguments[o];if(r&&r.lastThis===this&&t(n,r.lastArgs))return r.lastResult;var i=e.apply(this,n);return r={lastResult:i,lastArgs:n,lastThis:this},i}return n.clear=function(){r=null},n}const Qe=Ke((e=>e.reduce(((e,t)=>(e[t.descriptor.id]=t,e)),{}))),Ze=Ke((e=>e.reduce(((e,t)=>(e[t.descriptor.id]=t,e)),{}))),et=Ke((e=>Object.values(e))),tt=Ke((e=>Object.values(e)));var rt=Ke(((e,t)=>{const r=tt(t).filter((t=>e===t.descriptor.droppableId)).sort(((e,t)=>e.descriptor.index-t.descriptor.index));return r}));function nt(e){return e.at&&"REORDER"===e.at.type?e.at.destination:null}function ot(e){return e.at&&"COMBINE"===e.at.type?e.at.combine:null}var it=Ke(((e,t)=>t.filter((t=>t.descriptor.id!==e.descriptor.id)))),at=(e,t)=>e.descriptor.droppableId===t.descriptor.id;const st={point:Se,value:0},lt={invisible:{},visible:{},all:[]};var ct={displaced:lt,displacedBy:st,at:null},dt=(e,t)=>r=>e<=r&&r<=t,ut=e=>{const t=dt(e.top,e.bottom),r=dt(e.left,e.right);return n=>{if(t(n.top)&&t(n.bottom)&&r(n.left)&&r(n.right))return!0;const o=t(n.top)||t(n.bottom),i=r(n.left)||r(n.right);if(o&&i)return!0;const a=n.top<e.top&&n.bottom>e.bottom,s=n.left<e.left&&n.right>e.right;if(a&&s)return!0;return a&&i||s&&o}},pt=e=>{const t=dt(e.top,e.bottom),r=dt(e.left,e.right);return e=>t(e.top)&&t(e.bottom)&&r(e.left)&&r(e.right)};const ft={direction:"vertical",line:"y",crossAxisLine:"x",start:"top",end:"bottom",size:"height",crossAxisStart:"left",crossAxisEnd:"right",crossAxisSize:"width"},gt={direction:"horizontal",line:"x",crossAxisLine:"y",start:"left",end:"right",size:"width",crossAxisStart:"top",crossAxisEnd:"bottom",crossAxisSize:"height"};const mt=e=>{let{target:t,destination:r,viewport:n,withDroppableDisplacement:o,isVisibleThroughFrameFn:i}=e;const a=o?((e,t)=>{const r=t.frame?t.frame.scroll.diff.displacement:Se;return He(e,r)})(t,r):t;return((e,t,r)=>!!t.subject.active&&r(t.subject.active)(e))(a,r,i)&&((e,t,r)=>r(t)(e))(a,n,i)},bt=e=>mt({...e,isVisibleThroughFrameFn:ut}),ht=e=>mt({...e,isVisibleThroughFrameFn:pt});function yt(e){let{afterDragging:t,destination:r,displacedBy:n,viewport:o,forceShouldAnimate:i,last:a}=e;return t.reduce((function(e,t){const s=function(e,t){const r=e.page.marginBox,n={top:t.point.y,right:0,bottom:0,left:t.point.x};return Le(Me(r,n))}(t,n),l=t.descriptor.id;e.all.push(l);if(!bt({target:s,destination:r,viewport:o,withDroppableDisplacement:!0}))return e.invisible[t.descriptor.id]=!0,e;const c=((e,t,r)=>{if("boolean"==typeof r)return r;if(!t)return!0;const{invisible:n,visible:o}=t;if(n[e])return!1;const i=o[e];return!i||i.shouldAnimate})(l,a,i),d={draggableId:l,shouldAnimate:c};return e.visible[l]=d,e}),{all:[],visible:{},invisible:{}})}function vt(e){let{insideDestination:t,inHomeList:r,displacedBy:n,destination:o}=e;const i=function(e,t){if(!e.length)return 0;const r=e[e.length-1].descriptor.index;return t.inHomeList?r:r+1}(t,{inHomeList:r});return{displaced:lt,displacedBy:n,at:{type:"REORDER",destination:{droppableId:o.descriptor.id,index:i}}}}function xt(e){let{draggable:t,insideDestination:r,destination:n,viewport:o,displacedBy:i,last:a,index:s,forceShouldAnimate:l}=e;const c=at(t,n);if(null==s)return vt({insideDestination:r,inHomeList:c,displacedBy:i,destination:n});const d=r.find((e=>e.descriptor.index===s));if(!d)return vt({insideDestination:r,inHomeList:c,displacedBy:i,destination:n});const u=it(t,r),p=r.indexOf(d);return{displaced:yt({afterDragging:u.slice(p),destination:n,displacedBy:i,last:a,viewport:o.frame,forceShouldAnimate:l}),displacedBy:i,at:{type:"REORDER",destination:{droppableId:n.descriptor.id,index:s}}}}function It(e,t){return Boolean(t.effected[e])}var Dt=e=>{let{isMovingForward:t,isInHomeList:r,draggable:n,draggables:o,destination:i,insideDestination:a,previousImpact:s,viewport:l,afterCritical:c}=e;const d=s.at;if(d||u(!1),"REORDER"===d.type){const e=(e=>{let{isMovingForward:t,isInHomeList:r,insideDestination:n,location:o}=e;if(!n.length)return null;const i=o.index,a=t?i+1:i-1,s=n[0].descriptor.index,l=n[n.length-1].descriptor.index;return a<s||a>(r?l:l+1)?null:a})({isMovingForward:t,isInHomeList:r,location:d.destination,insideDestination:a});return null==e?null:xt({draggable:n,insideDestination:a,destination:i,viewport:l,last:s.displaced,displacedBy:s.displacedBy,index:e})}const p=(e=>{let{isMovingForward:t,destination:r,draggables:n,combine:o,afterCritical:i}=e;if(!r.isCombineEnabled)return null;const a=o.draggableId,s=n[a].descriptor.index;return It(a,i)?t?s:s-1:t?s+1:s})({isMovingForward:t,destination:i,displaced:s.displaced,draggables:o,combine:d.combine,afterCritical:c});return null==p?null:xt({draggable:n,insideDestination:a,destination:i,viewport:l,last:s.displaced,displacedBy:s.displacedBy,index:p})},wt=e=>{let{afterCritical:t,impact:r,draggables:n}=e;const o=ot(r);o||u(!1);const i=o.draggableId,a=n[i].page.borderBox.center,s=(e=>{let{displaced:t,afterCritical:r,combineWith:n,displacedBy:o}=e;const i=Boolean(t.visible[n]||t.invisible[n]);return It(n,r)?i?Se:Pe(o.point):i?o.point:Se})({displaced:r.displaced,afterCritical:t,combineWith:i,displacedBy:r.displacedBy});return Ce(a,s)};const Et=(e,t)=>t.margin[e.start]+t.borderBox[e.size]/2,St=(e,t,r)=>t[e.crossAxisStart]+r.margin[e.crossAxisStart]+r.borderBox[e.crossAxisSize]/2,Ct=e=>{let{axis:t,moveRelativeTo:r,isMoving:n}=e;return Re(t.line,r.marginBox[t.end]+Et(t,n),St(t,r.marginBox,n))},Ot=e=>{let{axis:t,moveRelativeTo:r,isMoving:n}=e;return Re(t.line,r.marginBox[t.start]-((e,t)=>t.margin[e.end]+t.borderBox[e.size]/2)(t,n),St(t,r.marginBox,n))};var At=e=>{let{impact:t,draggable:r,draggables:n,droppable:o,afterCritical:i}=e;const a=rt(o.descriptor.id,n),s=r.page,l=o.axis;if(!a.length)return(e=>{let{axis:t,moveInto:r,isMoving:n}=e;return Re(t.line,r.contentBox[t.start]+Et(t,n),St(t,r.contentBox,n))})({axis:l,moveInto:o.page,isMoving:s});const{displaced:c,displacedBy:d}=t,u=c.all[0];if(u){const e=n[u];if(It(u,i))return Ot({axis:l,moveRelativeTo:e.page,isMoving:s});const t=We(e.page,d.point);return Ot({axis:l,moveRelativeTo:t,isMoving:s})}const p=a[a.length-1];if(p.descriptor.id===r.descriptor.id)return s.borderBox.center;if(It(p.descriptor.id,i)){const e=We(p.page,Pe(i.displacedBy.point));return Ct({axis:l,moveRelativeTo:e,isMoving:s})}return Ct({axis:l,moveRelativeTo:p.page,isMoving:s})},Pt=(e,t)=>{const r=e.frame;return r?Ce(t,r.scroll.diff.displacement):t};var Rt=e=>{const t=(e=>{let{impact:t,draggable:r,droppable:n,draggables:o,afterCritical:i}=e;const a=r.page.borderBox.center,s=t.at;return n&&s?"REORDER"===s.type?At({impact:t,draggable:r,draggables:o,droppable:n,afterCritical:i}):wt({impact:t,draggables:o,afterCritical:i}):a})(e),r=e.droppable;return r?Pt(r,t):t},Nt=(e,t)=>{const r=Oe(t,e.scroll.initial),n=Pe(r);return{frame:Le({top:t.y,bottom:t.y+e.frame.height,left:t.x,right:t.x+e.frame.width}),scroll:{initial:e.scroll.initial,max:e.scroll.max,current:t,diff:{value:r,displacement:n}}}};function Bt(e,t){return e.map((e=>t[e]))}var Tt=e=>{let{pageBorderBoxCenter:t,draggable:r,viewport:n}=e;const o=((e,t)=>Ce(e.scroll.diff.displacement,t))(n,t),i=Oe(o,r.page.borderBox.center);return Ce(r.client.borderBox.center,i)},Lt=e=>{let{draggable:t,destination:r,newPageBorderBoxCenter:n,viewport:o,withDroppableDisplacement:i,onlyOnMainAxis:a=!1}=e;const s=Oe(n,t.page.borderBox.center),l={target:He(t.page.borderBox,s),destination:r,withDroppableDisplacement:i,viewport:o};return a?(e=>{return mt({...e,isVisibleThroughFrameFn:(t=e.destination.axis,e=>{const r=dt(e.top,e.bottom),n=dt(e.left,e.right);return e=>t===ft?r(e.top)&&r(e.bottom):n(e.left)&&n(e.right)})});var t})(l):ht(l)},Mt=e=>{let{isMovingForward:t,draggable:r,destination:n,draggables:o,previousImpact:i,viewport:a,previousPageBorderBoxCenter:s,previousClientSelection:l,afterCritical:c}=e;if(!n.isEnabled)return null;const d=rt(n.descriptor.id,o),p=at(r,n),f=(e=>{let{isMovingForward:t,draggable:r,destination:n,insideDestination:o,previousImpact:i}=e;if(!n.isCombineEnabled)return null;if(!nt(i))return null;function a(e){const t={type:"COMBINE",combine:{draggableId:e,droppableId:n.descriptor.id}};return{...i,at:t}}const s=i.displaced.all,l=s.length?s[0]:null;if(t)return l?a(l):null;const c=it(r,o);if(!l)return c.length?a(c[c.length-1].descriptor.id):null;const d=c.findIndex((e=>e.descriptor.id===l));-1===d&&u(!1);const p=d-1;return p<0?null:a(c[p].descriptor.id)})({isMovingForward:t,draggable:r,destination:n,insideDestination:d,previousImpact:i})||Dt({isMovingForward:t,isInHomeList:p,draggable:r,draggables:o,destination:n,insideDestination:d,previousImpact:i,viewport:a,afterCritical:c});if(!f)return null;const g=Rt({impact:f,draggable:r,droppable:n,draggables:o,afterCritical:c});if(Lt({draggable:r,destination:n,newPageBorderBoxCenter:g,viewport:a.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})){return{clientSelection:Tt({pageBorderBoxCenter:g,draggable:r,viewport:a}),impact:f,scrollJumpRequest:null}}const m=Oe(g,s),b=(e=>{let{impact:t,viewport:r,destination:n,draggables:o,maxScrollChange:i}=e;const a=Nt(r,Ce(r.scroll.current,i)),s=n.frame?Ye(n,Ce(n.frame.scroll.current,i)):n,l=t.displaced,c=yt({afterDragging:Bt(l.all,o),destination:n,displacedBy:t.displacedBy,viewport:a.frame,last:l,forceShouldAnimate:!1}),d=yt({afterDragging:Bt(l.all,o),destination:s,displacedBy:t.displacedBy,viewport:r.frame,last:l,forceShouldAnimate:!1}),u={},p={},f=[l,c,d];return l.all.forEach((e=>{const t=function(e,t){for(let r=0;r<t.length;r++){const n=t[r].visible[e];if(n)return n}return null}(e,f);t?p[e]=t:u[e]=!0})),{...t,displaced:{all:l.all,invisible:u,visible:p}}})({impact:f,viewport:a,destination:n,draggables:o,maxScrollChange:m});return{clientSelection:l,impact:b,scrollJumpRequest:m}};const Gt=e=>{const t=e.subject.active;return t||u(!1),t};const _t=(e,t)=>{const r=e.page.borderBox.center;return It(e.descriptor.id,t)?Oe(r,t.displacedBy.point):r},Ft=(e,t)=>{const r=e.page.borderBox;return It(e.descriptor.id,t)?He(r,Pe(t.displacedBy.point)):r};var $t=Ke((function(e,t){const r=t[e.line];return{value:r,point:Re(e.line,r)}}));const Wt=(e,t)=>({...e,scroll:{...e.scroll,max:t}}),kt=(e,t,r)=>{const n=e.frame;at(t,e)&&u(!1),e.subject.withPlaceholder&&u(!1);const o=$t(e.axis,t.displaceBy).point,i=((e,t,r)=>{const n=e.axis;if("virtual"===e.descriptor.mode)return Re(n.line,t[n.line]);const o=e.subject.page.contentBox[n.size],i=rt(e.descriptor.id,r).reduce(((e,t)=>e+t.client.marginBox[n.size]),0)+t[n.line]-o;return i<=0?null:Re(n.line,i)})(e,o,r),a={placeholderSize:o,increasedBy:i,oldFrameMaxScroll:e.frame?e.frame.scroll.max:null};if(!n){const t=ze({page:e.subject.page,withPlaceholder:a,axis:e.axis,frame:e.frame});return{...e,subject:t}}const s=i?Ce(n.scroll.max,i):n.scroll.max,l=Wt(n,s),c=ze({page:e.subject.page,withPlaceholder:a,axis:e.axis,frame:l});return{...e,subject:c,frame:l}};var jt=e=>{let{isMovingForward:t,previousPageBorderBoxCenter:r,draggable:n,isOver:o,draggables:i,droppables:a,viewport:s,afterCritical:l}=e;const c=(e=>{let{isMovingForward:t,pageBorderBoxCenter:r,source:n,droppables:o,viewport:i}=e;const a=n.subject.active;if(!a)return null;const s=n.axis,l=dt(a[s.start],a[s.end]),c=et(o).filter((e=>e!==n)).filter((e=>e.isEnabled)).filter((e=>Boolean(e.subject.active))).filter((e=>ut(i.frame)(Gt(e)))).filter((e=>{const r=Gt(e);return t?a[s.crossAxisEnd]<r[s.crossAxisEnd]:r[s.crossAxisStart]<a[s.crossAxisStart]})).filter((e=>{const t=Gt(e),r=dt(t[s.start],t[s.end]);return l(t[s.start])||l(t[s.end])||r(a[s.start])||r(a[s.end])})).sort(((e,r)=>{const n=Gt(e)[s.crossAxisStart],o=Gt(r)[s.crossAxisStart];return t?n-o:o-n})).filter(((e,t,r)=>Gt(e)[s.crossAxisStart]===Gt(r[0])[s.crossAxisStart]));if(!c.length)return null;if(1===c.length)return c[0];const d=c.filter((e=>dt(Gt(e)[s.start],Gt(e)[s.end])(r[s.line])));return 1===d.length?d[0]:d.length>1?d.sort(((e,t)=>Gt(e)[s.start]-Gt(t)[s.start]))[0]:c.sort(((e,t)=>{const n=Be(r,qe(Gt(e))),o=Be(r,qe(Gt(t)));return n!==o?n-o:Gt(e)[s.start]-Gt(t)[s.start]}))[0]})({isMovingForward:t,pageBorderBoxCenter:r,source:o,droppables:a,viewport:s});if(!c)return null;const d=rt(c.descriptor.id,i),u=(e=>{let{pageBorderBoxCenter:t,viewport:r,destination:n,insideDestination:o,afterCritical:i}=e;const a=o.filter((e=>ht({target:Ft(e,i),destination:n,viewport:r.frame,withDroppableDisplacement:!0}))).sort(((e,r)=>{const o=Ne(t,Pt(n,_t(e,i))),a=Ne(t,Pt(n,_t(r,i)));return o<a?-1:a<o?1:e.descriptor.index-r.descriptor.index}));return a[0]||null})({pageBorderBoxCenter:r,viewport:s,destination:c,insideDestination:d,afterCritical:l}),p=(e=>{let{previousPageBorderBoxCenter:t,moveRelativeTo:r,insideDestination:n,draggable:o,draggables:i,destination:a,viewport:s,afterCritical:l}=e;if(!r){if(n.length)return null;const e={displaced:lt,displacedBy:st,at:{type:"REORDER",destination:{droppableId:a.descriptor.id,index:0}}},t=Rt({impact:e,draggable:o,droppable:a,draggables:i,afterCritical:l}),r=at(o,a)?a:kt(a,o,i);return Lt({draggable:o,destination:r,newPageBorderBoxCenter:t,viewport:s.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})?e:null}const c=Boolean(t[a.axis.line]<=r.page.borderBox.center[a.axis.line]),d=(()=>{const e=r.descriptor.index;return r.descriptor.id===o.descriptor.id||c?e:e+1})(),u=$t(a.axis,o.displaceBy);return xt({draggable:o,insideDestination:n,destination:a,viewport:s,displacedBy:u,last:lt,index:d})})({previousPageBorderBoxCenter:r,destination:c,draggable:n,draggables:i,moveRelativeTo:u,insideDestination:d,viewport:s,afterCritical:l});if(!p)return null;const f=Rt({impact:p,draggable:n,droppable:c,draggables:i,afterCritical:l});return{clientSelection:Tt({pageBorderBoxCenter:f,draggable:n,viewport:s}),impact:p,scrollJumpRequest:null}},Ut=e=>{const t=e.at;return t?"REORDER"===t.type?t.destination.droppableId:t.combine.droppableId:null};var Ht=e=>{let{state:t,type:r}=e;const n=((e,t)=>{const r=Ut(e);return r?t[r]:null})(t.impact,t.dimensions.droppables),o=Boolean(n),i=t.dimensions.droppables[t.critical.droppable.id],a=n||i,s=a.axis.direction,l="vertical"===s&&("MOVE_UP"===r||"MOVE_DOWN"===r)||"horizontal"===s&&("MOVE_LEFT"===r||"MOVE_RIGHT"===r);if(l&&!o)return null;const c="MOVE_DOWN"===r||"MOVE_RIGHT"===r,d=t.dimensions.draggables[t.critical.draggable.id],u=t.current.page.borderBoxCenter,{draggables:p,droppables:f}=t.dimensions;return l?Mt({isMovingForward:c,previousPageBorderBoxCenter:u,draggable:d,destination:a,draggables:p,viewport:t.viewport,previousClientSelection:t.current.client.selection,previousImpact:t.impact,afterCritical:t.afterCritical}):jt({isMovingForward:c,previousPageBorderBoxCenter:u,draggable:d,isOver:a,draggables:p,droppables:f,viewport:t.viewport,afterCritical:t.afterCritical})};function qt(e){return"DRAGGING"===e.phase||"COLLECTING"===e.phase}function Vt(e){const t=dt(e.top,e.bottom),r=dt(e.left,e.right);return function(e){return t(e.y)&&r(e.x)}}function zt(e){let{pageBorderBox:t,draggable:r,droppables:n}=e;const o=et(n).filter((e=>{if(!e.isEnabled)return!1;const r=e.subject.active;if(!r)return!1;if(o=r,!((n=t).left<o.right&&n.right>o.left&&n.top<o.bottom&&n.bottom>o.top))return!1;var n,o;if(Vt(r)(t.center))return!0;const i=e.axis,a=r.center[i.crossAxisLine],s=t[i.crossAxisStart],l=t[i.crossAxisEnd],c=dt(r[i.crossAxisStart],r[i.crossAxisEnd]),d=c(s),u=c(l);return!d&&!u||(d?s<a:l>a)}));return o.length?1===o.length?o[0].descriptor.id:function(e){let{pageBorderBox:t,draggable:r,candidates:n}=e;const o=r.page.borderBox.center,i=n.map((e=>{const r=e.axis,n=Re(e.axis.line,t.center[r.line],e.page.borderBox.center[r.crossAxisLine]);return{id:e.descriptor.id,distance:Ne(o,n)}})).sort(((e,t)=>t.distance-e.distance));return i[0]?i[0].id:null}({pageBorderBox:t,draggable:r,candidates:o}):null}const Yt=(e,t)=>Le(He(e,t));function Jt(e){let{displaced:t,id:r}=e;return Boolean(t.visible[r]||t.invisible[r])}var Xt=e=>{let{pageOffset:t,draggable:r,draggables:n,droppables:o,previousImpact:i,viewport:a,afterCritical:s}=e;const l=Yt(r.page.borderBox,t),c=zt({pageBorderBox:l,draggable:r,droppables:o});if(!c)return ct;const d=o[c],u=rt(d.descriptor.id,n),p=((e,t)=>{const r=e.frame;return r?Yt(t,r.scroll.diff.value):t})(d,l);return(e=>{let{draggable:t,pageBorderBoxWithDroppableScroll:r,previousImpact:n,destination:o,insideDestination:i,afterCritical:a}=e;if(!o.isCombineEnabled)return null;const s=o.axis,l=$t(o.axis,t.displaceBy),c=l.value,d=r[s.start],u=r[s.end],p=it(t,i).find((e=>{const t=e.descriptor.id,r=e.page.borderBox,o=r[s.size]/4,i=It(t,a),l=Jt({displaced:n.displaced,id:t});return i?l?u>r[s.start]+o&&u<r[s.end]-o:d>r[s.start]-c+o&&d<r[s.end]-c-o:l?u>r[s.start]+c+o&&u<r[s.end]+c-o:d>r[s.start]+o&&d<r[s.end]-o}));return p?{displacedBy:l,displaced:n.displaced,at:{type:"COMBINE",combine:{draggableId:p.descriptor.id,droppableId:o.descriptor.id}}}:null})({pageBorderBoxWithDroppableScroll:p,draggable:r,previousImpact:i,destination:d,insideDestination:u,afterCritical:s})||(e=>{let{pageBorderBoxWithDroppableScroll:t,draggable:r,destination:n,insideDestination:o,last:i,viewport:a,afterCritical:s}=e;const l=n.axis,c=$t(n.axis,r.displaceBy),d=c.value,u=t[l.start],p=t[l.end],f=function(e){let{draggable:t,closest:r,inHomeList:n}=e;return r?n&&r.descriptor.index>t.descriptor.index?r.descriptor.index-1:r.descriptor.index:null}({draggable:r,closest:it(r,o).find((e=>{const t=e.descriptor.id,r=e.page.borderBox.center[l.line],n=It(t,s),o=Jt({displaced:i,id:t});return n?o?p<=r:u<r-d:o?p<=r+d:u<r}))||null,inHomeList:at(r,n)});return xt({draggable:r,insideDestination:o,destination:n,viewport:a,last:i,displacedBy:c,index:f})})({pageBorderBoxWithDroppableScroll:p,draggable:r,destination:d,insideDestination:u,last:i.displaced,viewport:a,afterCritical:s})},Kt=(e,t)=>({...e,[t.descriptor.id]:t});const Qt=e=>{let{previousImpact:t,impact:r,droppables:n}=e;const o=Ut(t),i=Ut(r);if(!o)return n;if(o===i)return n;const a=n[o];if(!a.subject.withPlaceholder)return n;const s=(e=>{const t=e.subject.withPlaceholder;t||u(!1);const r=e.frame;if(!r){const t=ze({page:e.subject.page,axis:e.axis,frame:null,withPlaceholder:null});return{...e,subject:t}}const n=t.oldFrameMaxScroll;n||u(!1);const o=Wt(r,n),i=ze({page:e.subject.page,axis:e.axis,frame:o,withPlaceholder:null});return{...e,subject:i,frame:o}})(a);return Kt(n,s)};var Zt=e=>{let{state:t,clientSelection:r,dimensions:n,viewport:o,impact:i,scrollJumpRequest:a}=e;const s=o||t.viewport,l=n||t.dimensions,c=r||t.current.client.selection,d=Oe(c,t.initial.client.selection),u={offset:d,selection:c,borderBoxCenter:Ce(t.initial.client.borderBoxCenter,d)},p={selection:Ce(u.selection,s.scroll.current),borderBoxCenter:Ce(u.borderBoxCenter,s.scroll.current),offset:Ce(u.offset,s.scroll.diff.value)},f={client:u,page:p};if("COLLECTING"===t.phase)return{...t,dimensions:l,viewport:s,current:f};const g=l.draggables[t.critical.draggable.id],m=i||Xt({pageOffset:p.offset,draggable:g,draggables:l.draggables,droppables:l.droppables,previousImpact:t.impact,viewport:s,afterCritical:t.afterCritical}),b=(e=>{let{draggable:t,draggables:r,droppables:n,previousImpact:o,impact:i}=e;const a=Qt({previousImpact:o,impact:i,droppables:n}),s=Ut(i);if(!s)return a;const l=n[s];if(at(t,l))return a;if(l.subject.withPlaceholder)return a;const c=kt(l,t,r);return Kt(a,c)})({draggable:g,impact:m,previousImpact:t.impact,draggables:l.draggables,droppables:l.droppables});return{...t,current:f,dimensions:{draggables:l.draggables,droppables:b},impact:m,viewport:s,scrollJumpRequest:a||null,forceShouldAnimate:!a&&null}};var er=e=>{let{impact:t,viewport:r,draggables:n,destination:o,forceShouldAnimate:i}=e;const a=t.displaced,s=function(e,t){return e.map((e=>t[e]))}(a.all,n),l=yt({afterDragging:s,destination:o,displacedBy:t.displacedBy,viewport:r.frame,forceShouldAnimate:i,last:a});return{...t,displaced:l}},tr=e=>{let{impact:t,draggable:r,droppable:n,draggables:o,viewport:i,afterCritical:a}=e;const s=Rt({impact:t,draggable:r,draggables:o,droppable:n,afterCritical:a});return Tt({pageBorderBoxCenter:s,draggable:r,viewport:i})},rr=e=>{let{state:t,dimensions:r,viewport:n}=e;"SNAP"!==t.movementMode&&u(!1);const o=t.impact,i=n||t.viewport,a=r||t.dimensions,{draggables:s,droppables:l}=a,c=s[t.critical.draggable.id],d=Ut(o);d||u(!1);const p=l[d],f=er({impact:o,viewport:i,destination:p,draggables:s}),g=tr({impact:f,draggable:c,droppable:p,draggables:s,viewport:i,afterCritical:t.afterCritical});return Zt({impact:f,clientSelection:g,state:t,dimensions:a,viewport:i})},nr=e=>{let{draggable:t,home:r,draggables:n,viewport:o}=e;const i=$t(r.axis,t.displaceBy),a=rt(r.descriptor.id,n),s=a.indexOf(t);-1===s&&u(!1);const l=a.slice(s+1),c=l.reduce(((e,t)=>(e[t.descriptor.id]=!0,e)),{}),d={inVirtualList:"virtual"===r.descriptor.mode,displacedBy:i,effected:c};var p;return{impact:{displaced:yt({afterDragging:l,destination:r,displacedBy:i,last:null,viewport:o.frame,forceShouldAnimate:!1}),displacedBy:i,at:{type:"REORDER",destination:(p=t.descriptor,{index:p.index,droppableId:p.droppableId})}},afterCritical:d}};var or=e=>{let{additions:t,updatedDroppables:r,viewport:n}=e;const o=n.scroll.diff.value;return t.map((e=>{const t=e.descriptor.droppableId,i=(e=>{const t=e.frame;return t||u(!1),t})(r[t]),a=i.scroll.diff.value,s=(e=>{let{draggable:t,offset:r,initialWindowScroll:n}=e;const o=We(t.client,r),i=ke(o,n);return{...t,placeholder:{...t.placeholder,client:o},client:o,page:i}})({draggable:e,offset:Ce(o,a),initialWindowScroll:n.scroll.initial});return s}))};const ir=e=>"SNAP"===e.movementMode,ar=(e,t,r)=>{const n=((e,t)=>({draggables:e.draggables,droppables:Kt(e.droppables,t)}))(e.dimensions,t);return!ir(e)||r?Zt({state:e,dimensions:n}):rr({state:e,dimensions:n})};function sr(e){return e.isDragging&&"SNAP"===e.movementMode?{...e,scrollJumpRequest:null}:e}const lr={phase:"IDLE",completed:null,shouldFlush:!1};var cr=function(e,t){if(void 0===e&&(e=lr),"FLUSH"===t.type)return{...lr,shouldFlush:!0};if("INITIAL_PUBLISH"===t.type){"IDLE"!==e.phase&&u(!1);const{critical:r,clientSelection:n,viewport:o,dimensions:i,movementMode:a}=t.payload,s=i.draggables[r.draggable.id],l=i.droppables[r.droppable.id],c={selection:n,borderBoxCenter:s.client.borderBox.center,offset:Se},d={client:c,page:{selection:Ce(c.selection,o.scroll.initial),borderBoxCenter:Ce(c.selection,o.scroll.initial),offset:Ce(c.selection,o.scroll.diff.value)}},p=et(i.droppables).every((e=>!e.isFixedOnPage)),{impact:f,afterCritical:g}=nr({draggable:s,home:l,draggables:i.draggables,viewport:o});return{phase:"DRAGGING",isDragging:!0,critical:r,movementMode:a,dimensions:i,initial:d,current:d,isWindowScrollAllowed:p,impact:f,afterCritical:g,onLiftImpact:f,viewport:o,scrollJumpRequest:null,forceShouldAnimate:null}}if("COLLECTION_STARTING"===t.type){if("COLLECTING"===e.phase||"DROP_PENDING"===e.phase)return e;"DRAGGING"!==e.phase&&u(!1);return{...e,phase:"COLLECTING"}}if("PUBLISH_WHILE_DRAGGING"===t.type)return"COLLECTING"!==e.phase&&"DROP_PENDING"!==e.phase&&u(!1),(e=>{let{state:t,published:r}=e;const n=r.modified.map((e=>{const r=t.dimensions.droppables[e.droppableId];return Ye(r,e.scroll)})),o={...t.dimensions.droppables,...Qe(n)},i=Ze(or({additions:r.additions,updatedDroppables:o,viewport:t.viewport})),a={...t.dimensions.draggables,...i};r.removals.forEach((e=>{delete a[e]}));const s={droppables:o,draggables:a},l=Ut(t.impact),c=l?s.droppables[l]:null,d=s.draggables[t.critical.draggable.id],u=s.droppables[t.critical.droppable.id],{impact:p,afterCritical:f}=nr({draggable:d,home:u,draggables:a,viewport:t.viewport}),g=c&&c.isCombineEnabled?t.impact:p,m=Xt({pageOffset:t.current.page.offset,draggable:s.draggables[t.critical.draggable.id],draggables:s.draggables,droppables:s.droppables,previousImpact:g,viewport:t.viewport,afterCritical:f}),b={...t,phase:"DRAGGING",impact:m,onLiftImpact:p,dimensions:s,afterCritical:f,forceShouldAnimate:!1};return"COLLECTING"===t.phase?b:{...b,phase:"DROP_PENDING",reason:t.reason,isWaiting:!1}})({state:e,published:t.payload});if("MOVE"===t.type){if("DROP_PENDING"===e.phase)return e;qt(e)||u(!1);const{client:r}=t.payload;return Ae(r,e.current.client.selection)?e:Zt({state:e,clientSelection:r,impact:ir(e)?e.impact:null})}if("UPDATE_DROPPABLE_SCROLL"===t.type){if("DROP_PENDING"===e.phase)return sr(e);if("COLLECTING"===e.phase)return sr(e);qt(e)||u(!1);const{id:r,newScroll:n}=t.payload,o=e.dimensions.droppables[r];if(!o)return e;const i=Ye(o,n);return ar(e,i,!1)}if("UPDATE_DROPPABLE_IS_ENABLED"===t.type){if("DROP_PENDING"===e.phase)return e;qt(e)||u(!1);const{id:r,isEnabled:n}=t.payload,o=e.dimensions.droppables[r];o||u(!1),o.isEnabled===n&&u(!1);const i={...o,isEnabled:n};return ar(e,i,!0)}if("UPDATE_DROPPABLE_IS_COMBINE_ENABLED"===t.type){if("DROP_PENDING"===e.phase)return e;qt(e)||u(!1);const{id:r,isCombineEnabled:n}=t.payload,o=e.dimensions.droppables[r];o||u(!1),o.isCombineEnabled===n&&u(!1);const i={...o,isCombineEnabled:n};return ar(e,i,!0)}if("MOVE_BY_WINDOW_SCROLL"===t.type){if("DROP_PENDING"===e.phase||"DROP_ANIMATING"===e.phase)return e;qt(e)||u(!1),e.isWindowScrollAllowed||u(!1);const r=t.payload.newScroll;if(Ae(e.viewport.scroll.current,r))return sr(e);const n=Nt(e.viewport,r);return ir(e)?rr({state:e,viewport:n}):Zt({state:e,viewport:n})}if("UPDATE_VIEWPORT_MAX_SCROLL"===t.type){if(!qt(e))return e;const r=t.payload.maxScroll;if(Ae(r,e.viewport.scroll.max))return e;const n={...e.viewport,scroll:{...e.viewport.scroll,max:r}};return{...e,viewport:n}}if("MOVE_UP"===t.type||"MOVE_DOWN"===t.type||"MOVE_LEFT"===t.type||"MOVE_RIGHT"===t.type){if("COLLECTING"===e.phase||"DROP_PENDING"===e.phase)return e;"DRAGGING"!==e.phase&&u(!1);const r=Ht({state:e,type:t.type});return r?Zt({state:e,impact:r.impact,clientSelection:r.clientSelection,scrollJumpRequest:r.scrollJumpRequest}):e}if("DROP_PENDING"===t.type){const r=t.payload.reason;"COLLECTING"!==e.phase&&u(!1);return{...e,phase:"DROP_PENDING",isWaiting:!0,reason:r}}if("DROP_ANIMATE"===t.type){const{completed:r,dropDuration:n,newHomeClientOffset:o}=t.payload;"DRAGGING"!==e.phase&&"DROP_PENDING"!==e.phase&&u(!1);return{phase:"DROP_ANIMATING",completed:r,dropDuration:n,newHomeClientOffset:o,dimensions:e.dimensions}}if("DROP_COMPLETE"===t.type){const{completed:e}=t.payload;return{phase:"IDLE",completed:e,shouldFlush:!1}}return e};const dr=e=>({type:"PUBLISH_WHILE_DRAGGING",payload:e}),ur=()=>({type:"COLLECTION_STARTING",payload:null}),pr=e=>({type:"UPDATE_DROPPABLE_SCROLL",payload:e}),fr=e=>({type:"UPDATE_DROPPABLE_IS_ENABLED",payload:e}),gr=e=>({type:"UPDATE_DROPPABLE_IS_COMBINE_ENABLED",payload:e}),mr=e=>({type:"MOVE",payload:e}),br=()=>({type:"MOVE_UP",payload:null}),hr=()=>({type:"MOVE_DOWN",payload:null}),yr=()=>({type:"MOVE_RIGHT",payload:null}),vr=()=>({type:"MOVE_LEFT",payload:null}),xr=e=>({type:"DROP_COMPLETE",payload:e}),Ir=e=>({type:"DROP",payload:e}),Dr=()=>({type:"DROP_ANIMATION_FINISHED",payload:null});const wr="cubic-bezier(.2,1,.1,1)",Er={drop:0,combining:.7},Sr={drop:.75},Cr={outOfTheWay:.2,minDropTime:.33,maxDropTime:.55},Or=`${Cr.outOfTheWay}s ${"cubic-bezier(0.2, 0, 0, 1)"}`,Ar={fluid:`opacity ${Or}`,snap:`transform ${Or}, opacity ${Or}`,drop:e=>{const t=`${e}s ${wr}`;return`transform ${t}, opacity ${t}`},outOfTheWay:`transform ${Or}`,placeholder:`height ${Or}, width ${Or}, margin ${Or}`},Pr=e=>Ae(e,Se)?void 0:`translate(${e.x}px, ${e.y}px)`,Rr=Pr,Nr=(e,t)=>{const r=Pr(e);if(r)return t?`${r} scale(${Sr.drop})`:r},{minDropTime:Br,maxDropTime:Tr}=Cr,Lr=Tr-Br;var Mr=e=>{let{getState:t,dispatch:r}=e;return e=>n=>{if("DROP"!==n.type)return void e(n);const o=t(),i=n.payload.reason;if("COLLECTING"===o.phase)return void r((e=>({type:"DROP_PENDING",payload:e}))({reason:i}));if("IDLE"===o.phase)return;"DROP_PENDING"===o.phase&&o.isWaiting&&u(!1),"DRAGGING"!==o.phase&&"DROP_PENDING"!==o.phase&&u(!1);const a=o.critical,s=o.dimensions,l=s.draggables[o.critical.draggable.id],{impact:c,didDropInsideDroppable:d}=(e=>{let{draggables:t,reason:r,lastImpact:n,home:o,viewport:i,onLiftImpact:a}=e;if(!n.at||"DROP"!==r)return{impact:er({draggables:t,impact:a,destination:o,viewport:i,forceShouldAnimate:!0}),didDropInsideDroppable:!1};return"REORDER"===n.at.type?{impact:n,didDropInsideDroppable:!0}:{impact:{...n,displaced:lt},didDropInsideDroppable:!0}})({reason:i,lastImpact:o.impact,afterCritical:o.afterCritical,onLiftImpact:o.onLiftImpact,home:o.dimensions.droppables[o.critical.droppable.id],viewport:o.viewport,draggables:o.dimensions.draggables}),p=d?nt(c):null,f=d?ot(c):null,g={index:a.draggable.index,droppableId:a.droppable.id},m={draggableId:l.descriptor.id,type:l.descriptor.type,source:g,reason:i,mode:o.movementMode,destination:p,combine:f},b=(e=>{let{impact:t,draggable:r,dimensions:n,viewport:o,afterCritical:i}=e;const{draggables:a,droppables:s}=n,l=Ut(t),c=l?s[l]:null,d=s[r.descriptor.droppableId],u=tr({impact:t,draggable:r,draggables:a,afterCritical:i,droppable:c||d,viewport:o});return Oe(u,r.client.borderBox.center)})({impact:c,draggable:l,dimensions:s,viewport:o.viewport,afterCritical:o.afterCritical}),h={critical:o.critical,afterCritical:o.afterCritical,result:m,impact:c};if(!(!Ae(o.current.client.offset,b)||Boolean(m.combine)))return void r(xr({completed:h}));const y=(e=>{let{current:t,destination:r,reason:n}=e;const o=Ne(t,r);if(o<=0)return Br;if(o>=1500)return Tr;const i=Br+Lr*(o/1500);return Number(("CANCEL"===n?.6*i:i).toFixed(2))})({current:o.current.client.offset,destination:b,reason:i});r((e=>({type:"DROP_ANIMATE",payload:e}))({newHomeClientOffset:b,dropDuration:y,completed:h}))}},Gr=function(e){var t=[],r=null,n=function(){for(var n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];t=o,r||(r=requestAnimationFrame((function(){r=null,e.apply(void 0,t)})))};return n.cancel=function(){r&&(cancelAnimationFrame(r),r=null)},n},_r=()=>({x:window.pageXOffset,y:window.pageYOffset});function Fr(e){let{onWindowScroll:t}=e;const r=Gr((function(){t(_r())})),n=function(e){return{eventName:"scroll",options:{passive:!0,capture:!1},fn:t=>{t.target!==window&&t.target!==window.document||e()}}}(r);let o=s;function i(){return o!==s}return{start:function(){i()&&u(!1),o=l(window,[n])},stop:function(){i()||u(!1),r.cancel(),o(),o=s},isActive:i}}var $r=e=>{const t=Fr({onWindowScroll:t=>{e.dispatch({type:"MOVE_BY_WINDOW_SCROLL",payload:{newScroll:t}})}});return e=>r=>{t.isActive()||"INITIAL_PUBLISH"!==r.type||t.start(),t.isActive()&&(e=>"DROP_COMPLETE"===e.type||"DROP_ANIMATE"===e.type||"FLUSH"===e.type)(r)&&t.stop(),e(r)}},Wr=()=>{const e=[];return{add:t=>{const r=setTimeout((()=>(t=>{const r=e.findIndex((e=>e.timerId===t));-1===r&&u(!1);const[n]=e.splice(r,1);n.callback()})(r))),n={timerId:r,callback:t};e.push(n)},flush:()=>{if(!e.length)return;const t=[...e];e.length=0,t.forEach((e=>{clearTimeout(e.timerId),e.callback()}))}}};const kr=(e,t)=>{t()},jr=(e,t)=>({draggableId:e.draggable.id,type:e.droppable.type,source:{droppableId:e.droppable.id,index:e.draggable.index},mode:t});function Ur(e,t,r,n){if(!e)return void r(n(t));const o=(e=>{let t=!1,r=!1;const n=setTimeout((()=>{r=!0})),o=o=>{t||r||(t=!0,e(o),clearTimeout(n))};return o.wasCalled=()=>t,o})(r);e(t,{announce:o}),o.wasCalled()||r(n(t))}var Hr=(e,t)=>{const r=((e,t)=>{const r=Wr();let n=null;const o=r=>{n||u(!1),n=null,kr(0,(()=>Ur(e().onDragEnd,r,t,y.onDragEnd)))};return{beforeCapture:(t,r)=>{n&&u(!1),kr(0,(()=>{const n=e().onBeforeCapture;n&&n({draggableId:t,mode:r})}))},beforeStart:(t,r)=>{n&&u(!1),kr(0,(()=>{const n=e().onBeforeDragStart;n&&n(jr(t,r))}))},start:(o,i)=>{n&&u(!1);const a=jr(o,i);n={mode:i,lastCritical:o,lastLocation:a.source,lastCombine:null},r.add((()=>{kr(0,(()=>Ur(e().onDragStart,a,t,y.onDragStart)))}))},update:(o,i)=>{const a=nt(i),s=ot(i);n||u(!1);const l=!((e,t)=>{if(e===t)return!0;const r=e.draggable.id===t.draggable.id&&e.draggable.droppableId===t.draggable.droppableId&&e.draggable.type===t.draggable.type&&e.draggable.index===t.draggable.index,n=e.droppable.id===t.droppable.id&&e.droppable.type===t.droppable.type;return r&&n})(o,n.lastCritical);l&&(n.lastCritical=o);const c=(p=a,!(null==(d=n.lastLocation)&&null==p||null!=d&&null!=p&&d.droppableId===p.droppableId&&d.index===p.index));var d,p;c&&(n.lastLocation=a);const f=!((e,t)=>null==e&&null==t||null!=e&&null!=t&&e.draggableId===t.draggableId&&e.droppableId===t.droppableId)(n.lastCombine,s);if(f&&(n.lastCombine=s),!l&&!c&&!f)return;const g={...jr(o,n.mode),combine:s,destination:a};r.add((()=>{kr(0,(()=>Ur(e().onDragUpdate,g,t,y.onDragUpdate)))}))},flush:()=>{n||u(!1),r.flush()},drop:o,abort:()=>{if(!n)return;const e={...jr(n.lastCritical,n.mode),combine:null,destination:null,reason:"CANCEL"};o(e)}}})(e,t);return e=>t=>n=>{if("BEFORE_INITIAL_CAPTURE"===n.type)return void r.beforeCapture(n.payload.draggableId,n.payload.movementMode);if("INITIAL_PUBLISH"===n.type){const e=n.payload.critical;return r.beforeStart(e,n.payload.movementMode),t(n),void r.start(e,n.payload.movementMode)}if("DROP_COMPLETE"===n.type){const e=n.payload.completed.result;return r.flush(),t(n),void r.drop(e)}if(t(n),"FLUSH"===n.type)return void r.abort();const o=e.getState();"DRAGGING"===o.phase&&r.update(o.critical,o.impact)}};var qr=e=>t=>r=>{if("DROP_ANIMATION_FINISHED"!==r.type)return void t(r);const n=e.getState();"DROP_ANIMATING"!==n.phase&&u(!1),e.dispatch(xr({completed:n.completed}))};var Vr=e=>{let t=null,r=null;return n=>o=>{if("FLUSH"!==o.type&&"DROP_COMPLETE"!==o.type&&"DROP_ANIMATION_FINISHED"!==o.type||(r&&(cancelAnimationFrame(r),r=null),t&&(t(),t=null)),n(o),"DROP_ANIMATE"!==o.type)return;const i={eventName:"scroll",options:{capture:!0,passive:!1,once:!0},fn:function(){"DROP_ANIMATING"===e.getState().phase&&e.dispatch({type:"DROP_ANIMATION_FINISHED",payload:null})}};r=requestAnimationFrame((()=>{r=null,t=l(window,[i])}))}};var zr=e=>t=>r=>{if(t(r),"PUBLISH_WHILE_DRAGGING"!==r.type)return;const n=e.getState();"DROP_PENDING"===n.phase&&(n.isWaiting||e.dispatch(Ir({reason:n.reason})))};const Yr=R;var Jr=e=>{let{dimensionMarshal:t,focusMarshal:r,styleMarshal:n,getResponders:o,announce:i,autoScroller:a}=e;return O(cr,Yr(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){return function(){var r=e.apply(void 0,arguments),n=function(){throw new Error(D(15))},o={getState:r.getState,dispatch:function(){return n.apply(void 0,arguments)}},i=t.map((function(e){return e(o)}));return n=R.apply(void 0,i)(r.dispatch),I(I({},r),{},{dispatch:n})}}}((s=n,()=>e=>t=>{"INITIAL_PUBLISH"===t.type&&s.dragging(),"DROP_ANIMATE"===t.type&&s.dropping(t.payload.completed.result.reason),"FLUSH"!==t.type&&"DROP_COMPLETE"!==t.type||s.resting(),e(t)}),(e=>()=>t=>r=>{"DROP_COMPLETE"!==r.type&&"FLUSH"!==r.type&&"DROP_ANIMATE"!==r.type||e.stopPublishing(),t(r)})(t),(e=>t=>{let{getState:r,dispatch:n}=t;return t=>o=>{if("LIFT"!==o.type)return void t(o);const{id:i,clientSelection:a,movementMode:s}=o.payload,l=r();"DROP_ANIMATING"===l.phase&&n(xr({completed:l.completed})),"IDLE"!==r().phase&&u(!1),n({type:"FLUSH",payload:null}),n({type:"BEFORE_INITIAL_CAPTURE",payload:{draggableId:i,movementMode:s}});const c={draggableId:i,scrollOptions:{shouldPublishImmediately:"SNAP"===s}},{critical:d,dimensions:p,viewport:f}=e.startPublishing(c);n({type:"INITIAL_PUBLISH",payload:{critical:d,dimensions:p,clientSelection:a,movementMode:s,viewport:f}})}})(t),Mr,qr,Vr,zr,(e=>t=>r=>n=>{if((e=>"DROP_COMPLETE"===e.type||"DROP_ANIMATE"===e.type||"FLUSH"===e.type)(n))return e.stop(),void r(n);if("INITIAL_PUBLISH"===n.type){r(n);const o=t.getState();return"DRAGGING"!==o.phase&&u(!1),void e.start(o)}r(n),e.scroll(t.getState())})(a),$r,(e=>{let t=!1;return()=>r=>n=>{if("INITIAL_PUBLISH"===n.type)return t=!0,e.tryRecordFocus(n.payload.critical.draggable.id),r(n),void e.tryRestoreFocusRecorded();if(r(n),t){if("FLUSH"===n.type)return t=!1,void e.tryRestoreFocusRecorded();if("DROP_COMPLETE"===n.type){t=!1;const r=n.payload.completed.result;r.combine&&e.tryShiftRecord(r.draggableId,r.combine.draggableId),e.tryRestoreFocusRecorded()}}}})(r),Hr(o,i))));var s};var Xr=e=>{let{scrollHeight:t,scrollWidth:r,height:n,width:o}=e;const i=Oe({x:r,y:t},{x:o,y:n});return{x:Math.max(0,i.x),y:Math.max(0,i.y)}},Kr=()=>{const e=document.documentElement;return e||u(!1),e},Qr=()=>{const e=Kr();return Xr({scrollHeight:e.scrollHeight,scrollWidth:e.scrollWidth,width:e.clientWidth,height:e.clientHeight})},Zr=e=>{let{critical:t,scrollOptions:r,registry:n}=e;const o=(()=>{const e=_r(),t=Qr(),r=e.y,n=e.x,o=Kr(),i=o.clientWidth,a=o.clientHeight;return{frame:Le({top:r,left:n,right:n+i,bottom:r+a}),scroll:{initial:e,current:e,max:t,diff:{value:Se,displacement:Se}}}})(),i=o.scroll.current,a=t.droppable,s=n.droppable.getAllByType(a.type).map((e=>e.callbacks.getDimensionAndWatchScroll(i,r))),l=n.draggable.getAllByType(t.draggable.type).map((e=>e.getDimension(i)));return{dimensions:{draggables:Ze(l),droppables:Qe(s)},critical:t,viewport:o}};function en(e,t,r){if(r.descriptor.id===t.id)return!1;if(r.descriptor.type!==t.type)return!1;return"virtual"===e.droppable.getById(r.descriptor.droppableId).descriptor.mode}var tn=(e,t)=>{let r=null;const n=function(e){let{registry:t,callbacks:r}=e,n={additions:{},removals:{},modified:{}},o=null;const i=()=>{o||(r.collectionStarting(),o=requestAnimationFrame((()=>{o=null;const{additions:e,removals:i,modified:a}=n,s=Object.keys(e).map((e=>t.draggable.getById(e).getDimension(Se))).sort(((e,t)=>e.descriptor.index-t.descriptor.index)),l=Object.keys(a).map((e=>({droppableId:e,scroll:t.droppable.getById(e).callbacks.getScrollWhileDragging()}))),c={additions:s,removals:Object.keys(i),modified:l};n={additions:{},removals:{},modified:{}},r.publish(c)})))};return{add:e=>{const t=e.descriptor.id;n.additions[t]=e,n.modified[e.descriptor.droppableId]=!0,n.removals[t]&&delete n.removals[t],i()},remove:e=>{const t=e.descriptor;n.removals[t.id]=!0,n.modified[t.droppableId]=!0,n.additions[t.id]&&delete n.additions[t.id],i()},stop:()=>{o&&(cancelAnimationFrame(o),o=null,n={additions:{},removals:{},modified:{}})}}}({callbacks:{publish:t.publishWhileDragging,collectionStarting:t.collectionStarting},registry:e}),o=t=>{r||u(!1);const o=r.critical.draggable;"ADDITION"===t.type&&en(e,o,t.value)&&n.add(t.value),"REMOVAL"===t.type&&en(e,o,t.value)&&n.remove(t.value)},i={updateDroppableIsEnabled:(n,o)=>{e.droppable.exists(n)||u(!1),r&&t.updateDroppableIsEnabled({id:n,isEnabled:o})},updateDroppableIsCombineEnabled:(n,o)=>{r&&(e.droppable.exists(n)||u(!1),t.updateDroppableIsCombineEnabled({id:n,isCombineEnabled:o}))},scrollDroppable:(t,n)=>{r&&e.droppable.getById(t).callbacks.scroll(n)},updateDroppableScroll:(n,o)=>{r&&(e.droppable.exists(n)||u(!1),t.updateDroppableScroll({id:n,newScroll:o}))},startPublishing:t=>{r&&u(!1);const n=e.draggable.getById(t.draggableId),i=e.droppable.getById(n.descriptor.droppableId),a={draggable:n.descriptor,droppable:i.descriptor},s=e.subscribe(o);return r={critical:a,unsubscribe:s},Zr({critical:a,registry:e,scrollOptions:t.scrollOptions})},stopPublishing:()=>{if(!r)return;n.stop();const t=r.critical.droppable;e.droppable.getAllByType(t.type).forEach((e=>e.callbacks.dragStopped())),r.unsubscribe(),r=null}};return i},rn=(e,t)=>"IDLE"===e.phase||"DROP_ANIMATING"===e.phase&&(e.completed.result.draggableId!==t&&"DROP"===e.completed.result.reason),nn=e=>{window.scrollBy(e.x,e.y)};const on=Ke((e=>et(e).filter((e=>!!e.isEnabled&&!!e.frame))));var an=e=>{let{center:t,destination:r,droppables:n}=e;if(r){const e=n[r];return e.frame?e:null}const o=((e,t)=>{const r=on(t).find((t=>(t.frame||u(!1),Vt(t.frame.pageMarginBox)(e))))||null;return r})(t,n);return o};const sn={startFromPercentage:.25,maxScrollAtPercentage:.05,maxPixelScroll:28,ease:e=>e**2,durationDampening:{stopDampeningAt:1200,accelerateAt:360},disabled:!1};var ln=e=>{let{startOfRange:t,endOfRange:r,current:n}=e;const o=r-t;if(0===o)return 0;return(n-t)/o},cn=e=>{let{distanceToEdge:t,thresholds:r,dragStartTime:n,shouldUseTimeDampening:o,getAutoScrollerOptions:i}=e;const a=function(e,t,r){void 0===r&&(r=()=>sn);const n=r();if(e>t.startScrollingFrom)return 0;if(e<=t.maxScrollValueAt)return n.maxPixelScroll;if(e===t.startScrollingFrom)return 1;const o=1-ln({startOfRange:t.maxScrollValueAt,endOfRange:t.startScrollingFrom,current:e}),i=n.maxPixelScroll*n.ease(o);return Math.ceil(i)}(t,r,i);return 0===a?0:o?Math.max(((e,t,r)=>{const n=r(),o=n.durationDampening.accelerateAt,i=n.durationDampening.stopDampeningAt,a=t,s=i,l=Date.now()-a;if(l>=i)return e;if(l<o)return 1;const c=ln({startOfRange:o,endOfRange:s,current:l}),d=e*n.ease(c);return Math.ceil(d)})(a,n,i),1):a},dn=e=>{let{container:t,distanceToEdges:r,dragStartTime:n,axis:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=function(e,t,r){void 0===r&&(r=()=>sn);const n=r();return{startScrollingFrom:e[t.size]*n.startFromPercentage,maxScrollValueAt:e[t.size]*n.maxScrollAtPercentage}}(t,o,a);return r[o.end]<r[o.start]?cn({distanceToEdge:r[o.end],thresholds:s,dragStartTime:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a}):-1*cn({distanceToEdge:r[o.start],thresholds:s,dragStartTime:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a})};const un=Te((e=>0===e?0:e));var pn=e=>{let{dragStartTime:t,container:r,subject:n,center:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s={top:o.y-r.top,right:r.right-o.x,bottom:r.bottom-o.y,left:o.x-r.left},l=dn({container:r,distanceToEdges:s,dragStartTime:t,axis:ft,shouldUseTimeDampening:i,getAutoScrollerOptions:a}),c=dn({container:r,distanceToEdges:s,dragStartTime:t,axis:gt,shouldUseTimeDampening:i,getAutoScrollerOptions:a}),d=un({x:c,y:l});if(Ae(d,Se))return null;const u=(e=>{let{container:t,subject:r,proposedScroll:n}=e;const o=r.height>t.height,i=r.width>t.width;return i||o?i&&o?null:{x:i?0:n.x,y:o?0:n.y}:n})({container:r,subject:n,proposedScroll:d});return u?Ae(u,Se)?null:u:null};const fn=Te((e=>0===e?0:e>0?1:-1)),gn=(()=>{const e=(e,t)=>e<0?e:e>t?e-t:0;return t=>{let{current:r,max:n,change:o}=t;const i=Ce(r,o),a={x:e(i.x,n.x),y:e(i.y,n.y)};return Ae(a,Se)?null:a}})(),mn=e=>{let{max:t,current:r,change:n}=e;const o={x:Math.max(r.x,t.x),y:Math.max(r.y,t.y)},i=fn(n),a=gn({max:o,current:r,change:i});return!a||(0!==i.x&&0===a.x||0!==i.y&&0===a.y)},bn=(e,t)=>mn({current:e.scroll.current,max:e.scroll.max,change:t}),hn=(e,t)=>{const r=e.frame;return!!r&&mn({current:r.scroll.current,max:r.scroll.max,change:t})};var yn=e=>{let{state:t,dragStartTime:r,shouldUseTimeDampening:n,scrollWindow:o,scrollDroppable:i,getAutoScrollerOptions:a}=e;const s=t.current.page.borderBoxCenter,l=t.dimensions.draggables[t.critical.draggable.id].page.marginBox;if(t.isWindowScrollAllowed){const e=(e=>{let{viewport:t,subject:r,center:n,dragStartTime:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=pn({dragStartTime:o,container:t.frame,subject:r,center:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a});return s&&bn(t,s)?s:null})({dragStartTime:r,viewport:t.viewport,subject:l,center:s,shouldUseTimeDampening:n,getAutoScrollerOptions:a});if(e)return void o(e)}const c=an({center:s,destination:Ut(t.impact),droppables:t.dimensions.droppables});if(!c)return;const d=(e=>{let{droppable:t,subject:r,center:n,dragStartTime:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=t.frame;if(!s)return null;const l=pn({dragStartTime:o,container:s.pageMarginBox,subject:r,center:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a});return l&&hn(t,l)?l:null})({dragStartTime:r,droppable:c,subject:l,center:s,shouldUseTimeDampening:n,getAutoScrollerOptions:a});d&&i(c.descriptor.id,d)},vn=e=>{let{move:t,scrollDroppable:r,scrollWindow:n}=e;const o=(e,t)=>{if(!hn(e,t))return t;const n=((e,t)=>{const r=e.frame;return r&&hn(e,t)?gn({current:r.scroll.current,max:r.scroll.max,change:t}):null})(e,t);if(!n)return r(e.descriptor.id,t),null;const o=Oe(t,n);r(e.descriptor.id,o);return Oe(t,o)},i=(e,t,r)=>{if(!e)return r;if(!bn(t,r))return r;const o=((e,t)=>{if(!bn(e,t))return null;const r=e.scroll.max,n=e.scroll.current;return gn({current:n,max:r,change:t})})(t,r);if(!o)return n(r),null;const i=Oe(r,o);n(i);return Oe(r,i)};return e=>{const r=e.scrollJumpRequest;if(!r)return;const n=Ut(e.impact);n||u(!1);const a=o(e.dimensions.droppables[n],r);if(!a)return;const s=e.viewport,l=i(e.isWindowScrollAllowed,s,a);l&&((e,r)=>{const n=Ce(e.current.client.selection,r);t({client:n})})(e,l)}};const xn=(()=>{const e="data-rfd-drag-handle";return{base:e,draggableId:`${e}-draggable-id`,contextId:`${e}-context-id`}})(),In=(()=>{const e="data-rfd-draggable";return{base:e,contextId:`${e}-context-id`,id:`${e}-id`}})(),Dn=(()=>{const e="data-rfd-droppable";return{base:e,contextId:`${e}-context-id`,id:`${e}-id`}})(),wn={contextId:"data-rfd-scroll-container-context-id"},En=(e,t)=>e.map((e=>{const r=e.styles[t];return r?`${e.selector} { ${r} }`:""})).join(" ");var Sn="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?t.useLayoutEffect:t.useEffect;const Cn=()=>{const e=document.querySelector("head");return e||u(!1),e},On=e=>{const t=document.createElement("style");return e&&t.setAttribute("nonce",e),t.type="text/css",t};function An(e,r){const n=we((()=>(e=>{const t=(r=e,e=>`[${e}="${r}"]`);var r;const n=(()=>{const e="\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";return{selector:t(xn.contextId),styles:{always:"\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",resting:e,dragging:"pointer-events: none;",dropAnimating:e}}})(),o=[(()=>{const e=`\n      transition: ${Ar.outOfTheWay};\n    `;return{selector:t(In.contextId),styles:{dragging:e,dropAnimating:e,userCancel:e}}})(),n,{selector:t(Dn.contextId),styles:{always:"overflow-anchor: none;"}},{selector:"body",styles:{dragging:"\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "}}];return{always:En(o,"always"),resting:En(o,"resting"),dragging:En(o,"dragging"),dropAnimating:En(o,"dropAnimating"),userCancel:En(o,"userCancel")}})(e)),[e]),o=t.useRef(null),i=t.useRef(null),a=Ee(Ke((e=>{const t=i.current;t||u(!1),t.textContent=e})),[]),s=Ee((e=>{const t=o.current;t||u(!1),t.textContent=e}),[]);Sn((()=>{(o.current||i.current)&&u(!1);const t=On(r),l=On(r);return o.current=t,i.current=l,t.setAttribute("data-rfd-always",e),l.setAttribute("data-rfd-dynamic",e),Cn().appendChild(t),Cn().appendChild(l),s(n.always),a(n.resting),()=>{const e=e=>{const t=e.current;t||u(!1),Cn().removeChild(t),e.current=null};e(o),e(i)}}),[r,s,a,n.always,n.resting,e]);const l=Ee((()=>a(n.dragging)),[a,n.dragging]),c=Ee((e=>{a("DROP"!==e?n.userCancel:n.dropAnimating)}),[a,n.dropAnimating,n.userCancel]),d=Ee((()=>{i.current&&a(n.resting)}),[a,n.resting]);return we((()=>({dragging:l,dropping:c,resting:d})),[l,c,d])}function Pn(e,t){return Array.from(e.querySelectorAll(t))}var Rn=e=>{var t;return(null==e||null==(t=e.ownerDocument)?void 0:t.defaultView)||window};function Nn(e){return e instanceof Rn(e).HTMLElement}function Bn(e){const r=t.useRef({}),n=t.useRef(null),o=t.useRef(null),i=t.useRef(!1),a=Ee((function(e,t){const n={id:e,focus:t};return r.current[e]=n,function(){const t=r.current;t[e]!==n&&delete t[e]}}),[]),s=Ee((function(t){const r=function(e,t){const r=`[${xn.contextId}="${e}"]`,n=Pn(document,r);if(!n.length)return null;const o=n.find((e=>e.getAttribute(xn.draggableId)===t));return o&&Nn(o)?o:null}(e,t);r&&r!==document.activeElement&&r.focus()}),[e]),l=Ee((function(e,t){n.current===e&&(n.current=t)}),[]),c=Ee((function(){o.current||i.current&&(o.current=requestAnimationFrame((()=>{o.current=null;const e=n.current;e&&s(e)})))}),[s]),d=Ee((function(e){n.current=null;const t=document.activeElement;t&&t.getAttribute(xn.draggableId)===e&&(n.current=e)}),[]);Sn((()=>(i.current=!0,function(){i.current=!1;const e=o.current;e&&cancelAnimationFrame(e)})),[]);return we((()=>({register:a,tryRecordFocus:d,tryRestoreFocusRecorded:c,tryShiftRecord:l})),[a,d,c,l])}function Tn(){const e={draggables:{},droppables:{}},t=[];function r(e){t.length&&t.forEach((t=>t(e)))}function n(t){return e.draggables[t]||null}function o(t){return e.droppables[t]||null}return{draggable:{register:t=>{e.draggables[t.descriptor.id]=t,r({type:"ADDITION",value:t})},update:(t,r)=>{const n=e.draggables[r.descriptor.id];n&&n.uniqueId===t.uniqueId&&(delete e.draggables[r.descriptor.id],e.draggables[t.descriptor.id]=t)},unregister:t=>{const o=t.descriptor.id,i=n(o);i&&t.uniqueId===i.uniqueId&&(delete e.draggables[o],e.droppables[t.descriptor.droppableId]&&r({type:"REMOVAL",value:t}))},getById:function(e){const t=n(e);return t||u(!1),t},findById:n,exists:e=>Boolean(n(e)),getAllByType:t=>Object.values(e.draggables).filter((e=>e.descriptor.type===t))},droppable:{register:t=>{e.droppables[t.descriptor.id]=t},unregister:t=>{const r=o(t.descriptor.id);r&&t.uniqueId===r.uniqueId&&delete e.droppables[t.descriptor.id]},getById:function(e){const t=o(e);return t||u(!1),t},findById:o,exists:e=>Boolean(o(e)),getAllByType:t=>Object.values(e.droppables).filter((e=>e.descriptor.type===t))},subscribe:function(e){return t.push(e),function(){const r=t.indexOf(e);-1!==r&&t.splice(r,1)}},clean:function(){e.draggables={},e.droppables={},t.length=0}}}var Ln=i.default.createContext(null),Mn=()=>{const e=document.body;return e||u(!1),e};var Gn={position:"absolute",width:"1px",height:"1px",margin:"-1px",border:"0",padding:"0",overflow:"hidden",clip:"rect(0 0 0 0)","clip-path":"inset(100%)"};let _n=0;const Fn={separator:"::"};var $n="useId"in i.default?function(e,t){void 0===t&&(t=Fn);const r=i.default.useId();return we((()=>`${e}${t.separator}${r}`),[t.separator,e,r])}:function(e,t){return void 0===t&&(t=Fn),we((()=>`${e}${t.separator}${_n++}`),[t.separator,e])};var Wn=i.default.createContext(null);function kn(e){const r=t.useRef(e);return t.useEffect((()=>{r.current=e})),r}function jn(e){return"IDLE"!==e.phase&&"DROP_ANIMATING"!==e.phase&&e.isDragging}const Un={13:!0,9:!0};var Hn=e=>{Un[e.keyCode]&&e.preventDefault()};var qn=(()=>{const e="visibilitychange";if("undefined"==typeof document)return e;return[e,`ms${e}`,`webkit${e}`,`moz${e}`,`o${e}`].find((e=>`on${e}`in document))||e})();const Vn={type:"IDLE"};function zn(e){let{cancel:t,completed:r,getPhase:n,setPhase:o}=e;return[{eventName:"mousemove",fn:e=>{const{button:t,clientX:r,clientY:i}=e;if(0!==t)return;const a={x:r,y:i},s=n();if("DRAGGING"===s.type)return e.preventDefault(),void s.actions.move(a);"PENDING"!==s.type&&u(!1);const l=s.point;if(c=l,d=a,!(Math.abs(d.x-c.x)>=5||Math.abs(d.y-c.y)>=5))return;var c,d;e.preventDefault();const p=s.actions.fluidLift(a);o({type:"DRAGGING",actions:p})}},{eventName:"mouseup",fn:e=>{const o=n();"DRAGGING"===o.type?(e.preventDefault(),o.actions.drop({shouldBlockNextClick:!0}),r()):t()}},{eventName:"mousedown",fn:e=>{"DRAGGING"===n().type&&e.preventDefault(),t()}},{eventName:"keydown",fn:e=>{if("PENDING"!==n().type)return 27===e.keyCode?(e.preventDefault(),void t()):void Hn(e);t()}},{eventName:"resize",fn:t},{eventName:"scroll",options:{passive:!0,capture:!1},fn:()=>{"PENDING"===n().type&&t()}},{eventName:"webkitmouseforcedown",fn:e=>{const r=n();"IDLE"===r.type&&u(!1),r.actions.shouldRespectForcePress()?t():e.preventDefault()}},{eventName:qn,fn:t}]}function Yn(e){const r=t.useRef(Vn),n=t.useRef(s),o=we((()=>({eventName:"mousedown",fn:function(t){if(t.defaultPrevented)return;if(0!==t.button)return;if(t.ctrlKey||t.metaKey||t.shiftKey||t.altKey)return;const r=e.findClosestDraggableId(t);if(!r)return;const o=e.tryGetLock(r,c,{sourceEvent:t});if(!o)return;t.preventDefault();const i={x:t.clientX,y:t.clientY};n.current(),f(o,i)}})),[e]),i=we((()=>({eventName:"webkitmouseforcewillbegin",fn:t=>{if(t.defaultPrevented)return;const r=e.findClosestDraggableId(t);if(!r)return;const n=e.findOptionsForDraggable(r);n&&(n.shouldRespectForcePress||e.canGetLock(r)&&t.preventDefault())}})),[e]),a=Ee((function(){n.current=l(window,[i,o],{passive:!1,capture:!0})}),[i,o]),c=Ee((()=>{"IDLE"!==r.current.type&&(r.current=Vn,n.current(),a())}),[a]),d=Ee((()=>{const e=r.current;c(),"DRAGGING"===e.type&&e.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===e.type&&e.actions.abort()}),[c]),p=Ee((function(){const e=zn({cancel:d,completed:c,getPhase:()=>r.current,setPhase:e=>{r.current=e}});n.current=l(window,e,{capture:!0,passive:!1})}),[d,c]),f=Ee((function(e,t){"IDLE"!==r.current.type&&u(!1),r.current={type:"PENDING",point:t,actions:e},p()}),[p]);Sn((function(){return a(),function(){n.current()}}),[a])}function Jn(){}const Xn={34:!0,33:!0,36:!0,35:!0};function Kn(e,t){function r(){t(),e.cancel()}return[{eventName:"keydown",fn:n=>27===n.keyCode?(n.preventDefault(),void r()):32===n.keyCode?(n.preventDefault(),t(),void e.drop()):40===n.keyCode?(n.preventDefault(),void e.moveDown()):38===n.keyCode?(n.preventDefault(),void e.moveUp()):39===n.keyCode?(n.preventDefault(),void e.moveRight()):37===n.keyCode?(n.preventDefault(),void e.moveLeft()):void(Xn[n.keyCode]?n.preventDefault():Hn(n))},{eventName:"mousedown",fn:r},{eventName:"mouseup",fn:r},{eventName:"click",fn:r},{eventName:"touchstart",fn:r},{eventName:"resize",fn:r},{eventName:"wheel",fn:r,options:{passive:!0}},{eventName:qn,fn:r}]}function Qn(e){const r=t.useRef(Jn),n=we((()=>({eventName:"keydown",fn:function(t){if(t.defaultPrevented)return;if(32!==t.keyCode)return;const n=e.findClosestDraggableId(t);if(!n)return;const i=e.tryGetLock(n,c,{sourceEvent:t});if(!i)return;t.preventDefault();let a=!0;const s=i.snapLift();function c(){a||u(!1),a=!1,r.current(),o()}r.current(),r.current=l(window,Kn(s,c),{capture:!0,passive:!1})}})),[e]),o=Ee((function(){r.current=l(window,[n],{passive:!1,capture:!0})}),[n]);Sn((function(){return o(),function(){r.current()}}),[o])}const Zn={type:"IDLE"};function eo(e){const r=t.useRef(Zn),n=t.useRef(s),o=Ee((function(){return r.current}),[]),i=Ee((function(e){r.current=e}),[]),a=we((()=>({eventName:"touchstart",fn:function(t){if(t.defaultPrevented)return;const r=e.findClosestDraggableId(t);if(!r)return;const o=e.tryGetLock(r,d,{sourceEvent:t});if(!o)return;const i=t.touches[0],{clientX:a,clientY:s}=i,l={x:a,y:s};n.current(),m(o,l)}})),[e]),c=Ee((function(){n.current=l(window,[a],{capture:!0,passive:!1})}),[a]),d=Ee((()=>{const e=r.current;"IDLE"!==e.type&&("PENDING"===e.type&&clearTimeout(e.longPressTimerId),i(Zn),n.current(),c())}),[c,i]),p=Ee((()=>{const e=r.current;d(),"DRAGGING"===e.type&&e.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===e.type&&e.actions.abort()}),[d]),f=Ee((function(){const e={capture:!0,passive:!1},t={cancel:p,completed:d,getPhase:o},r=l(window,function(e){let{cancel:t,completed:r,getPhase:n}=e;return[{eventName:"touchmove",options:{capture:!1},fn:e=>{const r=n();if("DRAGGING"!==r.type)return void t();r.hasMoved=!0;const{clientX:o,clientY:i}=e.touches[0],a={x:o,y:i};e.preventDefault(),r.actions.move(a)}},{eventName:"touchend",fn:e=>{const o=n();"DRAGGING"===o.type?(e.preventDefault(),o.actions.drop({shouldBlockNextClick:!0}),r()):t()}},{eventName:"touchcancel",fn:e=>{"DRAGGING"===n().type?(e.preventDefault(),t()):t()}},{eventName:"touchforcechange",fn:e=>{const r=n();"IDLE"===r.type&&u(!1);const o=e.touches[0];if(!o)return;if(!(o.force>=.15))return;const i=r.actions.shouldRespectForcePress();if("PENDING"!==r.type)return i?r.hasMoved?void e.preventDefault():void t():void e.preventDefault();i&&t()}},{eventName:qn,fn:t}]}(t),e),i=l(window,function(e){let{cancel:t,getPhase:r}=e;return[{eventName:"orientationchange",fn:t},{eventName:"resize",fn:t},{eventName:"contextmenu",fn:e=>{e.preventDefault()}},{eventName:"keydown",fn:e=>{"DRAGGING"===r().type?(27===e.keyCode&&e.preventDefault(),t()):t()}},{eventName:qn,fn:t}]}(t),e);n.current=function(){r(),i()}}),[p,o,d]),g=Ee((function(){const e=o();"PENDING"!==e.type&&u(!1);const t=e.actions.fluidLift(e.point);i({type:"DRAGGING",actions:t,hasMoved:!1})}),[o,i]),m=Ee((function(e,t){"IDLE"!==o().type&&u(!1);const r=setTimeout(g,120);i({type:"PENDING",point:t,actions:e,longPressTimerId:r}),f()}),[f,o,i,g]);Sn((function(){return c(),function(){n.current();const e=o();"PENDING"===e.type&&(clearTimeout(e.longPressTimerId),i(Zn))}}),[o,c,i]),Sn((function(){return l(window,[{eventName:"touchmove",fn:()=>{},options:{capture:!1,passive:!1}}])}),[])}const to=["input","button","textarea","select","option","optgroup","video","audio"];function ro(e,t){if(null==t)return!1;if(to.includes(t.tagName.toLowerCase()))return!0;const r=t.getAttribute("contenteditable");return"true"===r||""===r||t!==e&&ro(e,t.parentElement)}function no(e,t){const r=t.target;return!!Nn(r)&&ro(e,r)}var oo=e=>Le(e.getBoundingClientRect()).center;const io=(()=>{const e="matches";if("undefined"==typeof document)return e;return[e,"msMatchesSelector","webkitMatchesSelector"].find((e=>e in Element.prototype))||e})();function ao(e,t){return null==e?null:e[io](t)?e:ao(e.parentElement,t)}function so(e,t){return e.closest?e.closest(t):ao(e,t)}function lo(e,t){const r=t.target;if(!((n=r)instanceof Rn(n).Element))return null;var n;const o=function(e){return`[${xn.contextId}="${e}"]`}(e),i=so(r,o);return i&&Nn(i)?i:null}function co(e){e.preventDefault()}function uo(e){let{expected:t,phase:r,isLockActive:n,shouldWarn:o}=e;return!!n()&&t===r}function po(e){let{lockAPI:t,store:r,registry:n,draggableId:o}=e;if(t.isClaimed())return!1;const i=n.draggable.findById(o);return!!i&&(!!i.options.isEnabled&&!!rn(r.getState(),o))}function fo(e){let{lockAPI:t,contextId:r,store:n,registry:o,draggableId:i,forceSensorStop:a,sourceEvent:c}=e;if(!po({lockAPI:t,store:n,registry:o,draggableId:i}))return null;const d=o.draggable.getById(i),p=function(e,t){const r=`[${In.contextId}="${e}"]`,n=Pn(document,r).find((e=>e.getAttribute(In.id)===t));return n&&Nn(n)?n:null}(r,d.descriptor.id);if(!p)return null;if(c&&!d.options.canDragInteractiveElements&&no(p,c))return null;const f=t.claim(a||s);let g="PRE_DRAG";function m(){return d.options.shouldRespectForcePress}function b(){return t.isActive(f)}const h=function(e,t){uo({expected:e,phase:g,isLockActive:b,shouldWarn:!0})&&n.dispatch(t())}.bind(null,"DRAGGING");function y(e){function r(){t.release(),g="COMPLETED"}function o(t,o){if(void 0===o&&(o={shouldBlockNextClick:!1}),e.cleanup(),o.shouldBlockNextClick){const e=l(window,[{eventName:"click",fn:co,options:{once:!0,passive:!1,capture:!0}}]);setTimeout(e)}r(),n.dispatch(Ir({reason:t}))}return"PRE_DRAG"!==g&&(r(),u(!1)),n.dispatch((e=>({type:"LIFT",payload:e}))(e.liftActionArgs)),g="DRAGGING",{isActive:()=>uo({expected:"DRAGGING",phase:g,isLockActive:b,shouldWarn:!1}),shouldRespectForcePress:m,drop:e=>o("DROP",e),cancel:e=>o("CANCEL",e),...e.actions}}return{isActive:()=>uo({expected:"PRE_DRAG",phase:g,isLockActive:b,shouldWarn:!1}),shouldRespectForcePress:m,fluidLift:function(e){const t=Gr((e=>{h((()=>mr({client:e})))}));return{...y({liftActionArgs:{id:i,clientSelection:e,movementMode:"FLUID"},cleanup:()=>t.cancel(),actions:{move:t}}),move:t}},snapLift:function(){const e={moveUp:()=>h(br),moveRight:()=>h(yr),moveDown:()=>h(hr),moveLeft:()=>h(vr)};return y({liftActionArgs:{id:i,clientSelection:oo(p),movementMode:"SNAP"},cleanup:s,actions:e})},abort:function(){uo({expected:"PRE_DRAG",phase:g,isLockActive:b,shouldWarn:!0})&&t.release()}}}const go=[Yn,Qn,eo];function mo(e){let{contextId:r,store:n,registry:o,customSensors:i,enableDefaultSensors:a}=e;const s=[...a?go:[],...i||[]],l=t.useState((()=>function(){let e=null;function t(){e||u(!1),e=null}return{isClaimed:function(){return Boolean(e)},isActive:function(t){return t===e},claim:function(t){e&&u(!1);const r={abandon:t};return e=r,r},release:t,tryAbandon:function(){e&&(e.abandon(),t())}}}()))[0],c=Ee((function(e,t){jn(e)&&!jn(t)&&l.tryAbandon()}),[l]);Sn((function(){let e=n.getState();return n.subscribe((()=>{const t=n.getState();c(e,t),e=t}))}),[l,n,c]),Sn((()=>l.tryAbandon),[l.tryAbandon]);const d=Ee((e=>po({lockAPI:l,registry:o,store:n,draggableId:e})),[l,o,n]),p=Ee(((e,t,i)=>fo({lockAPI:l,registry:o,contextId:r,store:n,draggableId:e,forceSensorStop:t||null,sourceEvent:i&&i.sourceEvent?i.sourceEvent:null})),[r,l,o,n]),f=Ee((e=>function(e,t){const r=lo(e,t);return r?r.getAttribute(xn.draggableId):null}(r,e)),[r]),g=Ee((e=>{const t=o.draggable.findById(e);return t?t.options:null}),[o.draggable]),m=Ee((function(){l.isClaimed()&&(l.tryAbandon(),"IDLE"!==n.getState().phase&&n.dispatch({type:"FLUSH",payload:null}))}),[l,n]),b=Ee((()=>l.isClaimed()),[l]),h=we((()=>({canGetLock:d,tryGetLock:p,findClosestDraggableId:f,findOptionsForDraggable:g,tryReleaseLock:m,isLockClaimed:b})),[d,p,f,g,m,b]);for(let e=0;e<s.length;e++)s[e](h)}function bo(e){return e.current||u(!1),e.current}function ho(e){const{contextId:n,setCallbacks:o,sensors:a,nonce:s,dragHandleUsageInstructions:l}=e,c=t.useRef(null),d=kn(e),p=Ee((()=>(e=>({onBeforeCapture:t=>{const n=()=>{e.onBeforeCapture&&e.onBeforeCapture(t)};i.default.version.startsWith("16")||i.default.version.startsWith("17")?n():r.flushSync(n)},onBeforeDragStart:e.onBeforeDragStart,onDragStart:e.onDragStart,onDragEnd:e.onDragEnd,onDragUpdate:e.onDragUpdate}))(d.current)),[d]),f=Ee((()=>(e=>({...sn,...e.autoScrollerOptions,durationDampening:{...sn.durationDampening,...e.autoScrollerOptions}}))(d.current)),[d]),g=function(e){const r=we((()=>(e=>`rfd-announcement-${e}`)(e)),[e]),n=t.useRef(null);return t.useEffect((function(){const e=document.createElement("div");return n.current=e,e.id=r,e.setAttribute("aria-live","assertive"),e.setAttribute("aria-atomic","true"),L(e.style,Gn),Mn().appendChild(e),function(){setTimeout((function(){const t=Mn();t.contains(e)&&t.removeChild(e),e===n.current&&(n.current=null)}))}}),[r]),Ee((e=>{const t=n.current;t&&(t.textContent=e)}),[])}(n),m=function(e){let{contextId:r,text:n}=e;const o=$n("hidden-text",{separator:"-"}),i=we((()=>function(e){let{contextId:t,uniqueId:r}=e;return`rfd-hidden-text-${t}-${r}`}({contextId:r,uniqueId:o})),[o,r]);return t.useEffect((function(){const e=document.createElement("div");return e.id=i,e.textContent=n,e.style.display="none",Mn().appendChild(e),function(){const t=Mn();t.contains(e)&&t.removeChild(e)}}),[i,n]),i}({contextId:n,text:l}),b=An(n,s),h=Ee((e=>{bo(c).dispatch(e)}),[]),y=we((()=>P({publishWhileDragging:dr,updateDroppableScroll:pr,updateDroppableIsEnabled:fr,updateDroppableIsCombineEnabled:gr,collectionStarting:ur},h)),[h]),v=function(){const e=we(Tn,[]);return t.useEffect((()=>function(){i.default.version.startsWith("16")||i.default.version.startsWith("17")?requestAnimationFrame(e.clean):e.clean()}),[e]),e}(),x=we((()=>tn(v,y)),[v,y]),I=we((()=>(e=>{let{scrollDroppable:t,scrollWindow:r,move:n,getAutoScrollerOptions:o}=e;const i=(e=>{let{scrollWindow:t,scrollDroppable:r,getAutoScrollerOptions:n=(()=>sn)}=e;const o=Gr(t),i=Gr(r);let a=null;const s=e=>{a||u(!1);const{shouldUseTimeDampening:t,dragStartTime:r}=a;yn({state:e,scrollWindow:o,scrollDroppable:i,dragStartTime:r,shouldUseTimeDampening:t,getAutoScrollerOptions:n})};return{start:e=>{a&&u(!1);const t=Date.now();let r=!1;const o=()=>{r=!0};yn({state:e,dragStartTime:0,shouldUseTimeDampening:!1,scrollWindow:o,scrollDroppable:o,getAutoScrollerOptions:n}),a={dragStartTime:t,shouldUseTimeDampening:r},r&&s(e)},stop:()=>{a&&(o.cancel(),i.cancel(),a=null)},scroll:s}})({scrollWindow:r,scrollDroppable:t,getAutoScrollerOptions:o}),a=vn({move:n,scrollWindow:r,scrollDroppable:t});return{scroll:e=>{o().disabled||"DRAGGING"!==e.phase||("FLUID"!==e.movementMode?e.scrollJumpRequest&&a(e):i.scroll(e))},start:i.start,stop:i.stop}})({scrollWindow:nn,scrollDroppable:x.scrollDroppable,getAutoScrollerOptions:f,...P({move:mr},h)})),[x.scrollDroppable,h,f]),D=Bn(n),w=we((()=>Jr({announce:g,autoScroller:I,dimensionMarshal:x,focusMarshal:D,getResponders:p,styleMarshal:b})),[g,I,x,D,p,b]);c.current=w;const E=Ee((()=>{const e=bo(c);"IDLE"!==e.getState().phase&&e.dispatch({type:"FLUSH",payload:null})}),[]),S=Ee((()=>{const e=bo(c).getState();return"DROP_ANIMATING"===e.phase||"IDLE"!==e.phase&&e.isDragging}),[]);o(we((()=>({isDragging:S,tryAbort:E})),[S,E]));const C=Ee((e=>rn(bo(c).getState(),e)),[]),O=Ee((()=>qt(bo(c).getState())),[]),A=we((()=>({marshal:x,focus:D,contextId:n,canLift:C,isMovementAllowed:O,dragHandleUsageInstructionsId:m,registry:v})),[n,x,m,D,C,O,v]);return mo({contextId:n,store:w,registry:v,customSensors:a||null,enableDefaultSensors:!1!==e.enableDefaultSensors}),t.useEffect((()=>E),[E]),i.default.createElement(Wn.Provider,{value:A},i.default.createElement(ve,{context:Ln,store:w},e.children))}let yo=0;var vo="useId"in i.default?function(){return i.default.useId()}:function(){return we((()=>""+yo++),[])};const xo=5e3,Io=4500,Do=(e,t)=>t?Ar.drop(t.duration):e?Ar.snap:Ar.fluid,wo=(e,t)=>{if(e)return t?Er.drop:Er.combining};function Eo(e){return"DRAGGING"===e.type?function(e){const t=e.dimension.client,{offset:r,combineWith:n,dropping:o}=e,i=Boolean(n),a=(e=>null!=e.forceShouldAnimate?e.forceShouldAnimate:"SNAP"===e.mode)(e),s=Boolean(o),l=s?Nr(r,i):Rr(r);return{position:"fixed",top:t.marginBox.top,left:t.marginBox.left,boxSizing:"border-box",width:t.borderBox.width,height:t.borderBox.height,transition:Do(a,o),transform:l,opacity:wo(i,s),zIndex:s?Io:xo,pointerEvents:"none"}}(e):{transform:Rr((t=e).offset),transition:t.shouldAnimateDisplacement?void 0:"none"};var t}function So(e){const r=$n("draggable"),{descriptor:n,registry:o,getDraggableRef:i,canDragInteractiveElements:a,shouldRespectForcePress:s,isEnabled:l}=e,c=we((()=>({canDragInteractiveElements:a,shouldRespectForcePress:s,isEnabled:l})),[a,l,s]),d=Ee((e=>{const t=i();return t||u(!1),function(e,t,r){void 0===r&&(r=Se);const n=window.getComputedStyle(t),o=t.getBoundingClientRect(),i=je(o,n),a=ke(i,r);return{descriptor:e,placeholder:{client:i,tagName:t.tagName.toLowerCase(),display:n.display},displaceBy:{x:i.marginBox.width,y:i.marginBox.height},client:i,page:a}}(n,t,e)}),[n,i]),p=we((()=>({uniqueId:r,descriptor:n,options:c,getDimension:d})),[n,d,c,r]),f=t.useRef(p),g=t.useRef(!0);Sn((()=>(o.draggable.register(f.current),()=>o.draggable.unregister(f.current))),[o.draggable]),Sn((()=>{if(g.current)return void(g.current=!1);const e=f.current;f.current=p,o.draggable.update(p,e)}),[p,o.draggable])}var Co=i.default.createContext(null);function Oo(e){const r=t.useContext(e);return r||u(!1),r}function Ao(e){e.preventDefault()}var Po=e=>{const n=t.useRef(null),o=Ee((function(e){void 0===e&&(e=null),n.current=e}),[]),a=Ee((()=>n.current),[]),{contextId:s,dragHandleUsageInstructionsId:l,registry:c}=Oo(Wn),{type:d,droppableId:u}=Oo(Co),p=we((()=>({id:e.draggableId,index:e.index,type:d,droppableId:u})),[e.draggableId,e.index,d,u]),{children:f,draggableId:g,isEnabled:m,shouldRespectForcePress:b,canDragInteractiveElements:h,isClone:y,mapped:v,dropAnimationFinished:x}=e;if(!y){So(we((()=>({descriptor:p,registry:c,getDraggableRef:a,canDragInteractiveElements:h,shouldRespectForcePress:b,isEnabled:m})),[p,c,a,h,b,m]))}const I=we((()=>m?{tabIndex:0,role:"button","aria-describedby":l,"data-rfd-drag-handle-draggable-id":g,"data-rfd-drag-handle-context-id":s,draggable:!1,onDragStart:Ao}:null),[s,l,g,m]),D=Ee((e=>{"DRAGGING"===v.type&&v.dropping&&"transform"===e.propertyName&&(i.default.version.startsWith("16")||i.default.version.startsWith("17")?x():r.flushSync(x))}),[x,v]),w=we((()=>{const e=Eo(v),t="DRAGGING"===v.type&&v.dropping?D:void 0;return{innerRef:o,draggableProps:{"data-rfd-draggable-context-id":s,"data-rfd-draggable-id":g,style:e,onTransitionEnd:t},dragHandleProps:I}}),[s,I,g,v,D,o]),E=we((()=>({draggableId:p.id,type:p.type,source:{index:p.index,droppableId:p.droppableId}})),[p.droppableId,p.id,p.index,p.type]);return i.default.createElement(i.default.Fragment,null,f(w,v.snapshot,E))},Ro=(e,t)=>e===t,No=e=>{const{combine:t,destination:r}=e;return r?r.droppableId:t?t.droppableId:null};function Bo(e){return void 0===e&&(e=null),{isDragging:!1,isDropAnimating:!1,isClone:!1,dropAnimation:null,mode:null,draggingOver:null,combineTargetFor:e,combineWith:null}}const To={mapped:{type:"SECONDARY",offset:Se,combineTargetFor:null,shouldAnimateDisplacement:!0,snapshot:Bo(null)}};const Lo=ye((()=>{const e=function(){const e=Ke(((e,t)=>({x:e,y:t}))),t=Ke((function(e,t,r,n,o){return void 0===r&&(r=null),void 0===n&&(n=null),void 0===o&&(o=null),{isDragging:!0,isClone:t,isDropAnimating:Boolean(o),dropAnimation:o,mode:e,draggingOver:r,combineWith:n,combineTargetFor:null}})),r=Ke((function(e,r,n,o,i,a,s){return void 0===i&&(i=null),void 0===a&&(a=null),void 0===s&&(s=null),{mapped:{type:"DRAGGING",dropping:null,draggingOver:i,combineWith:a,mode:r,offset:e,dimension:n,forceShouldAnimate:s,snapshot:t(r,o,i,a,null)}}}));return(n,o)=>{if(jn(n)){if(n.critical.draggable.id!==o.draggableId)return null;const t=n.current.client.offset,a=n.dimensions.draggables[o.draggableId],s=Ut(n.impact),l=(i=n.impact).at&&"COMBINE"===i.at.type?i.at.combine.draggableId:null,c=n.forceShouldAnimate;return r(e(t.x,t.y),n.movementMode,a,o.isClone,s,l,c)}var i;if("DROP_ANIMATING"===n.phase){const e=n.completed;if(e.result.draggableId!==o.draggableId)return null;const r=o.isClone,i=n.dimensions.draggables[o.draggableId],a=e.result,s=a.mode,l=No(a),c=(e=>e.combine?e.combine.draggableId:null)(a),d={duration:n.dropDuration,curve:wr,moveTo:n.newHomeClientOffset,opacity:c?Er.drop:null,scale:c?Sr.drop:null};return{mapped:{type:"DRAGGING",offset:n.newHomeClientOffset,dimension:i,dropping:d,draggingOver:l,combineWith:c,mode:s,forceShouldAnimate:null,snapshot:t(s,r,l,c,d)}}}return null}}(),t=function(){const e=Ke(((e,t)=>({x:e,y:t}))),t=Ke(Bo),r=Ke((function(e,r,n){return void 0===r&&(r=null),{mapped:{type:"SECONDARY",offset:e,combineTargetFor:r,shouldAnimateDisplacement:n,snapshot:t(r)}}})),n=e=>e?r(Se,e,!0):null,o=(t,o,i,a)=>{const s=i.displaced.visible[t],l=Boolean(a.inVirtualList&&a.effected[t]),c=ot(i),d=c&&c.draggableId===t?o:null;if(!s){if(!l)return n(d);if(i.displaced.invisible[t])return null;const o=Pe(a.displacedBy.point),s=e(o.x,o.y);return r(s,d,!0)}if(l)return n(d);const u=i.displacedBy.point,p=e(u.x,u.y);return r(p,d,s.shouldAnimate)};return(e,t)=>{if(jn(e))return e.critical.draggable.id===t.draggableId?null:o(t.draggableId,e.critical.draggable.id,e.impact,e.afterCritical);if("DROP_ANIMATING"===e.phase){const r=e.completed;return r.result.draggableId===t.draggableId?null:o(t.draggableId,r.result.draggableId,r.impact,r.afterCritical)}return null}}();return(r,n)=>e(r,n)||t(r,n)||To}),{dropAnimationFinished:Dr},null,{context:Ln,areStatePropsEqual:Ro})(Po);var Mo=Lo;function Go(e){return Oo(Co).isUsingCloneFor!==e.draggableId||e.isClone?i.default.createElement(Mo,e):null}const _o=e=>t=>e===t,Fo=_o("scroll"),$o=_o("auto"),Wo=(e,t)=>t(e.overflowX)||t(e.overflowY),ko=e=>null==e||e===document.body||e===document.documentElement?null:(e=>{const t=window.getComputedStyle(e),r={overflowX:t.overflowX,overflowY:t.overflowY};return Wo(r,Fo)||Wo(r,$o)})(e)?e:ko(e.parentElement);var jo=ko,Uo=e=>({x:e.scrollLeft,y:e.scrollTop});const Ho=e=>{if(!e)return!1;return"fixed"===window.getComputedStyle(e).position||Ho(e.parentElement)};var qo=e=>{let{ref:t,descriptor:r,env:n,windowScroll:o,direction:i,isDropDisabled:a,isCombineEnabled:s,shouldClipSubject:l}=e;const c=n.closestScrollable,d=((e,t)=>{const r=Ue(e);if(!t)return r;if(e!==t)return r;const n=r.paddingBox.top-t.scrollTop,o=r.paddingBox.left-t.scrollLeft,i=n+t.scrollHeight,a=o+t.scrollWidth,s=Me({top:n,right:a,bottom:i,left:o},r.border);return Fe({borderBox:s,margin:r.margin,border:r.border,padding:r.padding})})(t,c),u=ke(d,o),p=(()=>{if(!c)return null;const e=Ue(c),t={scrollHeight:c.scrollHeight,scrollWidth:c.scrollWidth};return{client:e,page:ke(e,o),scroll:Uo(c),scrollSize:t,shouldClipSubject:l}})(),f=(e=>{let{descriptor:t,isEnabled:r,isCombineEnabled:n,isFixedOnPage:o,direction:i,client:a,page:s,closest:l}=e;const c=(()=>{if(!l)return null;const{scrollSize:e,client:t}=l,r=Xr({scrollHeight:e.scrollHeight,scrollWidth:e.scrollWidth,height:t.paddingBox.height,width:t.paddingBox.width});return{pageMarginBox:l.page.marginBox,frameClient:t,scrollSize:e,shouldClipSubject:l.shouldClipSubject,scroll:{initial:l.scroll,current:l.scroll,max:r,diff:{value:Se,displacement:Se}}}})(),d="vertical"===i?ft:gt;return{descriptor:t,isCombineEnabled:n,isFixedOnPage:o,axis:d,isEnabled:r,client:a,page:s,frame:c,subject:ze({page:s,withPlaceholder:null,axis:d,frame:c})}})({descriptor:r,isEnabled:!a,isCombineEnabled:s,isFixedOnPage:n.isFixedOnPage,direction:i,client:d,page:u,closest:p});return f};const Vo={passive:!1},zo={passive:!0};var Yo=e=>e.shouldPublishImmediately?Vo:zo;const Jo=e=>e&&e.env.closestScrollable||null;function Xo(e){const r=t.useRef(null),n=Oo(Wn),o=$n("droppable"),{registry:i,marshal:a}=n,s=kn(e),l=we((()=>({id:e.droppableId,type:e.type,mode:e.mode})),[e.droppableId,e.mode,e.type]),c=t.useRef(l),d=we((()=>Ke(((e,t)=>{r.current||u(!1);const n={x:e,y:t};a.updateDroppableScroll(l.id,n)}))),[l.id,a]),p=Ee((()=>{const e=r.current;return e&&e.env.closestScrollable?Uo(e.env.closestScrollable):Se}),[]),f=Ee((()=>{const e=p();d(e.x,e.y)}),[p,d]),g=we((()=>Gr(f)),[f]),m=Ee((()=>{const e=r.current,t=Jo(e);e&&t||u(!1);e.scrollOptions.shouldPublishImmediately?f():g()}),[g,f]),b=Ee(((e,t)=>{r.current&&u(!1);const o=s.current,i=o.getDroppableRef();i||u(!1);const a=(e=>({closestScrollable:jo(e),isFixedOnPage:Ho(e)}))(i),c={ref:i,descriptor:l,env:a,scrollOptions:t};r.current=c;const d=qo({ref:i,descriptor:l,env:a,windowScroll:e,direction:o.direction,isDropDisabled:o.isDropDisabled,isCombineEnabled:o.isCombineEnabled,shouldClipSubject:!o.ignoreContainerClipping}),p=a.closestScrollable;return p&&(p.setAttribute(wn.contextId,n.contextId),p.addEventListener("scroll",m,Yo(c.scrollOptions))),d}),[n.contextId,l,m,s]),h=Ee((()=>{const e=r.current,t=Jo(e);return e&&t||u(!1),Uo(t)}),[]),y=Ee((()=>{const e=r.current;e||u(!1);const t=Jo(e);r.current=null,t&&(g.cancel(),t.removeAttribute(wn.contextId),t.removeEventListener("scroll",m,Yo(e.scrollOptions)))}),[m,g]),v=Ee((e=>{const t=r.current;t||u(!1);const n=Jo(t);n||u(!1),n.scrollTop+=e.y,n.scrollLeft+=e.x}),[]),x=we((()=>({getDimensionAndWatchScroll:b,getScrollWhileDragging:h,dragStopped:y,scroll:v})),[y,b,h,v]),I=we((()=>({uniqueId:o,descriptor:l,callbacks:x})),[x,l,o]);Sn((()=>(c.current=I.descriptor,i.droppable.register(I),()=>{r.current&&y(),i.droppable.unregister(I)})),[x,l,y,I,a,i.droppable]),Sn((()=>{r.current&&a.updateDroppableIsEnabled(c.current.id,!e.isDropDisabled)}),[e.isDropDisabled,a]),Sn((()=>{r.current&&a.updateDroppableIsCombineEnabled(c.current.id,e.isCombineEnabled)}),[e.isCombineEnabled,a])}function Ko(){}const Qo={width:0,height:0,margin:{top:0,right:0,bottom:0,left:0}},Zo=e=>{let{isAnimatingOpenOnMount:t,placeholder:r,animate:n}=e;const o=(e=>{let{isAnimatingOpenOnMount:t,placeholder:r,animate:n}=e;return t||"close"===n?Qo:{height:r.client.borderBox.height,width:r.client.borderBox.width,margin:r.client.margin}})({isAnimatingOpenOnMount:t,placeholder:r,animate:n});return{display:r.display,boxSizing:"border-box",width:o.width,height:o.height,marginTop:o.margin.top,marginRight:o.margin.right,marginBottom:o.margin.bottom,marginLeft:o.margin.left,flexShrink:"0",flexGrow:"0",pointerEvents:"none",transition:"none"!==n?Ar.placeholder:null}};var ei=i.default.memo((e=>{const r=t.useRef(null),n=Ee((()=>{r.current&&(clearTimeout(r.current),r.current=null)}),[]),{animate:o,onTransitionEnd:a,onClose:s,contextId:l}=e,[c,d]=t.useState("open"===e.animate);t.useEffect((()=>c?"open"!==o?(n(),d(!1),Ko):r.current?Ko:(r.current=setTimeout((()=>{r.current=null,d(!1)})),n):Ko),[o,c,n]);const u=Ee((e=>{"height"===e.propertyName&&(a(),"close"===o&&s())}),[o,s,a]),p=Zo({isAnimatingOpenOnMount:c,animate:e.animate,placeholder:e.placeholder});return i.default.createElement(e.placeholder.tagName,{style:p,"data-rfd-placeholder-context-id":l,onTransitionEnd:u,ref:e.innerRef})}));class ti extends i.default.PureComponent{constructor(){super(...arguments),this.state={isVisible:Boolean(this.props.on),data:this.props.on,animate:this.props.shouldAnimate&&this.props.on?"open":"none"},this.onClose=()=>{"close"===this.state.animate&&this.setState({isVisible:!1})}}static getDerivedStateFromProps(e,t){return e.shouldAnimate?e.on?{isVisible:!0,data:e.on,animate:"open"}:t.isVisible?{isVisible:!0,data:t.data,animate:"close"}:{isVisible:!1,animate:"close",data:null}:{isVisible:Boolean(e.on),data:e.on,animate:"none"}}render(){if(!this.state.isVisible)return null;const e={onClose:this.onClose,data:this.state.data,animate:this.state.animate};return this.props.children(e)}}var ri=e=>{const r=t.useContext(Wn);r||u(!1);const{contextId:n,isMovementAllowed:o}=r,s=t.useRef(null),l=t.useRef(null),{children:c,droppableId:d,type:p,mode:f,direction:g,ignoreContainerClipping:m,isDropDisabled:b,isCombineEnabled:h,snapshot:y,useClone:v,updateViewportMaxScroll:x,getContainerForClone:I}=e,D=Ee((()=>s.current),[]),w=Ee((function(e){void 0===e&&(e=null),s.current=e}),[]);Ee((()=>l.current),[]);const E=Ee((function(e){void 0===e&&(e=null),l.current=e}),[]),S=Ee((()=>{o()&&x({maxScroll:Qr()})}),[o,x]);Xo({droppableId:d,type:p,mode:f,direction:g,isDropDisabled:b,isCombineEnabled:h,ignoreContainerClipping:m,getDroppableRef:D});const C=we((()=>i.default.createElement(ti,{on:e.placeholder,shouldAnimate:e.shouldAnimatePlaceholder},(e=>{let{onClose:t,data:r,animate:o}=e;return i.default.createElement(ei,{placeholder:r,onClose:t,innerRef:E,animate:o,contextId:n,onTransitionEnd:S})}))),[n,S,e.placeholder,e.shouldAnimatePlaceholder,E]),O=we((()=>({innerRef:w,placeholder:C,droppableProps:{"data-rfd-droppable-id":d,"data-rfd-droppable-context-id":n}})),[n,d,C,w]),A=v?v.dragging.draggableId:null,P=we((()=>({droppableId:d,type:p,isUsingCloneFor:A})),[d,A,p]);return i.default.createElement(Co.Provider,{value:P},c(O,y),function(){if(!v)return null;const{dragging:e,render:t}=v,r=i.default.createElement(Go,{draggableId:e.draggableId,index:e.source.index,isClone:!0,isEnabled:!0,shouldRespectForcePress:!1,canDragInteractiveElements:!0},((r,n)=>t(r,n,e)));return a.default.createPortal(r,I())}())};const ni=(e,t)=>e===t.droppable.type,oi=(e,t)=>t.draggables[e.draggable.id];const ii={mode:"standard",type:"DEFAULT",direction:"vertical",isDropDisabled:!1,isCombineEnabled:!1,ignoreContainerClipping:!1,renderClone:null,getContainerForClone:function(){return document.body||u(!1),document.body}},ai=ye((()=>{const e={placeholder:null,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:!1,draggingOverWith:null,draggingFromThisWith:null,isUsingPlaceholder:!1},useClone:null},t={...e,shouldAnimatePlaceholder:!1},r=Ke((e=>({draggableId:e.id,type:e.type,source:{index:e.index,droppableId:e.droppableId}}))),n=Ke(((n,o,i,a,s,l)=>{const c=s.descriptor.id;if(s.descriptor.droppableId===n){const e=l?{render:l,dragging:r(s.descriptor)}:null,t={isDraggingOver:i,draggingOverWith:i?c:null,draggingFromThisWith:c,isUsingPlaceholder:!0};return{placeholder:s.placeholder,shouldAnimatePlaceholder:!1,snapshot:t,useClone:e}}if(!o)return t;if(!a)return e;const d={isDraggingOver:i,draggingOverWith:c,draggingFromThisWith:null,isUsingPlaceholder:!0};return{placeholder:s.placeholder,shouldAnimatePlaceholder:!0,snapshot:d,useClone:null}}));return(r,o)=>{const i=o.droppableId,a=o.type,s=!o.isDropDisabled,l=o.renderClone;if(jn(r)){const e=r.critical;if(!ni(a,e))return t;const o=oi(e,r.dimensions),c=Ut(r.impact)===i;return n(i,s,c,c,o,l)}if("DROP_ANIMATING"===r.phase){const e=r.completed;if(!ni(a,e.critical))return t;const o=oi(e.critical,r.dimensions);return n(i,s,No(e.result)===i,Ut(e.impact)===i,o,l)}if("IDLE"===r.phase&&r.completed&&!r.shouldFlush){const n=r.completed;if(!ni(a,n.critical))return t;const o=Ut(n.impact)===i,s=Boolean(n.impact.at&&"COMBINE"===n.impact.at.type),l=n.critical.droppable.id===i;return o?s?e:t:l?e:t}return t}}),{updateViewportMaxScroll:e=>({type:"UPDATE_VIEWPORT_MAX_SCROLL",payload:e})},null,{context:Ln,areStatePropsEqual:Ro})(ri);ai.defaultProps=ii;var si=ai;e.DragDropContext=function(e){const t=vo(),r=e.dragHandleUsageInstructions||y.dragHandleUsageInstructions;return i.default.createElement(p,null,(n=>i.default.createElement(ho,{nonce:e.nonce,contextId:t,setCallbacks:n,dragHandleUsageInstructions:r,enableDefaultSensors:e.enableDefaultSensors,sensors:e.sensors,onBeforeCapture:e.onBeforeCapture,onBeforeDragStart:e.onBeforeDragStart,onDragStart:e.onDragStart,onDragUpdate:e.onDragUpdate,onDragEnd:e.onDragEnd,autoScrollerOptions:e.autoScrollerOptions},e.children)))},e.Draggable=function(e){const t="boolean"!=typeof e.isDragDisabled||!e.isDragDisabled,r=Boolean(e.disableInteractiveElementBlocking),n=Boolean(e.shouldRespectForcePress);return i.default.createElement(Go,L({},e,{isClone:!1,isEnabled:t,canDragInteractiveElements:r,shouldRespectForcePress:n}))},e.Droppable=si,e.resetServerContext=function(){"useId"in i.default||(yo=0,_n=0)},e.useKeyboardSensor=Qn,e.useMouseSensor=Yn,e.useTouchSensor=eo,Object.defineProperty(e,"__esModule",{value:!0})}));
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("react-dom"),require("use-sync-external-store/shim"),require("use-sync-external-store/shim/with-selector")):"function"==typeof define&&define.amd?define(["exports","react","react-dom","use-sync-external-store/shim","use-sync-external-store/shim/with-selector"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ReactBeautifulDnd={},e.React,e.ReactDOM,e.shim)}(this,(function(e,t,r,n){"use strict";function o(){}function i(e,t,r){const n=t.map((t=>{const n=(o=r,i=t.options,{...o,...i});var o,i;return e.addEventListener(t.eventName,t.fn,n),function(){e.removeEventListener(t.eventName,t.fn,n)}}));return function(){n.forEach((e=>{e()}))}}const a=!0,s="Invariant failed";class l extends Error{}function c(e,t){if(!e)throw new l(a?s:`${s}: ${t||""}`)}l.prototype.toString=function(){return this.message};class d extends t.Component{constructor(){super(...arguments),this.callbacks=null,this.unbind=o,this.onWindowError=e=>{const t=this.getCallbacks();t.isDragging()&&t.tryAbort();e.error instanceof l&&e.preventDefault()},this.getCallbacks=()=>{if(!this.callbacks)throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");return this.callbacks},this.setCallbacks=e=>{this.callbacks=e}}componentDidMount(){this.unbind=i(window,[{eventName:"error",fn:this.onWindowError}])}componentDidCatch(e){if(!(e instanceof l))throw e;this.setState({})}componentWillUnmount(){this.unbind()}render(){return this.props.children(this.setCallbacks)}}const u=e=>e+1,p=(e,t)=>{const r=e.droppableId===t.droppableId,n=u(e.index),o=u(t.index);return r?`\n      You have moved the item from position ${n}\n      to position ${o}\n    `:`\n    You have moved the item from position ${n}\n    in list ${e.droppableId}\n    to list ${t.droppableId}\n    in position ${o}\n  `},f=(e,t,r)=>t.droppableId===r.droppableId?`\n      The item ${e}\n      has been combined with ${r.draggableId}`:`\n      The item ${e}\n      in list ${t.droppableId}\n      has been combined with ${r.draggableId}\n      in list ${r.droppableId}\n    `,g=e=>`\n  The item has returned to its starting position\n  of ${u(e.index)}\n`,m={dragHandleUsageInstructions:"\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n",onDragStart:e=>`\n  You have lifted an item in position ${u(e.source.index)}\n`,onDragUpdate:e=>{const t=e.destination;if(t)return p(e.source,t);const r=e.combine;return r?f(e.draggableId,e.source,r):"You are over an area that cannot be dropped on"},onDragEnd:e=>{if("CANCEL"===e.reason)return`\n      Movement cancelled.\n      ${g(e.source)}\n    `;const t=e.destination,r=e.combine;return t?`\n      You have dropped the item.\n      ${p(e.source,t)}\n    `:r?`\n      You have dropped the item.\n      ${f(e.draggableId,e.source,r)}\n    `:`\n    The item has been dropped while not over a drop area.\n    ${g(e.source)}\n  `}};var b=m;function h(e){return h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},h(e)}function y(e){var t=function(e,t){if("object"!==h(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==h(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===h(t)?t:String(t)}function v(e,t,r){return(t=y(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function x(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function I(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?x(Object(r),!0).forEach((function(t){v(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):x(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function D(e){return"Minified Redux error #"+e+"; visit https://redux.js.org/Errors?code="+e+" for the full message or use the non-minified dev environment for full errors. "}var w="function"==typeof Symbol&&Symbol.observable||"@@observable",S=function(){return Math.random().toString(36).substring(7).split("").join(".")},E={INIT:"@@redux/INIT"+S(),REPLACE:"@@redux/REPLACE"+S(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+S()}};function C(e,t,r){var n;if("function"==typeof t&&"function"==typeof r||"function"==typeof r&&"function"==typeof arguments[3])throw new Error(D(0));if("function"==typeof t&&void 0===r&&(r=t,t=void 0),void 0!==r){if("function"!=typeof r)throw new Error(D(1));return r(C)(e,t)}if("function"!=typeof e)throw new Error(D(2));var o=e,i=t,a=[],s=a,l=!1;function c(){s===a&&(s=a.slice())}function d(){if(l)throw new Error(D(3));return i}function u(e){if("function"!=typeof e)throw new Error(D(4));if(l)throw new Error(D(5));var t=!0;return c(),s.push(e),function(){if(t){if(l)throw new Error(D(6));t=!1,c();var r=s.indexOf(e);s.splice(r,1),a=null}}}function p(e){if(!function(e){if("object"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}(e))throw new Error(D(7));if(void 0===e.type)throw new Error(D(8));if(l)throw new Error(D(9));try{l=!0,i=o(i,e)}finally{l=!1}for(var t=a=s,r=0;r<t.length;r++){(0,t[r])()}return e}return p({type:E.INIT}),(n={dispatch:p,subscribe:u,getState:d,replaceReducer:function(e){if("function"!=typeof e)throw new Error(D(10));o=e,p({type:E.REPLACE})}})[w]=function(){var e,t=u;return(e={subscribe:function(e){if("object"!=typeof e||null===e)throw new Error(D(11));function r(){e.next&&e.next(d())}return r(),{unsubscribe:t(r)}}})[w]=function(){return this},e},n}function A(e,t){return function(){return t(e.apply(this,arguments))}}function O(e,t){if("function"==typeof e)return A(e,t);if("object"!=typeof e||null===e)throw new Error(D(16));var r={};for(var n in e){var o=e[n];"function"==typeof o&&(r[n]=A(o,t))}return r}function P(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce((function(e,t){return function(){return e(t.apply(void 0,arguments))}}))}let R=function(e){e()};const N=()=>R,B=t.createContext(null);function T(){return T=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},T.apply(this,arguments)}function L(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}var M,G={},_={};!function(e){e.exports=function(){if(M)return _;M=1;var e="function"==typeof Symbol&&Symbol.for,t=e?Symbol.for("react.element"):60103,r=e?Symbol.for("react.portal"):60106,n=e?Symbol.for("react.fragment"):60107,o=e?Symbol.for("react.strict_mode"):60108,i=e?Symbol.for("react.profiler"):60114,a=e?Symbol.for("react.provider"):60109,s=e?Symbol.for("react.context"):60110,l=e?Symbol.for("react.async_mode"):60111,c=e?Symbol.for("react.concurrent_mode"):60111,d=e?Symbol.for("react.forward_ref"):60112,u=e?Symbol.for("react.suspense"):60113,p=e?Symbol.for("react.suspense_list"):60120,f=e?Symbol.for("react.memo"):60115,g=e?Symbol.for("react.lazy"):60116,m=e?Symbol.for("react.block"):60121,b=e?Symbol.for("react.fundamental"):60117,h=e?Symbol.for("react.responder"):60118,y=e?Symbol.for("react.scope"):60119;function v(e){if("object"==typeof e&&null!==e){var p=e.$$typeof;switch(p){case t:switch(e=e.type){case l:case c:case n:case i:case o:case u:return e;default:switch(e=e&&e.$$typeof){case s:case d:case g:case f:case a:return e;default:return p}}case r:return p}}}function x(e){return v(e)===c}return _.AsyncMode=l,_.ConcurrentMode=c,_.ContextConsumer=s,_.ContextProvider=a,_.Element=t,_.ForwardRef=d,_.Fragment=n,_.Lazy=g,_.Memo=f,_.Portal=r,_.Profiler=i,_.StrictMode=o,_.Suspense=u,_.isAsyncMode=function(e){return x(e)||v(e)===l},_.isConcurrentMode=x,_.isContextConsumer=function(e){return v(e)===s},_.isContextProvider=function(e){return v(e)===a},_.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===t},_.isForwardRef=function(e){return v(e)===d},_.isFragment=function(e){return v(e)===n},_.isLazy=function(e){return v(e)===g},_.isMemo=function(e){return v(e)===f},_.isPortal=function(e){return v(e)===r},_.isProfiler=function(e){return v(e)===i},_.isStrictMode=function(e){return v(e)===o},_.isSuspense=function(e){return v(e)===u},_.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===n||e===c||e===i||e===o||e===u||e===p||"object"==typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===f||e.$$typeof===a||e.$$typeof===s||e.$$typeof===d||e.$$typeof===b||e.$$typeof===h||e.$$typeof===y||e.$$typeof===m)},_.typeOf=v,_}()}({get exports(){return G},set exports(e){G=e}});var $=G,F={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},W={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},k={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},j={};function U(e){return $.isMemo(e)?k:j[e.$$typeof]||F}j[$.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},j[$.Memo]=k;var H=Object.defineProperty,q=Object.getOwnPropertyNames,V=Object.getOwnPropertySymbols,z=Object.getOwnPropertyDescriptor,Y=Object.getPrototypeOf,J=Object.prototype;var X,K=function e(t,r,n){if("string"!=typeof r){if(J){var o=Y(r);o&&o!==J&&e(t,o,n)}var i=q(r);V&&(i=i.concat(V(r)));for(var a=U(t),s=U(r),l=0;l<i.length;++l){var c=i[l];if(!(W[c]||n&&n[c]||s&&s[c]||a&&a[c])){var d=z(r,c);try{H(t,c,d)}catch(e){}}}}return t},Q={},Z={};!function(e){e.exports=function(){if(X)return Z;X=1;var e,t=Symbol.for("react.element"),r=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),s=Symbol.for("react.context"),l=Symbol.for("react.server_context"),c=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),u=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function m(e){if("object"==typeof e&&null!==e){var g=e.$$typeof;switch(g){case t:switch(e=e.type){case n:case i:case o:case d:case u:return e;default:switch(e=e&&e.$$typeof){case l:case s:case c:case f:case p:case a:return e;default:return g}}case r:return g}}}return e=Symbol.for("react.module.reference"),Z.ContextConsumer=s,Z.ContextProvider=a,Z.Element=t,Z.ForwardRef=c,Z.Fragment=n,Z.Lazy=f,Z.Memo=p,Z.Portal=r,Z.Profiler=i,Z.StrictMode=o,Z.Suspense=d,Z.SuspenseList=u,Z.isAsyncMode=function(){return!1},Z.isConcurrentMode=function(){return!1},Z.isContextConsumer=function(e){return m(e)===s},Z.isContextProvider=function(e){return m(e)===a},Z.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===t},Z.isForwardRef=function(e){return m(e)===c},Z.isFragment=function(e){return m(e)===n},Z.isLazy=function(e){return m(e)===f},Z.isMemo=function(e){return m(e)===p},Z.isPortal=function(e){return m(e)===r},Z.isProfiler=function(e){return m(e)===i},Z.isStrictMode=function(e){return m(e)===o},Z.isSuspense=function(e){return m(e)===d},Z.isSuspenseList=function(e){return m(e)===u},Z.isValidElementType=function(t){return"string"==typeof t||"function"==typeof t||t===n||t===i||t===o||t===d||t===u||t===g||"object"==typeof t&&null!==t&&(t.$$typeof===f||t.$$typeof===p||t.$$typeof===a||t.$$typeof===s||t.$$typeof===c||t.$$typeof===e||void 0!==t.getModuleId)},Z.typeOf=m,Z}()}({get exports(){return Q},set exports(e){Q=e}});const ee=["initMapStateToProps","initMapDispatchToProps","initMergeProps"];function te(e,t,r,n,{areStatesEqual:o,areOwnPropsEqual:i,areStatePropsEqual:a}){let s,l,c,d,u,p=!1;function f(p,f){const g=!i(f,l),m=!o(p,s,f,l);return s=p,l=f,g&&m?(c=e(s,l),t.dependsOnOwnProps&&(d=t(n,l)),u=r(c,d,l),u):g?(e.dependsOnOwnProps&&(c=e(s,l)),t.dependsOnOwnProps&&(d=t(n,l)),u=r(c,d,l),u):m?function(){const t=e(s,l),n=!a(t,c);return c=t,n&&(u=r(c,d,l)),u}():u}return function(o,i){return p?f(o,i):(s=o,l=i,c=e(s,l),d=t(n,l),u=r(c,d,l),p=!0,u)}}function re(e){return function(t){const r=e(t);function n(){return r}return n.dependsOnOwnProps=!1,n}}function ne(e){return e.dependsOnOwnProps?Boolean(e.dependsOnOwnProps):1!==e.length}function oe(e,t){return function(t,{displayName:r}){const n=function(e,t){return n.dependsOnOwnProps?n.mapToProps(e,t):n.mapToProps(e,void 0)};return n.dependsOnOwnProps=!0,n.mapToProps=function(t,r){n.mapToProps=e,n.dependsOnOwnProps=ne(e);let o=n(t,r);return"function"==typeof o&&(n.mapToProps=o,n.dependsOnOwnProps=ne(o),o=n(t,r)),o},n}}function ie(e,t){return(r,n)=>{throw new Error(`Invalid value of type ${typeof e} for ${t} argument when connecting component ${n.wrappedComponentName}.`)}}function ae(e,t,r){return T({},r,e,t)}const se={notify(){},get:()=>[]};function le(e,t){let r,n=se;function o(){a.onStateChange&&a.onStateChange()}function i(){r||(r=t?t.addNestedSub(o):e.subscribe(o),n=function(){const e=N();let t=null,r=null;return{clear(){t=null,r=null},notify(){e((()=>{let e=t;for(;e;)e.callback(),e=e.next}))},get(){let e=[],r=t;for(;r;)e.push(r),r=r.next;return e},subscribe(e){let n=!0,o=r={callback:e,next:null,prev:r};return o.prev?o.prev.next=o:t=o,function(){n&&null!==t&&(n=!1,o.next?o.next.prev=o.prev:r=o.prev,o.prev?o.prev.next=o.next:t=o.next)}}}}())}const a={addNestedSub:function(e){return i(),n.subscribe(e)},notifyNestedSubs:function(){n.notify()},handleChangeWrapper:o,isSubscribed:function(){return Boolean(r)},trySubscribe:i,tryUnsubscribe:function(){r&&(r(),r=void 0,n.clear(),n=se)},getListeners:()=>n};return a}const ce=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement)?t.useLayoutEffect:t.useEffect;function de(e,t){return e===t?0!==e||0!==t||1/e==1/t:e!=e&&t!=t}function ue(e,t){if(de(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let n=0;n<r.length;n++)if(!Object.prototype.hasOwnProperty.call(t,r[n])||!de(e[r[n]],t[r[n]]))return!1;return!0}const pe=["reactReduxForwardedRef"];let fe=()=>{throw new Error("uSES not initialized!")};const ge=[null,null];function me(e,t,r,n,o,i){e.current=n,r.current=!1,o.current&&(o.current=null,i())}function be(e,t){return e===t}function he(e,r,n,{pure:o,areStatesEqual:i=be,areOwnPropsEqual:a=ue,areStatePropsEqual:s=ue,areMergedPropsEqual:l=ue,forwardRef:c=!1,context:d=B}={}){const u=d,p=function(e){return e?"function"==typeof e?oe(e):ie(e,"mapStateToProps"):re((()=>({})))}(e),f=function(e){return e&&"object"==typeof e?re((t=>function(e,t){const r={};for(const n in e){const o=e[n];"function"==typeof o&&(r[n]=(...e)=>t(o(...e)))}return r}(e,t))):e?"function"==typeof e?oe(e):ie(e,"mapDispatchToProps"):re((e=>({dispatch:e})))}(r),g=function(e){return e?"function"==typeof e?function(e){return function(t,{displayName:r,areMergedPropsEqual:n}){let o,i=!1;return function(t,r,a){const s=e(t,r,a);return i?n(s,o)||(o=s):(i=!0,o=s),o}}}(e):ie(e,"mergeProps"):()=>ae}(n),m=Boolean(e);return e=>{const r=e.displayName||e.name||"Component",n=`Connect(${r})`,o={shouldHandleStateChanges:m,displayName:n,wrappedComponentName:r,WrappedComponent:e,initMapStateToProps:p,initMapDispatchToProps:f,initMergeProps:g,areStatesEqual:i,areStatePropsEqual:s,areOwnPropsEqual:a,areMergedPropsEqual:l};function d(r){const[n,i,a]=t.useMemo((()=>{const{reactReduxForwardedRef:e}=r,t=L(r,pe);return[r.context,e,t]}),[r]),s=t.useMemo((()=>n&&n.Consumer&&Q.isContextConsumer(t.createElement(n.Consumer,null))?n:u),[n,u]),l=t.useContext(s),c=Boolean(r.store)&&Boolean(r.store.getState)&&Boolean(r.store.dispatch),d=Boolean(l)&&Boolean(l.store),p=c?r.store:l.store,f=d?l.getServerState:p.getState,g=t.useMemo((()=>function(e,t){let{initMapStateToProps:r,initMapDispatchToProps:n,initMergeProps:o}=t,i=L(t,ee);return te(r(e,i),n(e,i),o(e,i),e,i)}(p.dispatch,o)),[p]),[b,h]=t.useMemo((()=>{if(!m)return ge;const e=le(p,c?void 0:l.subscription),t=e.notifyNestedSubs.bind(e);return[e,t]}),[p,c,l]),y=t.useMemo((()=>c?l:T({},l,{subscription:b})),[c,l,b]),v=t.useRef(),x=t.useRef(a),I=t.useRef(),D=t.useRef(!1);t.useRef(!1);const w=t.useRef(!1),S=t.useRef();ce((()=>(w.current=!0,()=>{w.current=!1})),[]);const E=t.useMemo((()=>()=>I.current&&a===x.current?I.current:g(p.getState(),a)),[p,a]),C=t.useMemo((()=>e=>b?function(e,t,r,n,o,i,a,s,l,c,d){if(!e)return()=>{};let u=!1,p=null;const f=()=>{if(u||!s.current)return;const e=t.getState();let r,f;try{r=n(e,o.current)}catch(e){f=e,p=e}f||(p=null),r===i.current?a.current||c():(i.current=r,l.current=r,a.current=!0,d())};return r.onStateChange=f,r.trySubscribe(),f(),()=>{if(u=!0,r.tryUnsubscribe(),r.onStateChange=null,p)throw p}}(m,p,b,g,x,v,D,w,I,h,e):()=>{}),[b]);var A,O,P;let R;A=me,O=[x,v,D,a,I,h],ce((()=>A(...O)),P);try{R=fe(C,E,f?()=>g(f(),a):E)}catch(e){throw S.current&&(e.message+=`\nThe error may be correlated with this previous error:\n${S.current.stack}\n\n`),e}ce((()=>{S.current=void 0,I.current=void 0,v.current=R}));const N=t.useMemo((()=>t.createElement(e,T({},R,{ref:i}))),[i,e,R]);return t.useMemo((()=>m?t.createElement(s.Provider,{value:y},N):N),[s,N,y])}const b=t.memo(d);if(b.WrappedComponent=e,b.displayName=d.displayName=n,c){const r=t.forwardRef((function(e,r){return t.createElement(b,T({},e,{reactReduxForwardedRef:r}))}));return r.displayName=n,r.WrappedComponent=e,K(r,e)}return K(b,e)}}function ye({store:e,context:r,children:n,serverState:o}){const i=t.useMemo((()=>{const t=le(e);return{store:e,subscription:t,getServerState:o?()=>o:void 0}}),[e,o]),a=t.useMemo((()=>e.getState()),[e]);ce((()=>{const{subscription:t}=i;return t.onStateChange=t.notifyNestedSubs,t.trySubscribe(),a!==e.getState()&&t.notifyNestedSubs(),()=>{t.tryUnsubscribe(),t.onStateChange=void 0}}),[i,a]);const s=r||B;return t.createElement(s.Provider,{value:i},n)}var ve,xe;function Ie(e,r){var n=t.useState((function(){return{inputs:r,result:e()}}))[0],o=t.useRef(!0),i=t.useRef(n),a=o.current||Boolean(r&&i.current.inputs&&function(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}(r,i.current.inputs))?i.current:{inputs:r,result:e()};return t.useEffect((function(){o.current=!1,i.current=a}),[a]),a.result}ve=n.useSyncExternalStore,fe=ve,xe=r.unstable_batchedUpdates,R=xe;var De=Ie,we=function(e,t){return Ie((function(){return e}),t)};const Se={x:0,y:0},Ee=(e,t)=>({x:e.x+t.x,y:e.y+t.y}),Ce=(e,t)=>({x:e.x-t.x,y:e.y-t.y}),Ae=(e,t)=>e.x===t.x&&e.y===t.y,Oe=e=>({x:0!==e.x?-e.x:0,y:0!==e.y?-e.y:0}),Pe=function(e,t,r){return void 0===r&&(r=0),"x"===e?{x:t,y:r}:{x:r,y:t}},Re=(e,t)=>Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2),Ne=(e,t)=>Math.min(...t.map((t=>Re(e,t)))),Be=e=>t=>({x:e(t.x),y:e(t.y)});var Te=!0,Le="Invariant failed";var Me=function(e){var t=e.top,r=e.right,n=e.bottom,o=e.left;return{top:t,right:r,bottom:n,left:o,width:r-o,height:n-t,x:o,y:t,center:{x:(r+o)/2,y:(n+t)/2}}},Ge=function(e,t){return{top:e.top-t.top,left:e.left-t.left,bottom:e.bottom+t.bottom,right:e.right+t.right}},_e=function(e,t){return{top:e.top+t.top,left:e.left+t.left,bottom:e.bottom-t.bottom,right:e.right-t.right}},$e={top:0,right:0,bottom:0,left:0},Fe=function(e){var t=e.borderBox,r=e.margin,n=void 0===r?$e:r,o=e.border,i=void 0===o?$e:o,a=e.padding,s=void 0===a?$e:a,l=Me(Ge(t,n)),c=Me(_e(t,i)),d=Me(_e(c,s));return{marginBox:l,borderBox:Me(t),paddingBox:c,contentBox:d,margin:n,border:i,padding:s}},We=function(e){var t=e.slice(0,-2);if("px"!==e.slice(-2))return 0;var r=Number(t);return isNaN(r)&&function(e,t){if(!e){if(Te)throw new Error(Le);var r="function"==typeof t?t():t;throw new Error(r?Le+": "+r:Le)}}(!1),r},ke=function(e,t){var r,n,o=e.borderBox,i=e.border,a=e.margin,s=e.padding,l=(n=t,{top:(r=o).top+n.y,left:r.left+n.x,bottom:r.bottom+n.y,right:r.right+n.x});return Fe({borderBox:l,border:i,margin:a,padding:s})},je=function(e,t){return void 0===t&&(t={x:window.pageXOffset,y:window.pageYOffset}),ke(e,t)},Ue=function(e,t){var r={top:We(t.marginTop),right:We(t.marginRight),bottom:We(t.marginBottom),left:We(t.marginLeft)},n={top:We(t.paddingTop),right:We(t.paddingRight),bottom:We(t.paddingBottom),left:We(t.paddingLeft)},o={top:We(t.borderTopWidth),right:We(t.borderRightWidth),bottom:We(t.borderBottomWidth),left:We(t.borderLeftWidth)};return Fe({borderBox:e,margin:r,padding:n,border:o})},He=function(e){var t=e.getBoundingClientRect(),r=window.getComputedStyle(e);return Ue(t,r)};const qe=(e,t)=>({top:e.top+t.y,left:e.left+t.x,bottom:e.bottom+t.y,right:e.right+t.x}),Ve=e=>[{x:e.left,y:e.top},{x:e.right,y:e.top},{x:e.left,y:e.bottom},{x:e.right,y:e.bottom}],ze=(e,t)=>t&&t.shouldClipSubject?((e,t)=>{const r=Me({top:Math.max(t.top,e.top),right:Math.min(t.right,e.right),bottom:Math.min(t.bottom,e.bottom),left:Math.max(t.left,e.left)});return r.width<=0||r.height<=0?null:r})(t.pageMarginBox,e):Me(e);var Ye=e=>{let{page:t,withPlaceholder:r,axis:n,frame:o}=e;const i=((e,t)=>t?qe(e,t.scroll.diff.displacement):e)(t.marginBox,o),a=((e,t,r)=>r&&r.increasedBy?{...e,[t.end]:e[t.end]+r.increasedBy[t.line]}:e)(i,n,r);return{page:t,withPlaceholder:r,active:ze(a,o)}},Je=(e,t)=>{e.frame||c(!1);const r=e.frame,n=Ce(t,r.scroll.initial),o=Oe(n),i={...r,scroll:{initial:r.scroll.initial,current:t,diff:{value:n,displacement:o},max:r.scroll.max}},a=Ye({page:e.subject.page,withPlaceholder:e.subject.withPlaceholder,axis:e.axis,frame:i});return{...e,frame:i,subject:a}},Xe=Number.isNaN||function(e){return"number"==typeof e&&e!=e};function Ke(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(n=e[r],o=t[r],!(n===o||Xe(n)&&Xe(o)))return!1;var n,o;return!0}function Qe(e,t){void 0===t&&(t=Ke);var r=null;function n(){for(var n=[],o=0;o<arguments.length;o++)n[o]=arguments[o];if(r&&r.lastThis===this&&t(n,r.lastArgs))return r.lastResult;var i=e.apply(this,n);return r={lastResult:i,lastArgs:n,lastThis:this},i}return n.clear=function(){r=null},n}const Ze=Qe((e=>e.reduce(((e,t)=>(e[t.descriptor.id]=t,e)),{}))),et=Qe((e=>e.reduce(((e,t)=>(e[t.descriptor.id]=t,e)),{}))),tt=Qe((e=>Object.values(e))),rt=Qe((e=>Object.values(e)));var nt=Qe(((e,t)=>{const r=rt(t).filter((t=>e===t.descriptor.droppableId)).sort(((e,t)=>e.descriptor.index-t.descriptor.index));return r}));function ot(e){return e.at&&"REORDER"===e.at.type?e.at.destination:null}function it(e){return e.at&&"COMBINE"===e.at.type?e.at.combine:null}var at=Qe(((e,t)=>t.filter((t=>t.descriptor.id!==e.descriptor.id)))),st=(e,t)=>e.descriptor.droppableId===t.descriptor.id;const lt={point:Se,value:0},ct={invisible:{},visible:{},all:[]};var dt={displaced:ct,displacedBy:lt,at:null},ut=(e,t)=>r=>e<=r&&r<=t,pt=e=>{const t=ut(e.top,e.bottom),r=ut(e.left,e.right);return n=>{if(t(n.top)&&t(n.bottom)&&r(n.left)&&r(n.right))return!0;const o=t(n.top)||t(n.bottom),i=r(n.left)||r(n.right);if(o&&i)return!0;const a=n.top<e.top&&n.bottom>e.bottom,s=n.left<e.left&&n.right>e.right;if(a&&s)return!0;return a&&i||s&&o}},ft=e=>{const t=ut(e.top,e.bottom),r=ut(e.left,e.right);return e=>t(e.top)&&t(e.bottom)&&r(e.left)&&r(e.right)};const gt={direction:"vertical",line:"y",crossAxisLine:"x",start:"top",end:"bottom",size:"height",crossAxisStart:"left",crossAxisEnd:"right",crossAxisSize:"width"},mt={direction:"horizontal",line:"x",crossAxisLine:"y",start:"left",end:"right",size:"width",crossAxisStart:"top",crossAxisEnd:"bottom",crossAxisSize:"height"};const bt=e=>{let{target:t,destination:r,viewport:n,withDroppableDisplacement:o,isVisibleThroughFrameFn:i}=e;const a=o?((e,t)=>{const r=t.frame?t.frame.scroll.diff.displacement:Se;return qe(e,r)})(t,r):t;return((e,t,r)=>!!t.subject.active&&r(t.subject.active)(e))(a,r,i)&&((e,t,r)=>r(t)(e))(a,n,i)},ht=e=>bt({...e,isVisibleThroughFrameFn:pt}),yt=e=>bt({...e,isVisibleThroughFrameFn:ft}),vt=(e,t,r)=>{if("boolean"==typeof r)return r;if(!t)return!0;const{invisible:n,visible:o}=t;if(n[e])return!1;const i=o[e];return!i||i.shouldAnimate};function xt(e){let{afterDragging:t,destination:r,displacedBy:n,viewport:o,forceShouldAnimate:i,last:a}=e;return t.reduce((function(e,t){const s=function(e,t){const r=e.page.marginBox,n={top:t.point.y,right:0,bottom:0,left:t.point.x};return Me(Ge(r,n))}(t,n),l=t.descriptor.id;e.all.push(l);if(!ht({target:s,destination:r,viewport:o,withDroppableDisplacement:!0}))return e.invisible[t.descriptor.id]=!0,e;const c={draggableId:l,shouldAnimate:vt(l,a,i)};return e.visible[l]=c,e}),{all:[],visible:{},invisible:{}})}function It(e){let{insideDestination:t,inHomeList:r,displacedBy:n,destination:o}=e;const i=function(e,t){if(!e.length)return 0;const r=e[e.length-1].descriptor.index;return t.inHomeList?r:r+1}(t,{inHomeList:r});return{displaced:ct,displacedBy:n,at:{type:"REORDER",destination:{droppableId:o.descriptor.id,index:i}}}}function Dt(e){let{draggable:t,insideDestination:r,destination:n,viewport:o,displacedBy:i,last:a,index:s,forceShouldAnimate:l}=e;const c=st(t,n);if(null==s)return It({insideDestination:r,inHomeList:c,displacedBy:i,destination:n});const d=r.find((e=>e.descriptor.index===s));if(!d)return It({insideDestination:r,inHomeList:c,displacedBy:i,destination:n});const u=at(t,r),p=r.indexOf(d);return{displaced:xt({afterDragging:u.slice(p),destination:n,displacedBy:i,last:a,viewport:o.frame,forceShouldAnimate:l}),displacedBy:i,at:{type:"REORDER",destination:{droppableId:n.descriptor.id,index:s}}}}function wt(e,t){return Boolean(t.effected[e])}var St=e=>{let{isMovingForward:t,isInHomeList:r,draggable:n,draggables:o,destination:i,insideDestination:a,previousImpact:s,viewport:l,afterCritical:d}=e;const u=s.at;if(u||c(!1),"REORDER"===u.type){const e=(e=>{let{isMovingForward:t,isInHomeList:r,insideDestination:n,location:o}=e;if(!n.length)return null;const i=o.index,a=t?i+1:i-1,s=n[0].descriptor.index,l=n[n.length-1].descriptor.index;return a<s||a>(r?l:l+1)?null:a})({isMovingForward:t,isInHomeList:r,location:u.destination,insideDestination:a});return null==e?null:Dt({draggable:n,insideDestination:a,destination:i,viewport:l,last:s.displaced,displacedBy:s.displacedBy,index:e})}const p=(e=>{let{isMovingForward:t,destination:r,draggables:n,combine:o,afterCritical:i}=e;if(!r.isCombineEnabled)return null;const a=o.draggableId,s=n[a].descriptor.index;return wt(a,i)?t?s:s-1:t?s+1:s})({isMovingForward:t,destination:i,displaced:s.displaced,draggables:o,combine:u.combine,afterCritical:d});return null==p?null:Dt({draggable:n,insideDestination:a,destination:i,viewport:l,last:s.displaced,displacedBy:s.displacedBy,index:p})},Et=e=>{let{afterCritical:t,impact:r,draggables:n}=e;const o=it(r);o||c(!1);const i=o.draggableId,a=n[i].page.borderBox.center,s=(e=>{let{displaced:t,afterCritical:r,combineWith:n,displacedBy:o}=e;const i=Boolean(t.visible[n]||t.invisible[n]);return wt(n,r)?i?Se:Oe(o.point):i?o.point:Se})({displaced:r.displaced,afterCritical:t,combineWith:i,displacedBy:r.displacedBy});return Ee(a,s)};const Ct=(e,t)=>t.margin[e.start]+t.borderBox[e.size]/2,At=(e,t,r)=>t[e.crossAxisStart]+r.margin[e.crossAxisStart]+r.borderBox[e.crossAxisSize]/2,Ot=e=>{let{axis:t,moveRelativeTo:r,isMoving:n}=e;return Pe(t.line,r.marginBox[t.end]+Ct(t,n),At(t,r.marginBox,n))},Pt=e=>{let{axis:t,moveRelativeTo:r,isMoving:n}=e;return Pe(t.line,r.marginBox[t.start]-((e,t)=>t.margin[e.end]+t.borderBox[e.size]/2)(t,n),At(t,r.marginBox,n))};var Rt=e=>{let{impact:t,draggable:r,draggables:n,droppable:o,afterCritical:i}=e;const a=nt(o.descriptor.id,n),s=r.page,l=o.axis;if(!a.length)return(e=>{let{axis:t,moveInto:r,isMoving:n}=e;return Pe(t.line,r.contentBox[t.start]+Ct(t,n),At(t,r.contentBox,n))})({axis:l,moveInto:o.page,isMoving:s});const{displaced:c,displacedBy:d}=t,u=c.all[0];if(u){const e=n[u];if(wt(u,i))return Pt({axis:l,moveRelativeTo:e.page,isMoving:s});const t=ke(e.page,d.point);return Pt({axis:l,moveRelativeTo:t,isMoving:s})}const p=a[a.length-1];if(p.descriptor.id===r.descriptor.id)return s.borderBox.center;if(wt(p.descriptor.id,i)){const e=ke(p.page,Oe(i.displacedBy.point));return Ot({axis:l,moveRelativeTo:e,isMoving:s})}return Ot({axis:l,moveRelativeTo:p.page,isMoving:s})},Nt=(e,t)=>{const r=e.frame;return r?Ee(t,r.scroll.diff.displacement):t};var Bt=e=>{const t=(e=>{let{impact:t,draggable:r,droppable:n,draggables:o,afterCritical:i}=e;const a=r.page.borderBox.center,s=t.at;return n&&s?"REORDER"===s.type?Rt({impact:t,draggable:r,draggables:o,droppable:n,afterCritical:i}):Et({impact:t,draggables:o,afterCritical:i}):a})(e),r=e.droppable;return r?Nt(r,t):t},Tt=(e,t)=>{const r=Ce(t,e.scroll.initial),n=Oe(r);return{frame:Me({top:t.y,bottom:t.y+e.frame.height,left:t.x,right:t.x+e.frame.width}),scroll:{initial:e.scroll.initial,max:e.scroll.max,current:t,diff:{value:r,displacement:n}}}};function Lt(e,t){return e.map((e=>t[e]))}var Mt=e=>{let{pageBorderBoxCenter:t,draggable:r,viewport:n}=e;const o=((e,t)=>Ee(e.scroll.diff.displacement,t))(n,t),i=Ce(o,r.page.borderBox.center);return Ee(r.client.borderBox.center,i)},Gt=e=>{let{draggable:t,destination:r,newPageBorderBoxCenter:n,viewport:o,withDroppableDisplacement:i,onlyOnMainAxis:a=!1}=e;const s=Ce(n,t.page.borderBox.center),l={target:qe(t.page.borderBox,s),destination:r,withDroppableDisplacement:i,viewport:o};return a?(e=>{return bt({...e,isVisibleThroughFrameFn:(t=e.destination.axis,e=>{const r=ut(e.top,e.bottom),n=ut(e.left,e.right);return e=>t===gt?r(e.top)&&r(e.bottom):n(e.left)&&n(e.right)})});var t})(l):yt(l)},_t=e=>{let{isMovingForward:t,draggable:r,destination:n,draggables:o,previousImpact:i,viewport:a,previousPageBorderBoxCenter:s,previousClientSelection:l,afterCritical:d}=e;if(!n.isEnabled)return null;const u=nt(n.descriptor.id,o),p=st(r,n),f=(e=>{let{isMovingForward:t,draggable:r,destination:n,insideDestination:o,previousImpact:i}=e;if(!n.isCombineEnabled)return null;if(!ot(i))return null;function a(e){const t={type:"COMBINE",combine:{draggableId:e,droppableId:n.descriptor.id}};return{...i,at:t}}const s=i.displaced.all,l=s.length?s[0]:null;if(t)return l?a(l):null;const d=at(r,o);if(!l)return d.length?a(d[d.length-1].descriptor.id):null;const u=d.findIndex((e=>e.descriptor.id===l));-1===u&&c(!1);const p=u-1;return p<0?null:a(d[p].descriptor.id)})({isMovingForward:t,draggable:r,destination:n,insideDestination:u,previousImpact:i})||St({isMovingForward:t,isInHomeList:p,draggable:r,draggables:o,destination:n,insideDestination:u,previousImpact:i,viewport:a,afterCritical:d});if(!f)return null;const g=Bt({impact:f,draggable:r,droppable:n,draggables:o,afterCritical:d});if(Gt({draggable:r,destination:n,newPageBorderBoxCenter:g,viewport:a.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})){return{clientSelection:Mt({pageBorderBoxCenter:g,draggable:r,viewport:a}),impact:f,scrollJumpRequest:null}}const m=Ce(g,s),b=(e=>{let{impact:t,viewport:r,destination:n,draggables:o,maxScrollChange:i}=e;const a=Tt(r,Ee(r.scroll.current,i)),s=n.frame?Je(n,Ee(n.frame.scroll.current,i)):n,l=t.displaced,c=xt({afterDragging:Lt(l.all,o),destination:n,displacedBy:t.displacedBy,viewport:a.frame,last:l,forceShouldAnimate:!1}),d=xt({afterDragging:Lt(l.all,o),destination:s,displacedBy:t.displacedBy,viewport:r.frame,last:l,forceShouldAnimate:!1}),u={},p={},f=[l,c,d];return l.all.forEach((e=>{const t=function(e,t){for(let r=0;r<t.length;r++){const n=t[r].visible[e];if(n)return n}return null}(e,f);t?p[e]=t:u[e]=!0})),{...t,displaced:{all:l.all,invisible:u,visible:p}}})({impact:f,viewport:a,destination:n,draggables:o,maxScrollChange:m});return{clientSelection:l,impact:b,scrollJumpRequest:m}};const $t=e=>{const t=e.subject.active;return t||c(!1),t};const Ft=(e,t)=>{const r=e.page.borderBox.center;return wt(e.descriptor.id,t)?Ce(r,t.displacedBy.point):r},Wt=(e,t)=>{const r=e.page.borderBox;return wt(e.descriptor.id,t)?qe(r,Oe(t.displacedBy.point)):r};var kt=Qe((function(e,t){const r=t[e.line];return{value:r,point:Pe(e.line,r)}}));const jt=(e,t)=>({...e,scroll:{...e.scroll,max:t}}),Ut=(e,t,r)=>{const n=e.frame;st(t,e)&&c(!1),e.subject.withPlaceholder&&c(!1);const o=kt(e.axis,t.displaceBy).point,i=((e,t,r)=>{const n=e.axis;if("virtual"===e.descriptor.mode)return Pe(n.line,t[n.line]);const o=e.subject.page.contentBox[n.size],i=nt(e.descriptor.id,r).reduce(((e,t)=>e+t.client.marginBox[n.size]),0)+t[n.line]-o;return i<=0?null:Pe(n.line,i)})(e,o,r),a={placeholderSize:o,increasedBy:i,oldFrameMaxScroll:e.frame?e.frame.scroll.max:null};if(!n){const t=Ye({page:e.subject.page,withPlaceholder:a,axis:e.axis,frame:e.frame});return{...e,subject:t}}const s=i?Ee(n.scroll.max,i):n.scroll.max,l=jt(n,s),d=Ye({page:e.subject.page,withPlaceholder:a,axis:e.axis,frame:l});return{...e,subject:d,frame:l}};var Ht=e=>{let{isMovingForward:t,previousPageBorderBoxCenter:r,draggable:n,isOver:o,draggables:i,droppables:a,viewport:s,afterCritical:l}=e;const c=(e=>{let{isMovingForward:t,pageBorderBoxCenter:r,source:n,droppables:o,viewport:i}=e;const a=n.subject.active;if(!a)return null;const s=n.axis,l=ut(a[s.start],a[s.end]),c=tt(o).filter((e=>e!==n)).filter((e=>e.isEnabled)).filter((e=>Boolean(e.subject.active))).filter((e=>pt(i.frame)($t(e)))).filter((e=>{const r=$t(e);return t?a[s.crossAxisEnd]<r[s.crossAxisEnd]:r[s.crossAxisStart]<a[s.crossAxisStart]})).filter((e=>{const t=$t(e),r=ut(t[s.start],t[s.end]);return l(t[s.start])||l(t[s.end])||r(a[s.start])||r(a[s.end])})).sort(((e,r)=>{const n=$t(e)[s.crossAxisStart],o=$t(r)[s.crossAxisStart];return t?n-o:o-n})).filter(((e,t,r)=>$t(e)[s.crossAxisStart]===$t(r[0])[s.crossAxisStart]));if(!c.length)return null;if(1===c.length)return c[0];const d=c.filter((e=>ut($t(e)[s.start],$t(e)[s.end])(r[s.line])));return 1===d.length?d[0]:d.length>1?d.sort(((e,t)=>$t(e)[s.start]-$t(t)[s.start]))[0]:c.sort(((e,t)=>{const n=Ne(r,Ve($t(e))),o=Ne(r,Ve($t(t)));return n!==o?n-o:$t(e)[s.start]-$t(t)[s.start]}))[0]})({isMovingForward:t,pageBorderBoxCenter:r,source:o,droppables:a,viewport:s});if(!c)return null;const d=nt(c.descriptor.id,i),u=(e=>{let{pageBorderBoxCenter:t,viewport:r,destination:n,insideDestination:o,afterCritical:i}=e;const a=o.filter((e=>yt({target:Wt(e,i),destination:n,viewport:r.frame,withDroppableDisplacement:!0}))).sort(((e,r)=>{const o=Re(t,Nt(n,Ft(e,i))),a=Re(t,Nt(n,Ft(r,i)));return o<a?-1:a<o?1:e.descriptor.index-r.descriptor.index}));return a[0]||null})({pageBorderBoxCenter:r,viewport:s,destination:c,insideDestination:d,afterCritical:l}),p=(e=>{let{previousPageBorderBoxCenter:t,moveRelativeTo:r,insideDestination:n,draggable:o,draggables:i,destination:a,viewport:s,afterCritical:l}=e;if(!r){if(n.length)return null;const e={displaced:ct,displacedBy:lt,at:{type:"REORDER",destination:{droppableId:a.descriptor.id,index:0}}},t=Bt({impact:e,draggable:o,droppable:a,draggables:i,afterCritical:l}),r=st(o,a)?a:Ut(a,o,i);return Gt({draggable:o,destination:r,newPageBorderBoxCenter:t,viewport:s.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})?e:null}const c=Boolean(t[a.axis.line]<=r.page.borderBox.center[a.axis.line]),d=(()=>{const e=r.descriptor.index;return r.descriptor.id===o.descriptor.id||c?e:e+1})(),u=kt(a.axis,o.displaceBy);return Dt({draggable:o,insideDestination:n,destination:a,viewport:s,displacedBy:u,last:ct,index:d})})({previousPageBorderBoxCenter:r,destination:c,draggable:n,draggables:i,moveRelativeTo:u,insideDestination:d,viewport:s,afterCritical:l});if(!p)return null;const f=Bt({impact:p,draggable:n,droppable:c,draggables:i,afterCritical:l});return{clientSelection:Mt({pageBorderBoxCenter:f,draggable:n,viewport:s}),impact:p,scrollJumpRequest:null}},qt=e=>{const t=e.at;return t?"REORDER"===t.type?t.destination.droppableId:t.combine.droppableId:null};var Vt=e=>{let{state:t,type:r}=e;const n=((e,t)=>{const r=qt(e);return r?t[r]:null})(t.impact,t.dimensions.droppables),o=Boolean(n),i=t.dimensions.droppables[t.critical.droppable.id],a=n||i,s=a.axis.direction,l="vertical"===s&&("MOVE_UP"===r||"MOVE_DOWN"===r)||"horizontal"===s&&("MOVE_LEFT"===r||"MOVE_RIGHT"===r);if(l&&!o)return null;const c="MOVE_DOWN"===r||"MOVE_RIGHT"===r,d=t.dimensions.draggables[t.critical.draggable.id],u=t.current.page.borderBoxCenter,{draggables:p,droppables:f}=t.dimensions;return l?_t({isMovingForward:c,previousPageBorderBoxCenter:u,draggable:d,destination:a,draggables:p,viewport:t.viewport,previousClientSelection:t.current.client.selection,previousImpact:t.impact,afterCritical:t.afterCritical}):Ht({isMovingForward:c,previousPageBorderBoxCenter:u,draggable:d,isOver:a,draggables:p,droppables:f,viewport:t.viewport,afterCritical:t.afterCritical})};function zt(e){return"DRAGGING"===e.phase||"COLLECTING"===e.phase}function Yt(e){const t=ut(e.top,e.bottom),r=ut(e.left,e.right);return function(e){return t(e.y)&&r(e.x)}}function Jt(e){let{pageBorderBox:t,draggable:r,droppables:n}=e;const o=tt(n).filter((e=>{if(!e.isEnabled)return!1;const r=e.subject.active;if(!r)return!1;if(o=r,!((n=t).left<o.right&&n.right>o.left&&n.top<o.bottom&&n.bottom>o.top))return!1;var n,o;if(Yt(r)(t.center))return!0;const i=e.axis,a=r.center[i.crossAxisLine],s=t[i.crossAxisStart],l=t[i.crossAxisEnd],c=ut(r[i.crossAxisStart],r[i.crossAxisEnd]),d=c(s),u=c(l);return!d&&!u||(d?s<a:l>a)}));return o.length?1===o.length?o[0].descriptor.id:function(e){let{pageBorderBox:t,draggable:r,candidates:n}=e;const o=r.page.borderBox.center,i=n.map((e=>{const r=e.axis,n=Pe(e.axis.line,t.center[r.line],e.page.borderBox.center[r.crossAxisLine]);return{id:e.descriptor.id,distance:Re(o,n)}})).sort(((e,t)=>t.distance-e.distance));return i[0]?i[0].id:null}({pageBorderBox:t,draggable:r,candidates:o}):null}const Xt=(e,t)=>Me(qe(e,t));function Kt(e){let{displaced:t,id:r}=e;return Boolean(t.visible[r]||t.invisible[r])}var Qt=e=>{let{pageOffset:t,draggable:r,draggables:n,droppables:o,previousImpact:i,viewport:a,afterCritical:s}=e;const l=Xt(r.page.borderBox,t),c=Jt({pageBorderBox:l,draggable:r,droppables:o});if(!c)return dt;const d=o[c],u=nt(d.descriptor.id,n),p=((e,t)=>{const r=e.frame;return r?Xt(t,r.scroll.diff.value):t})(d,l);return(e=>{let{draggable:t,pageBorderBoxWithDroppableScroll:r,previousImpact:n,destination:o,insideDestination:i,afterCritical:a}=e;if(!o.isCombineEnabled)return null;const s=o.axis,l=kt(o.axis,t.displaceBy),c=l.value,d=r[s.start],u=r[s.end],p=at(t,i).find((e=>{const t=e.descriptor.id,r=e.page.borderBox,o=r[s.size]/4,i=wt(t,a),l=Kt({displaced:n.displaced,id:t});return i?l?u>r[s.start]+o&&u<r[s.end]-o:d>r[s.start]-c+o&&d<r[s.end]-c-o:l?u>r[s.start]+c+o&&u<r[s.end]+c-o:d>r[s.start]+o&&d<r[s.end]-o}));return p?{displacedBy:l,displaced:n.displaced,at:{type:"COMBINE",combine:{draggableId:p.descriptor.id,droppableId:o.descriptor.id}}}:null})({pageBorderBoxWithDroppableScroll:p,draggable:r,previousImpact:i,destination:d,insideDestination:u,afterCritical:s})||(e=>{let{pageBorderBoxWithDroppableScroll:t,draggable:r,destination:n,insideDestination:o,last:i,viewport:a,afterCritical:s}=e;const l=n.axis,c=kt(n.axis,r.displaceBy),d=c.value,u=t[l.start],p=t[l.end],f=function(e){let{draggable:t,closest:r,inHomeList:n}=e;return r?n&&r.descriptor.index>t.descriptor.index?r.descriptor.index-1:r.descriptor.index:null}({draggable:r,closest:at(r,o).find((e=>{const t=e.descriptor.id,r=e.page.borderBox.center[l.line],n=wt(t,s),o=Kt({displaced:i,id:t});return n?o?p<=r:u<r-d:o?p<=r+d:u<r}))||null,inHomeList:st(r,n)});return Dt({draggable:r,insideDestination:o,destination:n,viewport:a,last:i,displacedBy:c,index:f})})({pageBorderBoxWithDroppableScroll:p,draggable:r,destination:d,insideDestination:u,last:i.displaced,viewport:a,afterCritical:s})},Zt=(e,t)=>({...e,[t.descriptor.id]:t});const er=e=>{let{previousImpact:t,impact:r,droppables:n}=e;const o=qt(t),i=qt(r);if(!o)return n;if(o===i)return n;const a=n[o];if(!a.subject.withPlaceholder)return n;const s=(e=>{const t=e.subject.withPlaceholder;t||c(!1);const r=e.frame;if(!r){const t=Ye({page:e.subject.page,axis:e.axis,frame:null,withPlaceholder:null});return{...e,subject:t}}const n=t.oldFrameMaxScroll;n||c(!1);const o=jt(r,n),i=Ye({page:e.subject.page,axis:e.axis,frame:o,withPlaceholder:null});return{...e,subject:i,frame:o}})(a);return Zt(n,s)};var tr=e=>{let{state:t,clientSelection:r,dimensions:n,viewport:o,impact:i,scrollJumpRequest:a}=e;const s=o||t.viewport,l=n||t.dimensions,c=r||t.current.client.selection,d=Ce(c,t.initial.client.selection),u={offset:d,selection:c,borderBoxCenter:Ee(t.initial.client.borderBoxCenter,d)},p={selection:Ee(u.selection,s.scroll.current),borderBoxCenter:Ee(u.borderBoxCenter,s.scroll.current),offset:Ee(u.offset,s.scroll.diff.value)},f={client:u,page:p};if("COLLECTING"===t.phase)return{...t,dimensions:l,viewport:s,current:f};const g=l.draggables[t.critical.draggable.id],m=i||Qt({pageOffset:p.offset,draggable:g,draggables:l.draggables,droppables:l.droppables,previousImpact:t.impact,viewport:s,afterCritical:t.afterCritical}),b=(e=>{let{draggable:t,draggables:r,droppables:n,previousImpact:o,impact:i}=e;const a=er({previousImpact:o,impact:i,droppables:n}),s=qt(i);if(!s)return a;const l=n[s];if(st(t,l))return a;if(l.subject.withPlaceholder)return a;const c=Ut(l,t,r);return Zt(a,c)})({draggable:g,impact:m,previousImpact:t.impact,draggables:l.draggables,droppables:l.droppables});return{...t,current:f,dimensions:{draggables:l.draggables,droppables:b},impact:m,viewport:s,scrollJumpRequest:a||null,forceShouldAnimate:!a&&null}};var rr=e=>{let{impact:t,viewport:r,draggables:n,destination:o,forceShouldAnimate:i}=e;const a=t.displaced,s=function(e,t){return e.map((e=>t[e]))}(a.all,n),l=xt({afterDragging:s,destination:o,displacedBy:t.displacedBy,viewport:r.frame,forceShouldAnimate:i,last:a});return{...t,displaced:l}},nr=e=>{let{impact:t,draggable:r,droppable:n,draggables:o,viewport:i,afterCritical:a}=e;const s=Bt({impact:t,draggable:r,draggables:o,droppable:n,afterCritical:a});return Mt({pageBorderBoxCenter:s,draggable:r,viewport:i})},or=e=>{let{state:t,dimensions:r,viewport:n}=e;"SNAP"!==t.movementMode&&c(!1);const o=t.impact,i=n||t.viewport,a=r||t.dimensions,{draggables:s,droppables:l}=a,d=s[t.critical.draggable.id],u=qt(o);u||c(!1);const p=l[u],f=rr({impact:o,viewport:i,destination:p,draggables:s}),g=nr({impact:f,draggable:d,droppable:p,draggables:s,viewport:i,afterCritical:t.afterCritical});return tr({impact:f,clientSelection:g,state:t,dimensions:a,viewport:i})},ir=e=>{let{draggable:t,home:r,draggables:n,viewport:o}=e;const i=kt(r.axis,t.displaceBy),a=nt(r.descriptor.id,n),s=a.indexOf(t);-1===s&&c(!1);const l=a.slice(s+1),d=l.reduce(((e,t)=>(e[t.descriptor.id]=!0,e)),{}),u={inVirtualList:"virtual"===r.descriptor.mode,displacedBy:i,effected:d};var p;return{impact:{displaced:xt({afterDragging:l,destination:r,displacedBy:i,last:null,viewport:o.frame,forceShouldAnimate:!1}),displacedBy:i,at:{type:"REORDER",destination:(p=t.descriptor,{index:p.index,droppableId:p.droppableId})}},afterCritical:u}};var ar=e=>{let{additions:t,updatedDroppables:r,viewport:n}=e;const o=n.scroll.diff.value;return t.map((e=>{const t=e.descriptor.droppableId,i=(e=>{const t=e.frame;return t||c(!1),t})(r[t]),a=i.scroll.diff.value,s=(e=>{let{draggable:t,offset:r,initialWindowScroll:n}=e;const o=ke(t.client,r),i=je(o,n);return{...t,placeholder:{...t.placeholder,client:o},client:o,page:i}})({draggable:e,offset:Ee(o,a),initialWindowScroll:n.scroll.initial});return s}))};const sr=e=>"SNAP"===e.movementMode,lr=(e,t,r)=>{const n=((e,t)=>({draggables:e.draggables,droppables:Zt(e.droppables,t)}))(e.dimensions,t);return!sr(e)||r?tr({state:e,dimensions:n}):or({state:e,dimensions:n})};function cr(e){return e.isDragging&&"SNAP"===e.movementMode?{...e,scrollJumpRequest:null}:e}const dr={phase:"IDLE",completed:null,shouldFlush:!1};var ur=function(e,t){if(void 0===e&&(e=dr),"FLUSH"===t.type)return{...dr,shouldFlush:!0};if("INITIAL_PUBLISH"===t.type){"IDLE"!==e.phase&&c(!1);const{critical:r,clientSelection:n,viewport:o,dimensions:i,movementMode:a}=t.payload,s=i.draggables[r.draggable.id],l=i.droppables[r.droppable.id],d={selection:n,borderBoxCenter:s.client.borderBox.center,offset:Se},u={client:d,page:{selection:Ee(d.selection,o.scroll.initial),borderBoxCenter:Ee(d.selection,o.scroll.initial),offset:Ee(d.selection,o.scroll.diff.value)}},p=tt(i.droppables).every((e=>!e.isFixedOnPage)),{impact:f,afterCritical:g}=ir({draggable:s,home:l,draggables:i.draggables,viewport:o});return{phase:"DRAGGING",isDragging:!0,critical:r,movementMode:a,dimensions:i,initial:u,current:u,isWindowScrollAllowed:p,impact:f,afterCritical:g,onLiftImpact:f,viewport:o,scrollJumpRequest:null,forceShouldAnimate:null}}if("COLLECTION_STARTING"===t.type){if("COLLECTING"===e.phase||"DROP_PENDING"===e.phase)return e;"DRAGGING"!==e.phase&&c(!1);return{...e,phase:"COLLECTING"}}if("PUBLISH_WHILE_DRAGGING"===t.type)return"COLLECTING"!==e.phase&&"DROP_PENDING"!==e.phase&&c(!1),(e=>{let{state:t,published:r}=e;const n=r.modified.map((e=>{const r=t.dimensions.droppables[e.droppableId];return Je(r,e.scroll)})),o={...t.dimensions.droppables,...Ze(n)},i=et(ar({additions:r.additions,updatedDroppables:o,viewport:t.viewport})),a={...t.dimensions.draggables,...i};r.removals.forEach((e=>{delete a[e]}));const s={droppables:o,draggables:a},l=qt(t.impact),c=l?s.droppables[l]:null,d=s.draggables[t.critical.draggable.id],u=s.droppables[t.critical.droppable.id],{impact:p,afterCritical:f}=ir({draggable:d,home:u,draggables:a,viewport:t.viewport}),g=c&&c.isCombineEnabled?t.impact:p,m=Qt({pageOffset:t.current.page.offset,draggable:s.draggables[t.critical.draggable.id],draggables:s.draggables,droppables:s.droppables,previousImpact:g,viewport:t.viewport,afterCritical:f}),b={...t,phase:"DRAGGING",impact:m,onLiftImpact:p,dimensions:s,afterCritical:f,forceShouldAnimate:!1};return"COLLECTING"===t.phase?b:{...b,phase:"DROP_PENDING",reason:t.reason,isWaiting:!1}})({state:e,published:t.payload});if("MOVE"===t.type){if("DROP_PENDING"===e.phase)return e;zt(e)||c(!1);const{client:r}=t.payload;return Ae(r,e.current.client.selection)?e:tr({state:e,clientSelection:r,impact:sr(e)?e.impact:null})}if("UPDATE_DROPPABLE_SCROLL"===t.type){if("DROP_PENDING"===e.phase)return cr(e);if("COLLECTING"===e.phase)return cr(e);zt(e)||c(!1);const{id:r,newScroll:n}=t.payload,o=e.dimensions.droppables[r];if(!o)return e;const i=Je(o,n);return lr(e,i,!1)}if("UPDATE_DROPPABLE_IS_ENABLED"===t.type){if("DROP_PENDING"===e.phase)return e;zt(e)||c(!1);const{id:r,isEnabled:n}=t.payload,o=e.dimensions.droppables[r];o||c(!1),o.isEnabled===n&&c(!1);const i={...o,isEnabled:n};return lr(e,i,!0)}if("UPDATE_DROPPABLE_IS_COMBINE_ENABLED"===t.type){if("DROP_PENDING"===e.phase)return e;zt(e)||c(!1);const{id:r,isCombineEnabled:n}=t.payload,o=e.dimensions.droppables[r];o||c(!1),o.isCombineEnabled===n&&c(!1);const i={...o,isCombineEnabled:n};return lr(e,i,!0)}if("MOVE_BY_WINDOW_SCROLL"===t.type){if("DROP_PENDING"===e.phase||"DROP_ANIMATING"===e.phase)return e;zt(e)||c(!1),e.isWindowScrollAllowed||c(!1);const r=t.payload.newScroll;if(Ae(e.viewport.scroll.current,r))return cr(e);const n=Tt(e.viewport,r);return sr(e)?or({state:e,viewport:n}):tr({state:e,viewport:n})}if("UPDATE_VIEWPORT_MAX_SCROLL"===t.type){if(!zt(e))return e;const r=t.payload.maxScroll;if(Ae(r,e.viewport.scroll.max))return e;const n={...e.viewport,scroll:{...e.viewport.scroll,max:r}};return{...e,viewport:n}}if("MOVE_UP"===t.type||"MOVE_DOWN"===t.type||"MOVE_LEFT"===t.type||"MOVE_RIGHT"===t.type){if("COLLECTING"===e.phase||"DROP_PENDING"===e.phase)return e;"DRAGGING"!==e.phase&&c(!1);const r=Vt({state:e,type:t.type});return r?tr({state:e,impact:r.impact,clientSelection:r.clientSelection,scrollJumpRequest:r.scrollJumpRequest}):e}if("DROP_PENDING"===t.type){const r=t.payload.reason;"COLLECTING"!==e.phase&&c(!1);return{...e,phase:"DROP_PENDING",isWaiting:!0,reason:r}}if("DROP_ANIMATE"===t.type){const{completed:r,dropDuration:n,newHomeClientOffset:o}=t.payload;"DRAGGING"!==e.phase&&"DROP_PENDING"!==e.phase&&c(!1);return{phase:"DROP_ANIMATING",completed:r,dropDuration:n,newHomeClientOffset:o,dimensions:e.dimensions}}if("DROP_COMPLETE"===t.type){const{completed:e}=t.payload;return{phase:"IDLE",completed:e,shouldFlush:!1}}return e};const pr=e=>({type:"LIFT",payload:e}),fr=e=>({type:"PUBLISH_WHILE_DRAGGING",payload:e}),gr=()=>({type:"COLLECTION_STARTING",payload:null}),mr=e=>({type:"UPDATE_DROPPABLE_SCROLL",payload:e}),br=e=>({type:"UPDATE_DROPPABLE_IS_ENABLED",payload:e}),hr=e=>({type:"UPDATE_DROPPABLE_IS_COMBINE_ENABLED",payload:e}),yr=e=>({type:"MOVE",payload:e}),vr=()=>({type:"MOVE_UP",payload:null}),xr=()=>({type:"MOVE_DOWN",payload:null}),Ir=()=>({type:"MOVE_RIGHT",payload:null}),Dr=()=>({type:"MOVE_LEFT",payload:null}),wr=()=>({type:"FLUSH",payload:null}),Sr=e=>({type:"DROP_COMPLETE",payload:e}),Er=e=>({type:"DROP",payload:e}),Cr=()=>({type:"DROP_ANIMATION_FINISHED",payload:null});const Ar={outOfTheWay:"cubic-bezier(0.2, 0, 0, 1)",drop:"cubic-bezier(.2,1,.1,1)"},Or={opacity:{drop:0,combining:.7},scale:{drop:.75}},Pr={outOfTheWay:.2,minDropTime:.33,maxDropTime:.55},Rr=`${Pr.outOfTheWay}s ${Ar.outOfTheWay}`,Nr={fluid:`opacity ${Rr}`,snap:`transform ${Rr}, opacity ${Rr}`,drop:e=>{const t=`${e}s ${Ar.drop}`;return`transform ${t}, opacity ${t}`},outOfTheWay:`transform ${Rr}`,placeholder:`height ${Rr}, width ${Rr}, margin ${Rr}`},Br=e=>Ae(e,Se)?void 0:`translate(${e.x}px, ${e.y}px)`,Tr={moveTo:Br,drop:(e,t)=>{const r=Br(e);if(r)return t?`${r} scale(${Or.scale.drop})`:r}},{minDropTime:Lr,maxDropTime:Mr}=Pr,Gr=Mr-Lr;var _r=e=>{let{getState:t,dispatch:r}=e;return e=>n=>{if("DROP"!==n.type)return void e(n);const o=t(),i=n.payload.reason;if("COLLECTING"===o.phase)return void r((e=>({type:"DROP_PENDING",payload:e}))({reason:i}));if("IDLE"===o.phase)return;"DROP_PENDING"===o.phase&&o.isWaiting&&c(!1),"DRAGGING"!==o.phase&&"DROP_PENDING"!==o.phase&&c(!1);const a=o.critical,s=o.dimensions,l=s.draggables[o.critical.draggable.id],{impact:d,didDropInsideDroppable:u}=(e=>{let{draggables:t,reason:r,lastImpact:n,home:o,viewport:i,onLiftImpact:a}=e;if(!n.at||"DROP"!==r)return{impact:rr({draggables:t,impact:a,destination:o,viewport:i,forceShouldAnimate:!0}),didDropInsideDroppable:!1};return"REORDER"===n.at.type?{impact:n,didDropInsideDroppable:!0}:{impact:{...n,displaced:ct},didDropInsideDroppable:!0}})({reason:i,lastImpact:o.impact,afterCritical:o.afterCritical,onLiftImpact:o.onLiftImpact,home:o.dimensions.droppables[o.critical.droppable.id],viewport:o.viewport,draggables:o.dimensions.draggables}),p=u?ot(d):null,f=u?it(d):null,g={index:a.draggable.index,droppableId:a.droppable.id},m={draggableId:l.descriptor.id,type:l.descriptor.type,source:g,reason:i,mode:o.movementMode,destination:p,combine:f},b=(e=>{let{impact:t,draggable:r,dimensions:n,viewport:o,afterCritical:i}=e;const{draggables:a,droppables:s}=n,l=qt(t),c=l?s[l]:null,d=s[r.descriptor.droppableId],u=nr({impact:t,draggable:r,draggables:a,afterCritical:i,droppable:c||d,viewport:o});return Ce(u,r.client.borderBox.center)})({impact:d,draggable:l,dimensions:s,viewport:o.viewport,afterCritical:o.afterCritical}),h={critical:o.critical,afterCritical:o.afterCritical,result:m,impact:d};if(!(!Ae(o.current.client.offset,b)||Boolean(m.combine)))return void r(Sr({completed:h}));const y=(e=>{let{current:t,destination:r,reason:n}=e;const o=Re(t,r);if(o<=0)return Lr;if(o>=1500)return Mr;const i=Lr+Gr*(o/1500);return Number(("CANCEL"===n?.6*i:i).toFixed(2))})({current:o.current.client.offset,destination:b,reason:i});r((e=>({type:"DROP_ANIMATE",payload:e}))({newHomeClientOffset:b,dropDuration:y,completed:h}))}},$r=function(e){var t=[],r=null,n=function(){for(var n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];t=o,r||(r=requestAnimationFrame((function(){r=null,e.apply(void 0,t)})))};return n.cancel=function(){r&&(cancelAnimationFrame(r),r=null)},n},Fr=()=>({x:window.pageXOffset,y:window.pageYOffset});function Wr(e){let{onWindowScroll:t}=e;const r=$r((function(){t(Fr())})),n=function(e){return{eventName:"scroll",options:{passive:!0,capture:!1},fn:t=>{t.target!==window&&t.target!==window.document||e()}}}(r);let a=o;function s(){return a!==o}return{start:function(){s()&&c(!1),a=i(window,[n])},stop:function(){s()||c(!1),r.cancel(),a(),a=o},isActive:s}}var kr=e=>{const t=Wr({onWindowScroll:t=>{e.dispatch({type:"MOVE_BY_WINDOW_SCROLL",payload:{newScroll:t}})}});return e=>r=>{t.isActive()||"INITIAL_PUBLISH"!==r.type||t.start(),t.isActive()&&(e=>"DROP_COMPLETE"===e.type||"DROP_ANIMATE"===e.type||"FLUSH"===e.type)(r)&&t.stop(),e(r)}},jr=e=>{let t=!1,r=!1;const n=setTimeout((()=>{r=!0})),o=o=>{t||r||(t=!0,e(o),clearTimeout(n))};return o.wasCalled=()=>t,o},Ur=()=>{const e=[];return{add:t=>{const r=setTimeout((()=>(t=>{const r=e.findIndex((e=>e.timerId===t));-1===r&&c(!1);const[n]=e.splice(r,1);n.callback()})(r))),n={timerId:r,callback:t};e.push(n)},flush:()=>{if(!e.length)return;const t=[...e];e.length=0,t.forEach((e=>{clearTimeout(e.timerId),e.callback()}))}}};const Hr=(e,t)=>{t()},qr=(e,t)=>({draggableId:e.draggable.id,type:e.droppable.type,source:{droppableId:e.droppable.id,index:e.draggable.index},mode:t});function Vr(e,t,r,n){if(!e)return void r(n(t));const o=jr(r);e(t,{announce:o}),o.wasCalled()||r(n(t))}var zr=(e,t)=>{const r=((e,t)=>{const r=Ur();let n=null;const o=r=>{n||c(!1),n=null,Hr(0,(()=>Vr(e().onDragEnd,r,t,b.onDragEnd)))};return{beforeCapture:(t,r)=>{n&&c(!1),Hr(0,(()=>{const n=e().onBeforeCapture;n&&n({draggableId:t,mode:r})}))},beforeStart:(t,r)=>{n&&c(!1),Hr(0,(()=>{const n=e().onBeforeDragStart;n&&n(qr(t,r))}))},start:(o,i)=>{n&&c(!1);const a=qr(o,i);n={mode:i,lastCritical:o,lastLocation:a.source,lastCombine:null},r.add((()=>{Hr(0,(()=>Vr(e().onDragStart,a,t,b.onDragStart)))}))},update:(o,i)=>{const a=ot(i),s=it(i);n||c(!1);const l=!((e,t)=>{if(e===t)return!0;const r=e.draggable.id===t.draggable.id&&e.draggable.droppableId===t.draggable.droppableId&&e.draggable.type===t.draggable.type&&e.draggable.index===t.draggable.index,n=e.droppable.id===t.droppable.id&&e.droppable.type===t.droppable.type;return r&&n})(o,n.lastCritical);l&&(n.lastCritical=o);const d=(p=a,!(null==(u=n.lastLocation)&&null==p||null!=u&&null!=p&&u.droppableId===p.droppableId&&u.index===p.index));var u,p;d&&(n.lastLocation=a);const f=!((e,t)=>null==e&&null==t||null!=e&&null!=t&&e.draggableId===t.draggableId&&e.droppableId===t.droppableId)(n.lastCombine,s);if(f&&(n.lastCombine=s),!l&&!d&&!f)return;const g={...qr(o,n.mode),combine:s,destination:a};r.add((()=>{Hr(0,(()=>Vr(e().onDragUpdate,g,t,b.onDragUpdate)))}))},flush:()=>{n||c(!1),r.flush()},drop:o,abort:()=>{if(!n)return;const e={...qr(n.lastCritical,n.mode),combine:null,destination:null,reason:"CANCEL"};o(e)}}})(e,t);return e=>t=>n=>{if("BEFORE_INITIAL_CAPTURE"===n.type)return void r.beforeCapture(n.payload.draggableId,n.payload.movementMode);if("INITIAL_PUBLISH"===n.type){const e=n.payload.critical;return r.beforeStart(e,n.payload.movementMode),t(n),void r.start(e,n.payload.movementMode)}if("DROP_COMPLETE"===n.type){const e=n.payload.completed.result;return r.flush(),t(n),void r.drop(e)}if(t(n),"FLUSH"===n.type)return void r.abort();const o=e.getState();"DRAGGING"===o.phase&&r.update(o.critical,o.impact)}};var Yr=e=>t=>r=>{if("DROP_ANIMATION_FINISHED"!==r.type)return void t(r);const n=e.getState();"DROP_ANIMATING"!==n.phase&&c(!1),e.dispatch(Sr({completed:n.completed}))};var Jr=e=>{let t=null,r=null;return n=>o=>{if("FLUSH"!==o.type&&"DROP_COMPLETE"!==o.type&&"DROP_ANIMATION_FINISHED"!==o.type||(r&&(cancelAnimationFrame(r),r=null),t&&(t(),t=null)),n(o),"DROP_ANIMATE"!==o.type)return;const a={eventName:"scroll",options:{capture:!0,passive:!1,once:!0},fn:function(){"DROP_ANIMATING"===e.getState().phase&&e.dispatch({type:"DROP_ANIMATION_FINISHED",payload:null})}};r=requestAnimationFrame((()=>{r=null,t=i(window,[a])}))}};var Xr=e=>t=>r=>{if(t(r),"PUBLISH_WHILE_DRAGGING"!==r.type)return;const n=e.getState();"DROP_PENDING"===n.phase&&(n.isWaiting||e.dispatch(Er({reason:n.reason})))};const Kr=P;var Qr=e=>{let{dimensionMarshal:t,focusMarshal:r,styleMarshal:n,getResponders:o,announce:i,autoScroller:a}=e;return C(ur,Kr(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){return function(){var r=e.apply(void 0,arguments),n=function(){throw new Error(D(15))},o={getState:r.getState,dispatch:function(){return n.apply(void 0,arguments)}},i=t.map((function(e){return e(o)}));return n=P.apply(void 0,i)(r.dispatch),I(I({},r),{},{dispatch:n})}}}((s=n,()=>e=>t=>{"INITIAL_PUBLISH"===t.type&&s.dragging(),"DROP_ANIMATE"===t.type&&s.dropping(t.payload.completed.result.reason),"FLUSH"!==t.type&&"DROP_COMPLETE"!==t.type||s.resting(),e(t)}),(e=>()=>t=>r=>{"DROP_COMPLETE"!==r.type&&"FLUSH"!==r.type&&"DROP_ANIMATE"!==r.type||e.stopPublishing(),t(r)})(t),(e=>t=>{let{getState:r,dispatch:n}=t;return t=>o=>{if("LIFT"!==o.type)return void t(o);const{id:i,clientSelection:a,movementMode:s}=o.payload,l=r();"DROP_ANIMATING"===l.phase&&n(Sr({completed:l.completed})),"IDLE"!==r().phase&&c(!1),n(wr()),n({type:"BEFORE_INITIAL_CAPTURE",payload:{draggableId:i,movementMode:s}});const d={draggableId:i,scrollOptions:{shouldPublishImmediately:"SNAP"===s}},{critical:u,dimensions:p,viewport:f}=e.startPublishing(d);n({type:"INITIAL_PUBLISH",payload:{critical:u,dimensions:p,clientSelection:a,movementMode:s,viewport:f}})}})(t),_r,Yr,Jr,Xr,(e=>t=>r=>n=>{if((e=>"DROP_COMPLETE"===e.type||"DROP_ANIMATE"===e.type||"FLUSH"===e.type)(n))return e.stop(),void r(n);if("INITIAL_PUBLISH"===n.type){r(n);const o=t.getState();return"DRAGGING"!==o.phase&&c(!1),void e.start(o)}r(n),e.scroll(t.getState())})(a),kr,(e=>{let t=!1;return()=>r=>n=>{if("INITIAL_PUBLISH"===n.type)return t=!0,e.tryRecordFocus(n.payload.critical.draggable.id),r(n),void e.tryRestoreFocusRecorded();if(r(n),t){if("FLUSH"===n.type)return t=!1,void e.tryRestoreFocusRecorded();if("DROP_COMPLETE"===n.type){t=!1;const r=n.payload.completed.result;r.combine&&e.tryShiftRecord(r.draggableId,r.combine.draggableId),e.tryRestoreFocusRecorded()}}}})(r),zr(o,i))));var s};const Zr=()=>({additions:{},removals:{},modified:{}});var en=e=>{let{scrollHeight:t,scrollWidth:r,height:n,width:o}=e;const i=Ce({x:r,y:t},{x:o,y:n});return{x:Math.max(0,i.x),y:Math.max(0,i.y)}},tn=()=>{const e=document.documentElement;return e||c(!1),e},rn=()=>{const e=tn();return en({scrollHeight:e.scrollHeight,scrollWidth:e.scrollWidth,width:e.clientWidth,height:e.clientHeight})},nn=e=>{let{critical:t,scrollOptions:r,registry:n}=e;const o=(()=>{const e=Fr(),t=rn(),r=e.y,n=e.x,o=tn(),i=o.clientWidth,a=o.clientHeight;return{frame:Me({top:r,left:n,right:n+i,bottom:r+a}),scroll:{initial:e,current:e,max:t,diff:{value:Se,displacement:Se}}}})(),i=o.scroll.current,a=t.droppable,s=n.droppable.getAllByType(a.type).map((e=>e.callbacks.getDimensionAndWatchScroll(i,r))),l=n.draggable.getAllByType(t.draggable.type).map((e=>e.getDimension(i)));return{dimensions:{draggables:et(l),droppables:Ze(s)},critical:t,viewport:o}};function on(e,t,r){if(r.descriptor.id===t.id)return!1;if(r.descriptor.type!==t.type)return!1;return"virtual"===e.droppable.getById(r.descriptor.droppableId).descriptor.mode}var an=(e,t)=>{let r=null;const n=function(e){let{registry:t,callbacks:r}=e,n=Zr(),o=null;const i=()=>{o||(r.collectionStarting(),o=requestAnimationFrame((()=>{o=null;const{additions:e,removals:i,modified:a}=n,s=Object.keys(e).map((e=>t.draggable.getById(e).getDimension(Se))).sort(((e,t)=>e.descriptor.index-t.descriptor.index)),l=Object.keys(a).map((e=>({droppableId:e,scroll:t.droppable.getById(e).callbacks.getScrollWhileDragging()}))),c={additions:s,removals:Object.keys(i),modified:l};n=Zr(),r.publish(c)})))};return{add:e=>{const t=e.descriptor.id;n.additions[t]=e,n.modified[e.descriptor.droppableId]=!0,n.removals[t]&&delete n.removals[t],i()},remove:e=>{const t=e.descriptor;n.removals[t.id]=!0,n.modified[t.droppableId]=!0,n.additions[t.id]&&delete n.additions[t.id],i()},stop:()=>{o&&(cancelAnimationFrame(o),o=null,n=Zr())}}}({callbacks:{publish:t.publishWhileDragging,collectionStarting:t.collectionStarting},registry:e}),o=t=>{r||c(!1);const o=r.critical.draggable;"ADDITION"===t.type&&on(e,o,t.value)&&n.add(t.value),"REMOVAL"===t.type&&on(e,o,t.value)&&n.remove(t.value)},i={updateDroppableIsEnabled:(n,o)=>{e.droppable.exists(n)||c(!1),r&&t.updateDroppableIsEnabled({id:n,isEnabled:o})},updateDroppableIsCombineEnabled:(n,o)=>{r&&(e.droppable.exists(n)||c(!1),t.updateDroppableIsCombineEnabled({id:n,isCombineEnabled:o}))},scrollDroppable:(t,n)=>{r&&e.droppable.getById(t).callbacks.scroll(n)},updateDroppableScroll:(n,o)=>{r&&(e.droppable.exists(n)||c(!1),t.updateDroppableScroll({id:n,newScroll:o}))},startPublishing:t=>{r&&c(!1);const n=e.draggable.getById(t.draggableId),i=e.droppable.getById(n.descriptor.droppableId),a={draggable:n.descriptor,droppable:i.descriptor},s=e.subscribe(o);return r={critical:a,unsubscribe:s},nn({critical:a,registry:e,scrollOptions:t.scrollOptions})},stopPublishing:()=>{if(!r)return;n.stop();const t=r.critical.droppable;e.droppable.getAllByType(t.type).forEach((e=>e.callbacks.dragStopped())),r.unsubscribe(),r=null}};return i},sn=(e,t)=>"IDLE"===e.phase||"DROP_ANIMATING"===e.phase&&(e.completed.result.draggableId!==t&&"DROP"===e.completed.result.reason),ln=e=>{window.scrollBy(e.x,e.y)};const cn=Qe((e=>tt(e).filter((e=>!!e.isEnabled&&!!e.frame))));var dn=e=>{let{center:t,destination:r,droppables:n}=e;if(r){const e=n[r];return e.frame?e:null}const o=((e,t)=>{const r=cn(t).find((t=>(t.frame||c(!1),Yt(t.frame.pageMarginBox)(e))))||null;return r})(t,n);return o};const un={startFromPercentage:.25,maxScrollAtPercentage:.05,maxPixelScroll:28,ease:e=>e**2,durationDampening:{stopDampeningAt:1200,accelerateAt:360},disabled:!1};var pn=e=>{let{startOfRange:t,endOfRange:r,current:n}=e;const o=r-t;if(0===o)return 0;return(n-t)/o},fn=e=>{let{distanceToEdge:t,thresholds:r,dragStartTime:n,shouldUseTimeDampening:o,getAutoScrollerOptions:i}=e;const a=function(e,t,r){void 0===r&&(r=()=>un);const n=r();if(e>t.startScrollingFrom)return 0;if(e<=t.maxScrollValueAt)return n.maxPixelScroll;if(e===t.startScrollingFrom)return 1;const o=1-pn({startOfRange:t.maxScrollValueAt,endOfRange:t.startScrollingFrom,current:e}),i=n.maxPixelScroll*n.ease(o);return Math.ceil(i)}(t,r,i);return 0===a?0:o?Math.max(((e,t,r)=>{const n=r(),o=n.durationDampening.accelerateAt,i=n.durationDampening.stopDampeningAt,a=t,s=i,l=Date.now()-a;if(l>=i)return e;if(l<o)return 1;const c=pn({startOfRange:o,endOfRange:s,current:l}),d=e*n.ease(c);return Math.ceil(d)})(a,n,i),1):a},gn=e=>{let{container:t,distanceToEdges:r,dragStartTime:n,axis:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=function(e,t,r){void 0===r&&(r=()=>un);const n=r();return{startScrollingFrom:e[t.size]*n.startFromPercentage,maxScrollValueAt:e[t.size]*n.maxScrollAtPercentage}}(t,o,a);return r[o.end]<r[o.start]?fn({distanceToEdge:r[o.end],thresholds:s,dragStartTime:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a}):-1*fn({distanceToEdge:r[o.start],thresholds:s,dragStartTime:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a})};const mn=Be((e=>0===e?0:e));var bn=e=>{let{dragStartTime:t,container:r,subject:n,center:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s={top:o.y-r.top,right:r.right-o.x,bottom:r.bottom-o.y,left:o.x-r.left},l=gn({container:r,distanceToEdges:s,dragStartTime:t,axis:gt,shouldUseTimeDampening:i,getAutoScrollerOptions:a}),c=gn({container:r,distanceToEdges:s,dragStartTime:t,axis:mt,shouldUseTimeDampening:i,getAutoScrollerOptions:a}),d=mn({x:c,y:l});if(Ae(d,Se))return null;const u=(e=>{let{container:t,subject:r,proposedScroll:n}=e;const o=r.height>t.height,i=r.width>t.width;return i||o?i&&o?null:{x:i?0:n.x,y:o?0:n.y}:n})({container:r,subject:n,proposedScroll:d});return u?Ae(u,Se)?null:u:null};const hn=Be((e=>0===e?0:e>0?1:-1)),yn=(()=>{const e=(e,t)=>e<0?e:e>t?e-t:0;return t=>{let{current:r,max:n,change:o}=t;const i=Ee(r,o),a={x:e(i.x,n.x),y:e(i.y,n.y)};return Ae(a,Se)?null:a}})(),vn=e=>{let{max:t,current:r,change:n}=e;const o={x:Math.max(r.x,t.x),y:Math.max(r.y,t.y)},i=hn(n),a=yn({max:o,current:r,change:i});return!a||(0!==i.x&&0===a.x||0!==i.y&&0===a.y)},xn=(e,t)=>vn({current:e.scroll.current,max:e.scroll.max,change:t}),In=(e,t)=>{const r=e.frame;return!!r&&vn({current:r.scroll.current,max:r.scroll.max,change:t})};var Dn=e=>{let{state:t,dragStartTime:r,shouldUseTimeDampening:n,scrollWindow:o,scrollDroppable:i,getAutoScrollerOptions:a}=e;const s=t.current.page.borderBoxCenter,l=t.dimensions.draggables[t.critical.draggable.id].page.marginBox;if(t.isWindowScrollAllowed){const e=(e=>{let{viewport:t,subject:r,center:n,dragStartTime:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=bn({dragStartTime:o,container:t.frame,subject:r,center:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a});return s&&xn(t,s)?s:null})({dragStartTime:r,viewport:t.viewport,subject:l,center:s,shouldUseTimeDampening:n,getAutoScrollerOptions:a});if(e)return void o(e)}const c=dn({center:s,destination:qt(t.impact),droppables:t.dimensions.droppables});if(!c)return;const d=(e=>{let{droppable:t,subject:r,center:n,dragStartTime:o,shouldUseTimeDampening:i,getAutoScrollerOptions:a}=e;const s=t.frame;if(!s)return null;const l=bn({dragStartTime:o,container:s.pageMarginBox,subject:r,center:n,shouldUseTimeDampening:i,getAutoScrollerOptions:a});return l&&In(t,l)?l:null})({dragStartTime:r,droppable:c,subject:l,center:s,shouldUseTimeDampening:n,getAutoScrollerOptions:a});d&&i(c.descriptor.id,d)},wn=e=>{let{scrollWindow:t,scrollDroppable:r,getAutoScrollerOptions:n=(()=>un)}=e;const o=$r(t),i=$r(r);let a=null;const s=e=>{a||c(!1);const{shouldUseTimeDampening:t,dragStartTime:r}=a;Dn({state:e,scrollWindow:o,scrollDroppable:i,dragStartTime:r,shouldUseTimeDampening:t,getAutoScrollerOptions:n})};return{start:e=>{a&&c(!1);const t=Date.now();let r=!1;const o=()=>{r=!0};Dn({state:e,dragStartTime:0,shouldUseTimeDampening:!1,scrollWindow:o,scrollDroppable:o,getAutoScrollerOptions:n}),a={dragStartTime:t,shouldUseTimeDampening:r},r&&s(e)},stop:()=>{a&&(o.cancel(),i.cancel(),a=null)},scroll:s}},Sn=e=>{let{move:t,scrollDroppable:r,scrollWindow:n}=e;const o=(e,t)=>{if(!In(e,t))return t;const n=((e,t)=>{const r=e.frame;return r&&In(e,t)?yn({current:r.scroll.current,max:r.scroll.max,change:t}):null})(e,t);if(!n)return r(e.descriptor.id,t),null;const o=Ce(t,n);r(e.descriptor.id,o);return Ce(t,o)},i=(e,t,r)=>{if(!e)return r;if(!xn(t,r))return r;const o=((e,t)=>{if(!xn(e,t))return null;const r=e.scroll.max,n=e.scroll.current;return yn({current:n,max:r,change:t})})(t,r);if(!o)return n(r),null;const i=Ce(r,o);n(i);return Ce(r,i)};return e=>{const r=e.scrollJumpRequest;if(!r)return;const n=qt(e.impact);n||c(!1);const a=o(e.dimensions.droppables[n],r);if(!a)return;const s=e.viewport,l=i(e.isWindowScrollAllowed,s,a);l&&((e,r)=>{const n=Ee(e.current.client.selection,r);t({client:n})})(e,l)}},En=e=>{let{scrollDroppable:t,scrollWindow:r,move:n,getAutoScrollerOptions:o}=e;const i=wn({scrollWindow:r,scrollDroppable:t,getAutoScrollerOptions:o}),a=Sn({move:n,scrollWindow:r,scrollDroppable:t});return{scroll:e=>{o().disabled||"DRAGGING"!==e.phase||("FLUID"!==e.movementMode?e.scrollJumpRequest&&a(e):i.scroll(e))},start:i.start,stop:i.stop}};const Cn="data-rfd",An=(()=>{const e=`${Cn}-drag-handle`;return{base:e,draggableId:`${e}-draggable-id`,contextId:`${e}-context-id`}})(),On=(()=>{const e=`${Cn}-draggable`;return{base:e,contextId:`${e}-context-id`,id:`${e}-id`}})(),Pn=(()=>{const e=`${Cn}-droppable`;return{base:e,contextId:`${e}-context-id`,id:`${e}-id`}})(),Rn={contextId:`${Cn}-scroll-container-context-id`},Nn=(e,t)=>e.map((e=>{const r=e.styles[t];return r?`${e.selector} { ${r} }`:""})).join(" ");var Bn=e=>{const t=(r=e,e=>`[${e}="${r}"]`);var r;const n=(()=>{const e="\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";return{selector:t(An.contextId),styles:{always:"\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",resting:e,dragging:"pointer-events: none;",dropAnimating:e}}})(),o=[(()=>{const e=`\n      transition: ${Nr.outOfTheWay};\n    `;return{selector:t(On.contextId),styles:{dragging:e,dropAnimating:e,userCancel:e}}})(),n,{selector:t(Pn.contextId),styles:{always:"overflow-anchor: none;"}},{selector:"body",styles:{dragging:"\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "}}];return{always:Nn(o,"always"),resting:Nn(o,"resting"),dragging:Nn(o,"dragging"),dropAnimating:Nn(o,"dropAnimating"),userCancel:Nn(o,"userCancel")}};var Tn="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?t.useLayoutEffect:t.useEffect;const Ln=()=>{const e=document.querySelector("head");return e||c(!1),e},Mn=e=>{const t=document.createElement("style");return e&&t.setAttribute("nonce",e),t.type="text/css",t};function Gn(e,t){return Array.from(e.querySelectorAll(t))}var _n=e=>e?.ownerDocument?.defaultView||window;function $n(e){return e instanceof _n(e).HTMLElement}function Fn(e){const r=t.useRef({}),n=t.useRef(null),o=t.useRef(null),i=t.useRef(!1),a=we((function(e,t){const n={id:e,focus:t};return r.current[e]=n,function(){const t=r.current;t[e]!==n&&delete t[e]}}),[]),s=we((function(t){const r=function(e,t){const r=`[${An.contextId}="${e}"]`,n=Gn(document,r);if(!n.length)return null;const o=n.find((e=>e.getAttribute(An.draggableId)===t));return o&&$n(o)?o:null}(e,t);r&&r!==document.activeElement&&r.focus()}),[e]),l=we((function(e,t){n.current===e&&(n.current=t)}),[]),c=we((function(){o.current||i.current&&(o.current=requestAnimationFrame((()=>{o.current=null;const e=n.current;e&&s(e)})))}),[s]),d=we((function(e){n.current=null;const t=document.activeElement;t&&t.getAttribute(An.draggableId)===e&&(n.current=e)}),[]);Tn((()=>(i.current=!0,function(){i.current=!1;const e=o.current;e&&cancelAnimationFrame(e)})),[]);return De((()=>({register:a,tryRecordFocus:d,tryRestoreFocusRecorded:c,tryShiftRecord:l})),[a,d,c,l])}function Wn(){const e={draggables:{},droppables:{}},t=[];function r(e){t.length&&t.forEach((t=>t(e)))}function n(t){return e.draggables[t]||null}function o(t){return e.droppables[t]||null}return{draggable:{register:t=>{e.draggables[t.descriptor.id]=t,r({type:"ADDITION",value:t})},update:(t,r)=>{const n=e.draggables[r.descriptor.id];n&&n.uniqueId===t.uniqueId&&(delete e.draggables[r.descriptor.id],e.draggables[t.descriptor.id]=t)},unregister:t=>{const o=t.descriptor.id,i=n(o);i&&t.uniqueId===i.uniqueId&&(delete e.draggables[o],e.droppables[t.descriptor.droppableId]&&r({type:"REMOVAL",value:t}))},getById:function(e){const t=n(e);return t||c(!1),t},findById:n,exists:e=>Boolean(n(e)),getAllByType:t=>Object.values(e.draggables).filter((e=>e.descriptor.type===t))},droppable:{register:t=>{e.droppables[t.descriptor.id]=t},unregister:t=>{const r=o(t.descriptor.id);r&&t.uniqueId===r.uniqueId&&delete e.droppables[t.descriptor.id]},getById:function(e){const t=o(e);return t||c(!1),t},findById:o,exists:e=>Boolean(o(e)),getAllByType:t=>Object.values(e.droppables).filter((e=>e.descriptor.type===t))},subscribe:function(e){return t.push(e),function(){const r=t.indexOf(e);-1!==r&&t.splice(r,1)}},clean:function(){e.draggables={},e.droppables={},t.length=0}}}var kn=t.createContext(null),jn=()=>{const e=document.body;return e||c(!1),e};var Un={position:"absolute",width:"1px",height:"1px",margin:"-1px",border:"0",padding:"0",overflow:"hidden",clip:"rect(0 0 0 0)","clip-path":"inset(100%)"};const Hn=e=>`rfd-announcement-${e}`;let qn=0;const Vn={separator:"::"};var zn="useId"in t?function(e,r){void 0===r&&(r=Vn);const n=t.useId();return De((()=>`${e}${r.separator}${n}`),[r.separator,e,n])}:function(e,t){return void 0===t&&(t=Vn),De((()=>`${e}${t.separator}${qn++}`),[t.separator,e])};var Yn=t.createContext(null);function Jn(e){const r=t.useRef(e);return t.useEffect((()=>{r.current=e})),r}function Xn(e){return"IDLE"!==e.phase&&"DROP_ANIMATING"!==e.phase&&e.isDragging}const Kn=27,Qn=32,Zn=37,eo=38,to=39,ro=40,no={13:!0,9:!0};var oo=e=>{no[e.keyCode]&&e.preventDefault()};var io=(()=>{const e="visibilitychange";if("undefined"==typeof document)return e;return[e,`ms${e}`,`webkit${e}`,`moz${e}`,`o${e}`].find((e=>`on${e}`in document))||e})();const ao=0,so=5;const lo={type:"IDLE"};function co(e){let{cancel:t,completed:r,getPhase:n,setPhase:o}=e;return[{eventName:"mousemove",fn:e=>{const{button:t,clientX:r,clientY:i}=e;if(t!==ao)return;const a={x:r,y:i},s=n();if("DRAGGING"===s.type)return e.preventDefault(),void s.actions.move(a);"PENDING"!==s.type&&c(!1);const l=s.point;if(d=l,u=a,!(Math.abs(u.x-d.x)>=so||Math.abs(u.y-d.y)>=so))return;var d,u;e.preventDefault();const p=s.actions.fluidLift(a);o({type:"DRAGGING",actions:p})}},{eventName:"mouseup",fn:e=>{const o=n();"DRAGGING"===o.type?(e.preventDefault(),o.actions.drop({shouldBlockNextClick:!0}),r()):t()}},{eventName:"mousedown",fn:e=>{"DRAGGING"===n().type&&e.preventDefault(),t()}},{eventName:"keydown",fn:e=>{if("PENDING"!==n().type)return e.keyCode===Kn?(e.preventDefault(),void t()):void oo(e);t()}},{eventName:"resize",fn:t},{eventName:"scroll",options:{passive:!0,capture:!1},fn:()=>{"PENDING"===n().type&&t()}},{eventName:"webkitmouseforcedown",fn:e=>{const r=n();"IDLE"===r.type&&c(!1),r.actions.shouldRespectForcePress()?t():e.preventDefault()}},{eventName:io,fn:t}]}function uo(e){const r=t.useRef(lo),n=t.useRef(o),a=De((()=>({eventName:"mousedown",fn:function(t){if(t.defaultPrevented)return;if(t.button!==ao)return;if(t.ctrlKey||t.metaKey||t.shiftKey||t.altKey)return;const r=e.findClosestDraggableId(t);if(!r)return;const o=e.tryGetLock(r,d,{sourceEvent:t});if(!o)return;t.preventDefault();const i={x:t.clientX,y:t.clientY};n.current(),f(o,i)}})),[e]),s=De((()=>({eventName:"webkitmouseforcewillbegin",fn:t=>{if(t.defaultPrevented)return;const r=e.findClosestDraggableId(t);if(!r)return;const n=e.findOptionsForDraggable(r);n&&(n.shouldRespectForcePress||e.canGetLock(r)&&t.preventDefault())}})),[e]),l=we((function(){n.current=i(window,[s,a],{passive:!1,capture:!0})}),[s,a]),d=we((()=>{"IDLE"!==r.current.type&&(r.current=lo,n.current(),l())}),[l]),u=we((()=>{const e=r.current;d(),"DRAGGING"===e.type&&e.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===e.type&&e.actions.abort()}),[d]),p=we((function(){const e=co({cancel:u,completed:d,getPhase:()=>r.current,setPhase:e=>{r.current=e}});n.current=i(window,e,{capture:!0,passive:!1})}),[u,d]),f=we((function(e,t){"IDLE"!==r.current.type&&c(!1),r.current={type:"PENDING",point:t,actions:e},p()}),[p]);Tn((function(){return l(),function(){n.current()}}),[l])}function po(){}const fo={34:!0,33:!0,36:!0,35:!0};function go(e,t){function r(){t(),e.cancel()}return[{eventName:"keydown",fn:n=>n.keyCode===Kn?(n.preventDefault(),void r()):n.keyCode===Qn?(n.preventDefault(),t(),void e.drop()):n.keyCode===ro?(n.preventDefault(),void e.moveDown()):n.keyCode===eo?(n.preventDefault(),void e.moveUp()):n.keyCode===to?(n.preventDefault(),void e.moveRight()):n.keyCode===Zn?(n.preventDefault(),void e.moveLeft()):void(fo[n.keyCode]?n.preventDefault():oo(n))},{eventName:"mousedown",fn:r},{eventName:"mouseup",fn:r},{eventName:"click",fn:r},{eventName:"touchstart",fn:r},{eventName:"resize",fn:r},{eventName:"wheel",fn:r,options:{passive:!0}},{eventName:io,fn:r}]}function mo(e){const r=t.useRef(po),n=De((()=>({eventName:"keydown",fn:function(t){if(t.defaultPrevented)return;if(t.keyCode!==Qn)return;const n=e.findClosestDraggableId(t);if(!n)return;const a=e.tryGetLock(n,d,{sourceEvent:t});if(!a)return;t.preventDefault();let s=!0;const l=a.snapLift();function d(){s||c(!1),s=!1,r.current(),o()}r.current(),r.current=i(window,go(l,d),{capture:!0,passive:!1})}})),[e]),o=we((function(){r.current=i(window,[n],{passive:!1,capture:!0})}),[n]);Tn((function(){return o(),function(){r.current()}}),[o])}const bo={type:"IDLE"},ho=120,yo=.15;function vo(e){const r=t.useRef(bo),n=t.useRef(o),a=we((function(){return r.current}),[]),s=we((function(e){r.current=e}),[]),l=De((()=>({eventName:"touchstart",fn:function(t){if(t.defaultPrevented)return;const r=e.findClosestDraggableId(t);if(!r)return;const o=e.tryGetLock(r,u,{sourceEvent:t});if(!o)return;const i=t.touches[0],{clientX:a,clientY:s}=i,l={x:a,y:s};n.current(),m(o,l)}})),[e]),d=we((function(){n.current=i(window,[l],{capture:!0,passive:!1})}),[l]),u=we((()=>{const e=r.current;"IDLE"!==e.type&&("PENDING"===e.type&&clearTimeout(e.longPressTimerId),s(bo),n.current(),d())}),[d,s]),p=we((()=>{const e=r.current;u(),"DRAGGING"===e.type&&e.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===e.type&&e.actions.abort()}),[u]),f=we((function(){const e={capture:!0,passive:!1},t={cancel:p,completed:u,getPhase:a},r=i(window,function(e){let{cancel:t,completed:r,getPhase:n}=e;return[{eventName:"touchmove",options:{capture:!1},fn:e=>{const r=n();if("DRAGGING"!==r.type)return void t();r.hasMoved=!0;const{clientX:o,clientY:i}=e.touches[0],a={x:o,y:i};e.preventDefault(),r.actions.move(a)}},{eventName:"touchend",fn:e=>{const o=n();"DRAGGING"===o.type?(e.preventDefault(),o.actions.drop({shouldBlockNextClick:!0}),r()):t()}},{eventName:"touchcancel",fn:e=>{"DRAGGING"===n().type?(e.preventDefault(),t()):t()}},{eventName:"touchforcechange",fn:e=>{const r=n();"IDLE"===r.type&&c(!1);const o=e.touches[0];if(!o)return;if(!(o.force>=yo))return;const i=r.actions.shouldRespectForcePress();if("PENDING"!==r.type)return i?r.hasMoved?void e.preventDefault():void t():void e.preventDefault();i&&t()}},{eventName:io,fn:t}]}(t),e),o=i(window,function(e){let{cancel:t,getPhase:r}=e;return[{eventName:"orientationchange",fn:t},{eventName:"resize",fn:t},{eventName:"contextmenu",fn:e=>{e.preventDefault()}},{eventName:"keydown",fn:e=>{"DRAGGING"===r().type?(e.keyCode===Kn&&e.preventDefault(),t()):t()}},{eventName:io,fn:t}]}(t),e);n.current=function(){r(),o()}}),[p,a,u]),g=we((function(){const e=a();"PENDING"!==e.type&&c(!1);const t=e.actions.fluidLift(e.point);s({type:"DRAGGING",actions:t,hasMoved:!1})}),[a,s]),m=we((function(e,t){"IDLE"!==a().type&&c(!1);const r=setTimeout(g,ho);s({type:"PENDING",point:t,actions:e,longPressTimerId:r}),f()}),[f,a,s,g]);Tn((function(){return d(),function(){n.current();const e=a();"PENDING"===e.type&&(clearTimeout(e.longPressTimerId),s(bo))}}),[a,d,s]),Tn((function(){return i(window,[{eventName:"touchmove",fn:()=>{},options:{capture:!1,passive:!1}}])}),[])}const xo=["input","button","textarea","select","option","optgroup","video","audio"];function Io(e,t){if(null==t)return!1;if(xo.includes(t.tagName.toLowerCase()))return!0;const r=t.getAttribute("contenteditable");return"true"===r||""===r||t!==e&&Io(e,t.parentElement)}function Do(e,t){const r=t.target;return!!$n(r)&&Io(e,r)}var wo=e=>Me(e.getBoundingClientRect()).center;const So=(()=>{const e="matches";if("undefined"==typeof document)return e;return[e,"msMatchesSelector","webkitMatchesSelector"].find((e=>e in Element.prototype))||e})();function Eo(e,t){return null==e?null:e[So](t)?e:Eo(e.parentElement,t)}function Co(e,t){return e.closest?e.closest(t):Eo(e,t)}function Ao(e,t){const r=t.target;if(!((n=r)instanceof _n(n).Element))return null;var n;const o=function(e){return`[${An.contextId}="${e}"]`}(e),i=Co(r,o);return i&&$n(i)?i:null}function Oo(e){e.preventDefault()}function Po(e){let{expected:t,phase:r,isLockActive:n,shouldWarn:o}=e;return!!n()&&t===r}function Ro(e){let{lockAPI:t,store:r,registry:n,draggableId:o}=e;if(t.isClaimed())return!1;const i=n.draggable.findById(o);return!!i&&(!!i.options.isEnabled&&!!sn(r.getState(),o))}function No(e){let{lockAPI:t,contextId:r,store:n,registry:a,draggableId:s,forceSensorStop:l,sourceEvent:d}=e;if(!Ro({lockAPI:t,store:n,registry:a,draggableId:s}))return null;const u=a.draggable.getById(s),p=function(e,t){const r=`[${On.contextId}="${e}"]`,n=Gn(document,r).find((e=>e.getAttribute(On.id)===t));return n&&$n(n)?n:null}(r,u.descriptor.id);if(!p)return null;if(d&&!u.options.canDragInteractiveElements&&Do(p,d))return null;const f=t.claim(l||o);let g="PRE_DRAG";function m(){return u.options.shouldRespectForcePress}function b(){return t.isActive(f)}const h=function(e,t){Po({expected:e,phase:g,isLockActive:b,shouldWarn:!0})&&n.dispatch(t())}.bind(null,"DRAGGING");function y(e){function r(){t.release(),g="COMPLETED"}function o(t,o){if(void 0===o&&(o={shouldBlockNextClick:!1}),e.cleanup(),o.shouldBlockNextClick){const e=i(window,[{eventName:"click",fn:Oo,options:{once:!0,passive:!1,capture:!0}}]);setTimeout(e)}r(),n.dispatch(Er({reason:t}))}return"PRE_DRAG"!==g&&(r(),c(!1)),n.dispatch(pr(e.liftActionArgs)),g="DRAGGING",{isActive:()=>Po({expected:"DRAGGING",phase:g,isLockActive:b,shouldWarn:!1}),shouldRespectForcePress:m,drop:e=>o("DROP",e),cancel:e=>o("CANCEL",e),...e.actions}}return{isActive:()=>Po({expected:"PRE_DRAG",phase:g,isLockActive:b,shouldWarn:!1}),shouldRespectForcePress:m,fluidLift:function(e){const t=$r((e=>{h((()=>yr({client:e})))}));return{...y({liftActionArgs:{id:s,clientSelection:e,movementMode:"FLUID"},cleanup:()=>t.cancel(),actions:{move:t}}),move:t}},snapLift:function(){const e={moveUp:()=>h(vr),moveRight:()=>h(Ir),moveDown:()=>h(xr),moveLeft:()=>h(Dr)};return y({liftActionArgs:{id:s,clientSelection:wo(p),movementMode:"SNAP"},cleanup:o,actions:e})},abort:function(){Po({expected:"PRE_DRAG",phase:g,isLockActive:b,shouldWarn:!0})&&t.release()}}}const Bo=[uo,mo,vo];function To(e){let{contextId:r,store:n,registry:o,customSensors:i,enableDefaultSensors:a}=e;const s=[...a?Bo:[],...i||[]],l=t.useState((()=>function(){let e=null;function t(){e||c(!1),e=null}return{isClaimed:function(){return Boolean(e)},isActive:function(t){return t===e},claim:function(t){e&&c(!1);const r={abandon:t};return e=r,r},release:t,tryAbandon:function(){e&&(e.abandon(),t())}}}()))[0],d=we((function(e,t){Xn(e)&&!Xn(t)&&l.tryAbandon()}),[l]);Tn((function(){let e=n.getState();return n.subscribe((()=>{const t=n.getState();d(e,t),e=t}))}),[l,n,d]),Tn((()=>l.tryAbandon),[l.tryAbandon]);const u=we((e=>Ro({lockAPI:l,registry:o,store:n,draggableId:e})),[l,o,n]),p=we(((e,t,i)=>No({lockAPI:l,registry:o,contextId:r,store:n,draggableId:e,forceSensorStop:t||null,sourceEvent:i&&i.sourceEvent?i.sourceEvent:null})),[r,l,o,n]),f=we((e=>function(e,t){const r=Ao(e,t);return r?r.getAttribute(An.draggableId):null}(r,e)),[r]),g=we((e=>{const t=o.draggable.findById(e);return t?t.options:null}),[o.draggable]),m=we((function(){l.isClaimed()&&(l.tryAbandon(),"IDLE"!==n.getState().phase&&n.dispatch(wr()))}),[l,n]),b=we((()=>l.isClaimed()),[l]),h=De((()=>({canGetLock:u,tryGetLock:p,findClosestDraggableId:f,findOptionsForDraggable:g,tryReleaseLock:m,isLockClaimed:b})),[u,p,f,g,m,b]);for(let e=0;e<s.length;e++)s[e](h)}const Lo=e=>({onBeforeCapture:n=>{const o=()=>{e.onBeforeCapture&&e.onBeforeCapture(n)};t.version.startsWith("16")||t.version.startsWith("17")?o():r.flushSync(o)},onBeforeDragStart:e.onBeforeDragStart,onDragStart:e.onDragStart,onDragEnd:e.onDragEnd,onDragUpdate:e.onDragUpdate}),Mo=e=>({...un,...e.autoScrollerOptions,durationDampening:{...un.durationDampening,...e.autoScrollerOptions}});function Go(e){return e.current||c(!1),e.current}function _o(e){const{contextId:r,setCallbacks:n,sensors:o,nonce:i,dragHandleUsageInstructions:a}=e,s=t.useRef(null),l=Jn(e),d=we((()=>Lo(l.current)),[l]),u=we((()=>Mo(l.current)),[l]),p=function(e){const r=De((()=>Hn(e)),[e]),n=t.useRef(null);return t.useEffect((function(){const e=document.createElement("div");return n.current=e,e.id=r,e.setAttribute("aria-live","assertive"),e.setAttribute("aria-atomic","true"),T(e.style,Un),jn().appendChild(e),function(){setTimeout((function(){const t=jn();t.contains(e)&&t.removeChild(e),e===n.current&&(n.current=null)}))}}),[r]),we((e=>{const t=n.current;t&&(t.textContent=e)}),[])}(r),f=function(e){let{contextId:r,text:n}=e;const o=zn("hidden-text",{separator:"-"}),i=De((()=>function(e){let{contextId:t,uniqueId:r}=e;return`rfd-hidden-text-${t}-${r}`}({contextId:r,uniqueId:o})),[o,r]);return t.useEffect((function(){const e=document.createElement("div");return e.id=i,e.textContent=n,e.style.display="none",jn().appendChild(e),function(){const t=jn();t.contains(e)&&t.removeChild(e)}}),[i,n]),i}({contextId:r,text:a}),g=function(e,r){const n=De((()=>Bn(e)),[e]),o=t.useRef(null),i=t.useRef(null),a=we(Qe((e=>{const t=i.current;t||c(!1),t.textContent=e})),[]),s=we((e=>{const t=o.current;t||c(!1),t.textContent=e}),[]);Tn((()=>{(o.current||i.current)&&c(!1);const t=Mn(r),l=Mn(r);return o.current=t,i.current=l,t.setAttribute(`${Cn}-always`,e),l.setAttribute(`${Cn}-dynamic`,e),Ln().appendChild(t),Ln().appendChild(l),s(n.always),a(n.resting),()=>{const e=e=>{const t=e.current;t||c(!1),Ln().removeChild(t),e.current=null};e(o),e(i)}}),[r,s,a,n.always,n.resting,e]);const l=we((()=>a(n.dragging)),[a,n.dragging]),d=we((e=>{a("DROP"!==e?n.userCancel:n.dropAnimating)}),[a,n.dropAnimating,n.userCancel]),u=we((()=>{i.current&&a(n.resting)}),[a,n.resting]);return De((()=>({dragging:l,dropping:d,resting:u})),[l,d,u])}(r,i),m=we((e=>{Go(s).dispatch(e)}),[]),b=De((()=>O({publishWhileDragging:fr,updateDroppableScroll:mr,updateDroppableIsEnabled:br,updateDroppableIsCombineEnabled:hr,collectionStarting:gr},m)),[m]),h=function(){const e=De(Wn,[]);return t.useEffect((()=>function(){t.version.startsWith("16")||t.version.startsWith("17")?requestAnimationFrame(e.clean):e.clean()}),[e]),e}(),y=De((()=>an(h,b)),[h,b]),v=De((()=>En({scrollWindow:ln,scrollDroppable:y.scrollDroppable,getAutoScrollerOptions:u,...O({move:yr},m)})),[y.scrollDroppable,m,u]),x=Fn(r),I=De((()=>Qr({announce:p,autoScroller:v,dimensionMarshal:y,focusMarshal:x,getResponders:d,styleMarshal:g})),[p,v,y,x,d,g]);s.current=I;const D=we((()=>{const e=Go(s);"IDLE"!==e.getState().phase&&e.dispatch(wr())}),[]),w=we((()=>{const e=Go(s).getState();return"DROP_ANIMATING"===e.phase||"IDLE"!==e.phase&&e.isDragging}),[]);n(De((()=>({isDragging:w,tryAbort:D})),[w,D]));const S=we((e=>sn(Go(s).getState(),e)),[]),E=we((()=>zt(Go(s).getState())),[]),C=De((()=>({marshal:y,focus:x,contextId:r,canLift:S,isMovementAllowed:E,dragHandleUsageInstructionsId:f,registry:h})),[r,y,f,x,S,E,h]);return To({contextId:r,store:I,registry:h,customSensors:o||null,enableDefaultSensors:!1!==e.enableDefaultSensors}),t.useEffect((()=>D),[D]),t.createElement(Yn.Provider,{value:C},t.createElement(ye,{context:kn,store:I},e.children))}let $o=0;var Fo="useId"in t?function(){return t.useId()}:function(){return De((()=>""+$o++),[])};const Wo={dragging:5e3,dropAnimating:4500},ko=(e,t)=>t?Nr.drop(t.duration):e?Nr.snap:Nr.fluid,jo=(e,t)=>{if(e)return t?Or.opacity.drop:Or.opacity.combining},Uo=e=>null!=e.forceShouldAnimate?e.forceShouldAnimate:"SNAP"===e.mode;function Ho(e){return"DRAGGING"===e.type?function(e){const t=e.dimension.client,{offset:r,combineWith:n,dropping:o}=e,i=Boolean(n),a=Uo(e),s=Boolean(o),l=s?Tr.drop(r,i):Tr.moveTo(r);return{position:"fixed",top:t.marginBox.top,left:t.marginBox.left,boxSizing:"border-box",width:t.borderBox.width,height:t.borderBox.height,transition:ko(a,o),transform:l,opacity:jo(i,s),zIndex:s?Wo.dropAnimating:Wo.dragging,pointerEvents:"none"}}(e):(t=e,{transform:Tr.moveTo(t.offset),transition:t.shouldAnimateDisplacement?void 0:"none"});var t}function qo(e){const r=zn("draggable"),{descriptor:n,registry:o,getDraggableRef:i,canDragInteractiveElements:a,shouldRespectForcePress:s,isEnabled:l}=e,d=De((()=>({canDragInteractiveElements:a,shouldRespectForcePress:s,isEnabled:l})),[a,l,s]),u=we((e=>{const t=i();return t||c(!1),function(e,t,r){void 0===r&&(r=Se);const n=window.getComputedStyle(t),o=t.getBoundingClientRect(),i=Ue(o,n),a=je(i,r);return{descriptor:e,placeholder:{client:i,tagName:t.tagName.toLowerCase(),display:n.display},displaceBy:{x:i.marginBox.width,y:i.marginBox.height},client:i,page:a}}(n,t,e)}),[n,i]),p=De((()=>({uniqueId:r,descriptor:n,options:d,getDimension:u})),[n,u,d,r]),f=t.useRef(p),g=t.useRef(!0);Tn((()=>(o.draggable.register(f.current),()=>o.draggable.unregister(f.current))),[o.draggable]),Tn((()=>{if(g.current)return void(g.current=!1);const e=f.current;f.current=p,o.draggable.update(p,e)}),[p,o.draggable])}var Vo=t.createContext(null);function zo(e){const r=t.useContext(e);return r||c(!1),r}function Yo(e){e.preventDefault()}var Jo=e=>{const n=t.useRef(null),o=we((function(e){void 0===e&&(e=null),n.current=e}),[]),i=we((()=>n.current),[]),{contextId:a,dragHandleUsageInstructionsId:s,registry:l}=zo(Yn),{type:c,droppableId:d}=zo(Vo),u=De((()=>({id:e.draggableId,index:e.index,type:c,droppableId:d})),[e.draggableId,e.index,c,d]),{children:p,draggableId:f,isEnabled:g,shouldRespectForcePress:m,canDragInteractiveElements:b,isClone:h,mapped:y,dropAnimationFinished:v}=e;if(!h){qo(De((()=>({descriptor:u,registry:l,getDraggableRef:i,canDragInteractiveElements:b,shouldRespectForcePress:m,isEnabled:g})),[u,l,i,b,m,g]))}const x=De((()=>g?{tabIndex:0,role:"button","aria-describedby":s,"data-rfd-drag-handle-draggable-id":f,"data-rfd-drag-handle-context-id":a,draggable:!1,onDragStart:Yo}:null),[a,s,f,g]),I=we((e=>{"DRAGGING"===y.type&&y.dropping&&"transform"===e.propertyName&&(t.version.startsWith("16")||t.version.startsWith("17")?v():r.flushSync(v))}),[v,y]),D=De((()=>{const e=Ho(y),t="DRAGGING"===y.type&&y.dropping?I:void 0;return{innerRef:o,draggableProps:{"data-rfd-draggable-context-id":a,"data-rfd-draggable-id":f,style:e,onTransitionEnd:t},dragHandleProps:x}}),[a,x,f,y,I,o]),w=De((()=>({draggableId:u.id,type:u.type,source:{index:u.index,droppableId:u.droppableId}})),[u.droppableId,u.id,u.index,u.type]);return t.createElement(t.Fragment,null,p(D,y.snapshot,w))},Xo=(e,t)=>e===t,Ko=e=>{const{combine:t,destination:r}=e;return r?r.droppableId:t?t.droppableId:null};const Qo=e=>e.combine?e.combine.draggableId:null,Zo=e=>e.at&&"COMBINE"===e.at.type?e.at.combine.draggableId:null;function ei(e){return void 0===e&&(e=null),{isDragging:!1,isDropAnimating:!1,isClone:!1,dropAnimation:null,mode:null,draggingOver:null,combineTargetFor:e,combineWith:null}}const ti={mapped:{type:"SECONDARY",offset:Se,combineTargetFor:null,shouldAnimateDisplacement:!0,snapshot:ei(null)}};const ri=he((()=>{const e=function(){const e=Qe(((e,t)=>({x:e,y:t}))),t=Qe((function(e,t,r,n,o){return void 0===r&&(r=null),void 0===n&&(n=null),void 0===o&&(o=null),{isDragging:!0,isClone:t,isDropAnimating:Boolean(o),dropAnimation:o,mode:e,draggingOver:r,combineWith:n,combineTargetFor:null}})),r=Qe((function(e,r,n,o,i,a,s){return void 0===i&&(i=null),void 0===a&&(a=null),void 0===s&&(s=null),{mapped:{type:"DRAGGING",dropping:null,draggingOver:i,combineWith:a,mode:r,offset:e,dimension:n,forceShouldAnimate:s,snapshot:t(r,o,i,a,null)}}}));return(n,o)=>{if(Xn(n)){if(n.critical.draggable.id!==o.draggableId)return null;const t=n.current.client.offset,i=n.dimensions.draggables[o.draggableId],a=qt(n.impact),s=Zo(n.impact),l=n.forceShouldAnimate;return r(e(t.x,t.y),n.movementMode,i,o.isClone,a,s,l)}if("DROP_ANIMATING"===n.phase){const e=n.completed;if(e.result.draggableId!==o.draggableId)return null;const r=o.isClone,i=n.dimensions.draggables[o.draggableId],a=e.result,s=a.mode,l=Ko(a),c=Qo(a),d={duration:n.dropDuration,curve:Ar.drop,moveTo:n.newHomeClientOffset,opacity:c?Or.opacity.drop:null,scale:c?Or.scale.drop:null};return{mapped:{type:"DRAGGING",offset:n.newHomeClientOffset,dimension:i,dropping:d,draggingOver:l,combineWith:c,mode:s,forceShouldAnimate:null,snapshot:t(s,r,l,c,d)}}}return null}}(),t=function(){const e=Qe(((e,t)=>({x:e,y:t}))),t=Qe(ei),r=Qe((function(e,r,n){return void 0===r&&(r=null),{mapped:{type:"SECONDARY",offset:e,combineTargetFor:r,shouldAnimateDisplacement:n,snapshot:t(r)}}})),n=e=>e?r(Se,e,!0):null,o=(t,o,i,a)=>{const s=i.displaced.visible[t],l=Boolean(a.inVirtualList&&a.effected[t]),c=it(i),d=c&&c.draggableId===t?o:null;if(!s){if(!l)return n(d);if(i.displaced.invisible[t])return null;const o=Oe(a.displacedBy.point),s=e(o.x,o.y);return r(s,d,!0)}if(l)return n(d);const u=i.displacedBy.point,p=e(u.x,u.y);return r(p,d,s.shouldAnimate)};return(e,t)=>{if(Xn(e))return e.critical.draggable.id===t.draggableId?null:o(t.draggableId,e.critical.draggable.id,e.impact,e.afterCritical);if("DROP_ANIMATING"===e.phase){const r=e.completed;return r.result.draggableId===t.draggableId?null:o(t.draggableId,r.result.draggableId,r.impact,r.afterCritical)}return null}}();return(r,n)=>e(r,n)||t(r,n)||ti}),{dropAnimationFinished:Cr},null,{context:kn,areStatePropsEqual:Xo})(Jo);var ni=ri;function oi(e){return zo(Vo).isUsingCloneFor!==e.draggableId||e.isClone?t.createElement(ni,e):null}const ii=e=>t=>e===t,ai=ii("scroll"),si=ii("auto"),li=(e,t)=>t(e.overflowX)||t(e.overflowY),ci=e=>null==e||e===document.body||e===document.documentElement?null:(e=>{const t=window.getComputedStyle(e),r={overflowX:t.overflowX,overflowY:t.overflowY};return li(r,ai)||li(r,si)})(e)?e:ci(e.parentElement);var di=ci,ui=e=>({x:e.scrollLeft,y:e.scrollTop});const pi=e=>{if(!e)return!1;return"fixed"===window.getComputedStyle(e).position||pi(e.parentElement)};var fi=e=>({closestScrollable:di(e),isFixedOnPage:pi(e)});var gi=e=>{let{ref:t,descriptor:r,env:n,windowScroll:o,direction:i,isDropDisabled:a,isCombineEnabled:s,shouldClipSubject:l}=e;const c=n.closestScrollable,d=((e,t)=>{const r=He(e);if(!t)return r;if(e!==t)return r;const n=r.paddingBox.top-t.scrollTop,o=r.paddingBox.left-t.scrollLeft,i=n+t.scrollHeight,a=o+t.scrollWidth,s=Ge({top:n,right:a,bottom:i,left:o},r.border);return Fe({borderBox:s,margin:r.margin,border:r.border,padding:r.padding})})(t,c),u=je(d,o),p=(()=>{if(!c)return null;const e=He(c),t={scrollHeight:c.scrollHeight,scrollWidth:c.scrollWidth};return{client:e,page:je(e,o),scroll:ui(c),scrollSize:t,shouldClipSubject:l}})(),f=(e=>{let{descriptor:t,isEnabled:r,isCombineEnabled:n,isFixedOnPage:o,direction:i,client:a,page:s,closest:l}=e;const c=(()=>{if(!l)return null;const{scrollSize:e,client:t}=l,r=en({scrollHeight:e.scrollHeight,scrollWidth:e.scrollWidth,height:t.paddingBox.height,width:t.paddingBox.width});return{pageMarginBox:l.page.marginBox,frameClient:t,scrollSize:e,shouldClipSubject:l.shouldClipSubject,scroll:{initial:l.scroll,current:l.scroll,max:r,diff:{value:Se,displacement:Se}}}})(),d="vertical"===i?gt:mt;return{descriptor:t,isCombineEnabled:n,isFixedOnPage:o,axis:d,isEnabled:r,client:a,page:s,frame:c,subject:Ye({page:s,withPlaceholder:null,axis:d,frame:c})}})({descriptor:r,isEnabled:!a,isCombineEnabled:s,isFixedOnPage:n.isFixedOnPage,direction:i,client:d,page:u,closest:p});return f};const mi={passive:!1},bi={passive:!0};var hi=e=>e.shouldPublishImmediately?mi:bi;const yi=e=>e&&e.env.closestScrollable||null;function vi(){}const xi={width:0,height:0,margin:{top:0,right:0,bottom:0,left:0}},Ii=e=>{let{isAnimatingOpenOnMount:t,placeholder:r,animate:n}=e;const o=(e=>{let{isAnimatingOpenOnMount:t,placeholder:r,animate:n}=e;return t||"close"===n?xi:{height:r.client.borderBox.height,width:r.client.borderBox.width,margin:r.client.margin}})({isAnimatingOpenOnMount:t,placeholder:r,animate:n});return{display:r.display,boxSizing:"border-box",width:o.width,height:o.height,marginTop:o.margin.top,marginRight:o.margin.right,marginBottom:o.margin.bottom,marginLeft:o.margin.left,flexShrink:"0",flexGrow:"0",pointerEvents:"none",transition:"none"!==n?Nr.placeholder:null}};var Di=t.memo((e=>{const r=t.useRef(null),n=we((()=>{r.current&&(clearTimeout(r.current),r.current=null)}),[]),{animate:o,onTransitionEnd:i,onClose:a,contextId:s}=e,[l,c]=t.useState("open"===e.animate);t.useEffect((()=>l?"open"!==o?(n(),c(!1),vi):r.current?vi:(r.current=setTimeout((()=>{r.current=null,c(!1)})),n):vi),[o,l,n]);const d=we((e=>{"height"===e.propertyName&&(i(),"close"===o&&a())}),[o,a,i]),u=Ii({isAnimatingOpenOnMount:l,animate:e.animate,placeholder:e.placeholder});return t.createElement(e.placeholder.tagName,{style:u,"data-rfd-placeholder-context-id":s,onTransitionEnd:d,ref:e.innerRef})}));class wi extends t.PureComponent{constructor(){super(...arguments),this.state={isVisible:Boolean(this.props.on),data:this.props.on,animate:this.props.shouldAnimate&&this.props.on?"open":"none"},this.onClose=()=>{"close"===this.state.animate&&this.setState({isVisible:!1})}}static getDerivedStateFromProps(e,t){return e.shouldAnimate?e.on?{isVisible:!0,data:e.on,animate:"open"}:t.isVisible?{isVisible:!0,data:t.data,animate:"close"}:{isVisible:!1,animate:"close",data:null}:{isVisible:Boolean(e.on),data:e.on,animate:"none"}}render(){if(!this.state.isVisible)return null;const e={onClose:this.onClose,data:this.state.data,animate:this.state.animate};return this.props.children(e)}}var Si=e=>{const n=t.useContext(Yn);n||c(!1);const{contextId:o,isMovementAllowed:i}=n,a=t.useRef(null),s=t.useRef(null),{children:l,droppableId:d,type:u,mode:p,direction:f,ignoreContainerClipping:g,isDropDisabled:m,isCombineEnabled:b,snapshot:h,useClone:y,updateViewportMaxScroll:v,getContainerForClone:x}=e,I=we((()=>a.current),[]),D=we((function(e){void 0===e&&(e=null),a.current=e}),[]);we((()=>s.current),[]);const w=we((function(e){void 0===e&&(e=null),s.current=e}),[]),S=we((()=>{i()&&v({maxScroll:rn()})}),[i,v]);!function(e){const r=t.useRef(null),n=zo(Yn),o=zn("droppable"),{registry:i,marshal:a}=n,s=Jn(e),l=De((()=>({id:e.droppableId,type:e.type,mode:e.mode})),[e.droppableId,e.mode,e.type]),d=t.useRef(l),u=De((()=>Qe(((e,t)=>{r.current||c(!1);const n={x:e,y:t};a.updateDroppableScroll(l.id,n)}))),[l.id,a]),p=we((()=>{const e=r.current;return e&&e.env.closestScrollable?ui(e.env.closestScrollable):Se}),[]),f=we((()=>{const e=p();u(e.x,e.y)}),[p,u]),g=De((()=>$r(f)),[f]),m=we((()=>{const e=r.current,t=yi(e);e&&t||c(!1),e.scrollOptions.shouldPublishImmediately?f():g()}),[g,f]),b=we(((e,t)=>{r.current&&c(!1);const o=s.current,i=o.getDroppableRef();i||c(!1);const a=fi(i),d={ref:i,descriptor:l,env:a,scrollOptions:t};r.current=d;const u=gi({ref:i,descriptor:l,env:a,windowScroll:e,direction:o.direction,isDropDisabled:o.isDropDisabled,isCombineEnabled:o.isCombineEnabled,shouldClipSubject:!o.ignoreContainerClipping}),p=a.closestScrollable;return p&&(p.setAttribute(Rn.contextId,n.contextId),p.addEventListener("scroll",m,hi(d.scrollOptions))),u}),[n.contextId,l,m,s]),h=we((()=>{const e=r.current,t=yi(e);return e&&t||c(!1),ui(t)}),[]),y=we((()=>{const e=r.current;e||c(!1);const t=yi(e);r.current=null,t&&(g.cancel(),t.removeAttribute(Rn.contextId),t.removeEventListener("scroll",m,hi(e.scrollOptions)))}),[m,g]),v=we((e=>{const t=r.current;t||c(!1);const n=yi(t);n||c(!1),n.scrollTop+=e.y,n.scrollLeft+=e.x}),[]),x=De((()=>({getDimensionAndWatchScroll:b,getScrollWhileDragging:h,dragStopped:y,scroll:v})),[y,b,h,v]),I=De((()=>({uniqueId:o,descriptor:l,callbacks:x})),[x,l,o]);Tn((()=>(d.current=I.descriptor,i.droppable.register(I),()=>{r.current&&y(),i.droppable.unregister(I)})),[x,l,y,I,a,i.droppable]),Tn((()=>{r.current&&a.updateDroppableIsEnabled(d.current.id,!e.isDropDisabled)}),[e.isDropDisabled,a]),Tn((()=>{r.current&&a.updateDroppableIsCombineEnabled(d.current.id,e.isCombineEnabled)}),[e.isCombineEnabled,a])}({droppableId:d,type:u,mode:p,direction:f,isDropDisabled:m,isCombineEnabled:b,ignoreContainerClipping:g,getDroppableRef:I});const E=De((()=>t.createElement(wi,{on:e.placeholder,shouldAnimate:e.shouldAnimatePlaceholder},(e=>{let{onClose:r,data:n,animate:i}=e;return t.createElement(Di,{placeholder:n,onClose:r,innerRef:w,animate:i,contextId:o,onTransitionEnd:S})}))),[o,S,e.placeholder,e.shouldAnimatePlaceholder,w]),C=De((()=>({innerRef:D,placeholder:E,droppableProps:{"data-rfd-droppable-id":d,"data-rfd-droppable-context-id":o}})),[o,d,E,D]),A=y?y.dragging.draggableId:null,O=De((()=>({droppableId:d,type:u,isUsingCloneFor:A})),[d,A,u]);return t.createElement(Vo.Provider,{value:O},l(C,h),function(){if(!y)return null;const{dragging:e,render:n}=y,o=t.createElement(oi,{draggableId:e.draggableId,index:e.source.index,isClone:!0,isEnabled:!0,shouldRespectForcePress:!1,canDragInteractiveElements:!0},((t,r)=>n(t,r,e)));return r.createPortal(o,x())}())};const Ei=(e,t)=>e===t.droppable.type,Ci=(e,t)=>t.draggables[e.draggable.id];const Ai={mode:"standard",type:"DEFAULT",direction:"vertical",isDropDisabled:!1,isCombineEnabled:!1,ignoreContainerClipping:!1,renderClone:null,getContainerForClone:function(){return document.body||c(!1),document.body}};var Oi=he((()=>{const e={placeholder:null,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:!1,draggingOverWith:null,draggingFromThisWith:null,isUsingPlaceholder:!1},useClone:null},t={...e,shouldAnimatePlaceholder:!1},r=Qe((e=>({draggableId:e.id,type:e.type,source:{index:e.index,droppableId:e.droppableId}}))),n=Qe(((n,o,i,a,s,l)=>{const c=s.descriptor.id;if(s.descriptor.droppableId===n){const e=l?{render:l,dragging:r(s.descriptor)}:null,t={isDraggingOver:i,draggingOverWith:i?c:null,draggingFromThisWith:c,isUsingPlaceholder:!0};return{placeholder:s.placeholder,shouldAnimatePlaceholder:!1,snapshot:t,useClone:e}}if(!o)return t;if(!a)return e;const d={isDraggingOver:i,draggingOverWith:c,draggingFromThisWith:null,isUsingPlaceholder:!0};return{placeholder:s.placeholder,shouldAnimatePlaceholder:!0,snapshot:d,useClone:null}}));return(r,o)=>{let{droppableId:i,type:a=Ai.type,isDropDisabled:s=Ai.isDropDisabled,renderClone:l=Ai.renderClone}=o;const c=i,d=!s;if(Xn(r)){const e=r.critical;if(!Ei(a,e))return t;const o=Ci(e,r.dimensions),i=qt(r.impact)===c;return n(c,d,i,i,o,l)}if("DROP_ANIMATING"===r.phase){const e=r.completed;if(!Ei(a,e.critical))return t;const o=Ci(e.critical,r.dimensions);return n(c,d,Ko(e.result)===c,qt(e.impact)===c,o,l)}if("IDLE"===r.phase&&r.completed&&!r.shouldFlush){const n=r.completed;if(!Ei(a,n.critical))return t;const o=qt(n.impact)===c,i=Boolean(n.impact.at&&"COMBINE"===n.impact.at.type),s=n.critical.droppable.id===c;return o?i?e:t:s?e:t}return t}}),{updateViewportMaxScroll:e=>({type:"UPDATE_VIEWPORT_MAX_SCROLL",payload:e})},((e,t,r)=>{const n={...r,...e,...t};console.log("CHUJ");for(const e in Ai)void 0===n[e]&&(n[e]=Ai[e]);return n}),{context:kn,areStatePropsEqual:Xo})(Si);e.DragDropContext=function(e){const r=Fo(),n=e.dragHandleUsageInstructions||b.dragHandleUsageInstructions;return t.createElement(d,null,(o=>t.createElement(_o,{nonce:e.nonce,contextId:r,setCallbacks:o,dragHandleUsageInstructions:n,enableDefaultSensors:e.enableDefaultSensors,sensors:e.sensors,onBeforeCapture:e.onBeforeCapture,onBeforeDragStart:e.onBeforeDragStart,onDragStart:e.onDragStart,onDragUpdate:e.onDragUpdate,onDragEnd:e.onDragEnd,autoScrollerOptions:e.autoScrollerOptions},e.children)))},e.Draggable=function(e){const r="boolean"!=typeof e.isDragDisabled||!e.isDragDisabled,n=Boolean(e.disableInteractiveElementBlocking),o=Boolean(e.shouldRespectForcePress);return t.createElement(oi,T({},e,{isClone:!1,isEnabled:r,canDragInteractiveElements:n,shouldRespectForcePress:o}))},e.Droppable=Oi,e.resetServerContext=function(){"useId"in t||($o=0,qn=0)},e.useKeyboardSensor=mo,e.useMouseSensor=uo,e.useTouchSensor=vo}));
diff --git a/package.json b/package.json
index 98f3c04d7debbc756f68ab441a9f029749665c67..f9d34258d9592177335393639092fce9c4e9d82b 100644
--- a/package.json
+++ b/package.json
@@ -210,5 +210,10 @@
   "license": "Apache-2.0",
   "jest-junit": {
     "output": "test-reports/junit/js-test-results.xml"
+  },
+  "pnpm": {
+    "patchedDependencies": {
+      "@hello-pangea/dnd@16.2.0": "patches/@hello-pangea__dnd@16.2.0.patch"
+    }
   }
 }
diff --git a/src/view/droppable/connected-droppable.ts b/src/view/droppable/connected-droppable.ts
index 4404c7ccb535e8a435c8e51a36cc009efbe77e3a..ee56a0c752fa4b1acc724a267f85eda067743814 100644
--- a/src/view/droppable/connected-droppable.ts
+++ b/src/view/droppable/connected-droppable.ts
@@ -41,6 +41,22 @@ const getDraggable = (
   dimensions: DimensionMap,
 ): DraggableDimension => dimensions.draggables[critical.draggable.id];
 
+function getBody(): HTMLElement {
+  invariant(document.body, 'document.body is not ready');
+  return document.body;
+}
+
+const defaultProps: DefaultProps = {
+  mode: 'standard',
+  type: 'DEFAULT',
+  direction: 'vertical',
+  isDropDisabled: false,
+  isCombineEnabled: false,
+  ignoreContainerClipping: false,
+  renderClone: null,
+  getContainerForClone: getBody,
+};
+
 // Returning a function to ensure each
 // Droppable gets its own selector
 export const makeMapStateToProps = (): Selector => {
@@ -135,13 +151,19 @@ export const makeMapStateToProps = (): Selector => {
     },
   );
 
-  const selector = (state: State, ownProps: InternalOwnProps): MapProps => {
+  const selector = (
+    state: State,
+    {
+      droppableId,
+      type = defaultProps.type,
+      isDropDisabled = defaultProps.isDropDisabled,
+      renderClone = defaultProps.renderClone,
+    }: InternalOwnProps,
+  ): MapProps => {
     // not checking if item is disabled as we need the home list to display a placeholder
 
-    const id: DroppableId = ownProps.droppableId;
-    const type: TypeId = ownProps.type;
-    const isEnabled = !ownProps.isDropDisabled;
-    const renderClone: DraggableChildrenFn | null = ownProps.renderClone;
+    const id: DroppableId = droppableId;
+    const isEnabled = !isDropDisabled;
 
     if (isDragging(state)) {
       const critical: Critical = state.critical;
@@ -228,22 +250,6 @@ const mapDispatchToProps: DispatchProps = {
   updateViewportMaxScroll: updateViewportMaxScrollAction,
 };
 
-function getBody(): HTMLElement {
-  invariant(document.body, 'document.body is not ready');
-  return document.body;
-}
-
-const defaultProps: DefaultProps = {
-  mode: 'standard',
-  type: 'DEFAULT',
-  direction: 'vertical',
-  isDropDisabled: false,
-  isCombineEnabled: false,
-  ignoreContainerClipping: false,
-  renderClone: null,
-  getContainerForClone: getBody,
-};
-
 // Abstract class allows to specify props and defaults to component.
 // All other ways give any or do not let add default props.
 // eslint-disable-next-line
@@ -261,8 +267,22 @@ const ConnectedDroppable = connect(
   makeMapStateToProps,
   // no dispatch props for droppable
   mapDispatchToProps,
-  // mergeProps - using default
-  null as any,
+  // default react-redux mergeProps and now-deprecated react defaultProps resolution
+  (stateProps, dispatchProps, ownProps) => {
+    const props: Record<string, unknown> = {
+      ...ownProps,
+      ...stateProps,
+      ...dispatchProps,
+    };
+    for (const propName in defaultProps) {
+      if (props[propName] === undefined) {
+        // @ts-expect-error property enumeration from an object with known keys
+        // doesn't actually type the key string with a union of known keys
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props as any;
+  },
   {
     // Ensuring our context does not clash with consumers
     context: StoreContext as any,
@@ -274,6 +294,4 @@ const ConnectedDroppable = connect(
   // FIXME: Typings are really complexe
 )(Droppable) as unknown as FunctionComponent<DroppableProps>;
 
-ConnectedDroppable.defaultProps = defaultProps;
-
 export default ConnectedDroppable;